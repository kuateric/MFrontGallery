 * fichier :  implicitnorton.dgibi 
 *======================================================================= 
 * 
 * CAS TEST DE VALIDATION DE LA PROCEDURE PASAPAS 
 * POUR UN ESSAI DE TRACTION UNIAXIALE A VITESSE DE DEFORMATION IMPOSEE 
 * SUR UNE LOI DE NORTON 
 * 
 *======================================================================= 
   
 'OPTION' 'ERREUR' 'FATAL'; 
   
 *======================================================================= 
 * 
 *                       PROCEDURES DEPENDANTES 
 * 
 *======================================================================= 
   
   
 DEBPROC EVO2FICH EV1*EVOLUTION FICOUT*MOT; 
   PROG1=EXTR EV1 ABSC; 
   PROG2=EXTR EV1 ORDO; 
   NB=DIME PROG1; 
   I=0; 
   ii=vale impr; 
   OPTI IMPR 10 IMPR FICOUT; 
   REPETER BOU1 NB; 
     I=I+1; 
     X1=EXTR PROG1 I; 
     Y1=EXTR PROG2 I; 
     MESSAGE X1 Y1 ; 
     FIN BOU1; 
   OPTI IMPR II; 
 FINPROC; 
   
 *======================================================================= 
 * 
 *                      JEU DE DONNEES PRINCIPAL 
 * 
 *======================================================================= 
   
 *----------------------------------------------------------------------- 
 * 0 - Maillage 
 *     PLAQUE CARREE    COTE : 1 m    EPAISSEUR : 1 cm 
   
 'OPTION'  'DIMENSION'  3 'ELEM' CUB8 'MODELISER' TRIDIM ; 
   
 *----------------------------------------------------------------------- 
 * Maillage 
 *----------------------------------------------------------------------- 
   
 lx= 1.0 ; 
 ly= 1.0 ; 
 lz= 1.0 ; 
 nx = 1; 
 ny = 1; 
 nz = 1; 
   
 pO  = 0. 0. 0.; 
 l1 = 'DROIT' pO (lx 0. 0.) nx ; 
 l3 = l1 'PLUS' (0. ly 0.); 
   
 s1 = 'TRANSLATION' l1 (0. ly 0.) ny ; 
 v1 = s1 'VOLUME' nz 'TRANSLATION'(0. 0. lz) ; 
 l2 = s1 'FACE' 4; 
 l4 = l2 'PLUS' (lx 0. 0.); 
 s2 = v1 'FACE' 2; 
   
 s4 = 'TRANSLATION' l1 (0. 0. lz) nz ; 
 s5 = 'TRANSLATION' l2 (0. 0. lz) nz ; 
 s6 = 'TRANSLATION' l3 (0. 0. lz) nz ; 
 s7 = 'TRANSLATION' l4 (0. 0. lz) nz ; 
   
 sy1 = s4; 
 sy2 = s6; 
 sx1 = s5; 
 sx2 = s7; 
 sz1 = s1; 
 sz2 = s2; 
   
 'ELIM' (v1 'ET'  sx1 'ET' sx2 'ET' sy1 'ET' sy2 'ET' sz1 'ET' sz2 'ET' 
         pO 'ET'  l1 'ET'  l2 'ET'  l3 'ET'  l4) 1.e-10; 
   
 *----------------------------------------------------------------------- 
 * Comportement loi de norton 
 *----------------------------------------------------------------------- 
   
 * 1 Definition du modele 
   
 lib = ('VENV' 'library'); 
 coel    = 'MOTS' 'YOUN' 'NU' 'RHO' 'ALPH' 'TALP' 'TREF' 'A' 'E'; 
 statev  = 'MOTS' 'EEXX' 'EEYY' 'EEZZ' 'EEXY' 'EEXZ' 'EEYZ' 'P'; 
 params  = 'MOTS' 'T'; 
 mo_meca = 'MODELISER' v1 'MECANIQUE' 'ELASTIQUE' 
                     'NON_LINEAIRE' 'UTILISATEUR' 
                     'LIB_LOI' lib 
                     'FCT_LOI' 'umatimplicitnorton' 
                     'C_MATERIAU' coel 'C_VARINTER' statev 
                     'PARA_LOI'  params 'CONS' M; 
   
 * 2 Affectation des constantes de materiau 
   
 ma_meca = 'MATERIAU' mo_meca 'YOUN' 150.e9 'NU' 0.333 
                     'RHO' 0. 'ALPH' 0. 'TALP' 0 'TREF' 0 
                     'A' 8e-67 'E' 8.2; 
   
 * 3 Definition des conditions aux limites et chargements 
   
 * 1.4.0 Creation de progressions pour la ponderation des chargements, 
 *       definissant autant d'etats a calculer 
   
 tmax    = 2500.; 
 NPAS    = 20.; 
 L_temps = PROG 0.0 'PAS' (tmax/NPAS)  tmax; 
 L_t     = PROG 0.0 tmax; 
 L_d     = PROG 0.0 1.0; 
   
 * 1.4.1 Blocages mecaniques et deplacement axial impose 
   
 uz3 =  2.5e-2; 
 clim1 = (BLOQ sz1 'UZ' ) et (BLOQ sx1 'UX') et ('BLOQUE' sy1 'UY') ; 
 clim2 = BLOQ pO 'DEPL'; 
 clim3 = BLOQ sz2 'UZ' ; 
 depi3 = DEPI clim3 uz3 ; 
 charmeca = CHAR 'DIMP' ('EVOL' 'MANUEL' L_t L_d) depi3 ; 
   
 * 1.4.2 Chargement en temp√©rature 
   
 TEK = 293.15; 
 THE1 = MANU 'CHPO' V1 1 'T' TEK ; 
 EV2 = EVOL MANU (prog 0 tmax) (prog 1. 1.) ; 
 CHARTHER = CHAR 'T' THE1 EV2 ; 
   
 * 1.5 Resolution par PASAPAS 
   
 * 
 TAB1                         = 'TABL' ; 
 TAB1 . 'GRANDS_DEPLACEMENTS' = FAUX ; 
 TAB1 . 'MODELE'              = mo_meca ; 
 TAB1 . 'CARACTERISTIQUES'    = ma_meca ; 
 TAB1 . 'EPSILON'             = 'LINEAIRE'; 
 TAB1 . 'BLOCAGES_MECANIQUES' = clim1 ET clim2 ET clim3 ; 
 TAB1 . 'CHARGEMENT'          = charmeca 'ET' charther; 
 TAB1 . 'TEMPS_CALCULES'      = L_temps; 
 TAB1 . 'TEMPERATURES'        = 'TABLE'; 
 TAB1 . 'TEMPERATURES'. 0     = 'MANU' 'CHPO' v1 'T' 293.15; 
   
 PASAPAS TAB1; 
 * PASAPAS   PROCEDUR  PASCAL    20/12/04    21:15:00     10803 
   
 'DEBP' PASAPAS  PRECED*'TABLE'; 
 'SAUT' 1 'LIGNE'; 
 'MESS' 
 '------------------ DEBUT DE LA PROCEDURE PASAPAS --------------------'; 
 ************************************************************************ 
 *                                                                      * 
 *                                                                      * 
 *** PRECED      objet de type TABLE                                    * 
 *               C'est une table donnant , les arguments d'entrees, les * 
 *               options, puis les  resultats des pas precedents        * 
 *                                                                      * 
 * Etat initial au debut du pas de temps decrit par le MCHELM WTAB.ETAT1* 
 * champs de materiaux :                                                * 
 *     WTAB.'MAT_REF' materiau etat a la temperature de REFERENCE       * 
 *     WTAB.'MAT0'    materiau etat debut de calcul                     * 
 *     WTAB.'MAT1'    materiau fin du pas de temps                      * 
 *                                                                      * 
 ************************************************************************ 
   
 ****************   I PARTIE   ****************************************** 
   
 *---------- attribution des valeurs par defaut et verifs elementaires 
 PAS_DEFA PRECED ; 
 *--------  initialisation du pas precedent si besoin et creation des tables de sorties. 
 PAS_INIT PRECED ; 
   
 WTAB  = PRECED.'WTABLE'      ; 
 conti = PRECED.'CONTINUATION'; 
 estim = PRECED.'ESTIMATION'  ; 
 * 
 WTAB.'GE0_DEB'=WTAB.'FOR0'; 
 'SI'( WTAB.'GRANDS_DEPLACEMENTS' 'OU'  WTAB.'FEFP_FORMULATION'); 
   'SI' ( 'EXIS' conti 'DEPLACEMENTS'); 
     WTAB.'GE0_DEB'= 'FORME' conti . 'DEPLACEMENTS'; 
   'FINSI'; 
 'FINSI'; 
 'FORM' WTAB.'FOR0'; 
   
 *--------- quel est le delta-temps du dernier pas calcule ? --------- 
 'SI' ('EGA' WTAB.'DT' ('MOT' 'INCONNU')); 
    DELTAN = 0.D0 ; 
    WTAB.'DT' = DELTAN ; 
 'SINON'; 
    DELTAN= WTAB.'DT'; 
 'FINSI'; 
   
 *------------Appel a une procedure utilisateur PERSO1 
  'SI' WTAB.'PROCEDURE_PERSO1'; 
     PRECED.'PERSO1_APPEL' = 1 ; 
     PERSO1 PRECED ; 
    'SI' ('EXIS' PRECED 'ARRET') ; 
       WTAB.'ARRET' = PRECED.'ARRET' ; 
    'FINSI' ; 
  'FINSI'; 
   
 * ------------Appel a une procedure utilisateur REEV_MEC 
  'SI' WTAB.'PROCEDURE_REEV_MEC' ; 
     REEV_MEC PRECED 0 ; 
  'FINSI' ; 
   
 * ------------Appel a une procedure utilisateur REEV_THE 
  'SI' WTAB.'PROCEDURE_REEV_THE' ; 
     REEV_THE PRECED 0 ; 
  'FINSI' ; 
   
 *---------   initialisation ETAT ET MATERIAUX 
 WTAB.'ETAT0'   = PAS_ETAT PRECED WTAB.'TEMPS0'            ; 
 WTAB.'ETAT1'   = WTAB.'ETAT0'                             ; 
 WTAB.'MAT0'    = PAS_MATE PRECED WTAB.'ETAT0'             ; 
 WTAB.'MAT1'    = WTAB.'MAT0'                              ; 
   
 *---------   initialisation deformation thermique de reference 
 'SI' WTAB.'FOR_MECA' ; 
   'SI' (WTAB.'CHAR_THE' 'OU'  WTAB.'FOR_THER' ) ; 
     'SI' ('EGA' WTAB.'ETREF' 'INCONNU'); 
        WTAB.'ETAT_REF'= PAS_ETAT PRECED WTAB.'TEMPS0' 'REFERENCE'; 
        WTAB.'MAT_REF' = PAS_MATE PRECED WTAB.'ETAT_REF'          ; 
        WTAB.'ETREF'   ='EPTH' WTAB.'MO_TOT' WTAB.'MAT_REF' WTAB.'TEMPERATURE_REFERENCE' ; 
     'FINS' ; 
   
     'SI' WTAB.'POR1'; 
       'SI' ('EGA' ('TYPE' WTAB.'TET1') 'CHPOINT'); 
          TET1 ='CHAN' 'CHAM' WTAB.'TET1' WTAB.'MO_TOT' 'STRESSES' 'TEMPERATURES' ; 
       'FINS'; 
        WTAB.'MSRTHER1'= PAS_EPTH PRECED WTAB.'MO_TOT' WTAB.'MAT0' TET1 ; 
     'FINS' ; 
   'FINS' ; 
 'FINS' ; 
   
 **************************   II PARTIE  ************************* 
 ****************************************************************** 
 ******************* boucle sur les pas de temps  ***************** 
 ****************************************************************** 
   
 * ------------quelques initialisations de l'algorithme 
 PASFINAL = 0 ; 
 IPAS     = 0 ; 
 ICHG     = 0 ; 
 IAUTO    = 1 ; 
 IREREDU  = VRAI; 
 TEMP0    = WTAB.'TEMPS0'; 
 ISAUV    = VRAI; 
 DTV      =('EXTR' WTAB.'TEMPS_CALCULES' 1) - TEMP0 ; 
 'SI' ( DTV '<' 1.e-15 ); 
   'SI' WTAB.'FREQUENTIEL' ; 
      DTV = 1.e-14 ; 
   'SINON' ; 
      DTV =('EXTR' WTAB.'TEMPS_CALCULES' 2) - TEMP0 ; 
   'FINSI'; 
 'FINSI'; 
 WTAB.'ARRET'   = FAUX; 
 WTAB.'AUTODEUX'= FAUX; 
 WTAB.'CONV'    = VRAI; 
 DT_AVANT       = DTV ; 
 WTAB.'NOMBRE_ITERATIONS'=12; 
   
 * Attention Bizarre : RFROT est initialise ici et utilise dans UNPAS ???? 
 RFROT=0; 
   
 *---------- debut boucle sur pas de temps 
 'REPETER' BEXTERN  ; 
   
 *---recherche du temps a calculer TI 
     NPAS='DIME' WTAB.'TEMPS_CALCULES'; 
     ICHG=ICHG + 1;  WTAB.'ICHG'= ICHG; 
     'SI' ( ICHG '>' NPAS) ; 'QUITTER' BEXTERN; 'FINSI'; 
     TI = 'EXTRAIRE'  WTAB.'TEMPS_CALCULES' ICHG ; 
     TIV=TI; 
     'SI' (WTAB.'FREQUENTIEL') ; 
        'SI'  (TI '<' TEMP0 ) ;  'ITERER'  BEXTERN ; 'FINSI' ; 
     'SINON' ; 
     'SI'  ((TI '<' TEMP0 ) 'OU' (TI 'EGA' PRECED.'TEMPS'. 0)); 
         'ITERER'  BEXTERN ; 
     'FINSI'; 'FINSI'; 
   
 *---ajustement du pas en fonction du nombre d iteration du pas precedent 
     PASFINAL=PASFINAL+1; 
     'SI' WTAB.'PAS_AJUSTE'; 
        DTV=DT_AVANT; 
        'SI' WTAB.'CONV'; 
            'SI' (WTAB.'NOMBRE_ITERATIONS' > 20); 
                DTV=DTV'/' (2. ** 0.5); 
            'FINSI'; 
            'SI' (WTAB.'NOMBRE_ITERATIONS' <  7); 
               'SI' IREREDU; 
                   DTV=DTV '*' (2. ** 0.5); 
               'FINSI'; 
            'FINSI'; 
            DT_AVANT= DTV; 
            IREREDU=VRAI; 
        'SINON'; 
            DTV=0.0000000001D0* DT_AVANT; 
            DT_AVANT= DT_AVANT /2.; 
            IREREDU=FAUX; 
        'FINSI'; 
        TTI = DTV* 1.0000000001 + TEMP0; 
        'SI' ( TTI '<EG' TIV ); 
           TI=TTI; 
           PASFINAL=0; 
        'FINSI'; 
     'FINSI'; 
      estim.'TEMPS'=TI; 
     'SI' (PASFINAL '>EG' 1.5) ; DT_AVANT= TI-TEMP0; 'FINSI'; 
     WTAB.'T_FINAL'= TI; 
     WTAB.'DT_INIT' = TI-TEMP0; 
     'SI'((WTAB.'CONSOLIDATION' 'OU' WTAB.'DYNAMIQUE') 
          'ET' (WTAB.'DT_INIT' 'EGA' 0.)); 
            'ITERER' BEXTERN; 
     'FINSI'; 
     WTAB.'DT'= WTAB.'DT_INIT'; 
   
 *---compteur IPAS des pas de temps calcules 
     IPAS = IPAS + 1; 
     WTAB.'PAS'=IPAS; 
   
 *---Mise a jour du modele si chargement de type MODE : 
     'SI' (WTAB.'CHAR_MODE') ; 
        MODEVOL1  = 'TIRE' WTAB.'CHARGEMENT' 'MODE' TI ; 
          WTAB.'MODELE' = MODEVOL1 ; 
   
       'SI' (WTAB.'CHAR_MATE') ; 
          MATEVOL1  = 'TIRE' WTAB.'CHARGEMENT' 'MATE' TI ; 
            WTAB.'CARACTERISTIQUES' = MATEVOL1 ; 
       'FINSI' ; 
   
        PAS_MODL PRECED ; 
   
 *      On sauvegarde les modeles successifs pour analyse resultats : 
        ESTIM.'MODELES'   = WTAB.'MODELE' ; 
 *       ESTIM.'MAILLAGES' = 'EXTR' WTAB.'MODELE' 'MAIL' ; 
   
     'FINSI' ; 
   
 *--- Mise a jour blocages passes dans chargement 
 *   Cas BLOCAGES_MECANIQUES (BLOM) 
     'SI' (WTAB.'CHAR_BLOM') ; 
 *      mess '  ***** TIRE CHAR BLOM au temps ' TI ; 
 *     BLOM du pas precedent : 
       'SI' ('EXIS' WTAB 'BLOM') ; 
         BLOM0    = WTAB . 'BLOM' ; 
       'SINON' ; 
         BLOM0    = 'VIDE' 'RIGIDITE' ; 
       'FINSI' ; 
 *     BLOM du pas courant : 
       BLOM1    = 'TIRE' WTAB.'CHARGEMENT' 'BLOM' TI ; 
       WTAB . 'BLOM' = BLOM1 ; 
   
 *     Si different, on remplace dans BLOCAGES_MECANIQUES et op. resolution RRRR 
       DBLOM01  = BLOM0 diff BLOM1 ; 
       'SI' ('NON' ('VIDE' DBLOM01)) ; 
 mess '  ***** Modif. blocages mecaniques' ; 
 *       On ne remplace que ce qui est necessaire : 
         BLOM01   = BLOM0 'INTE' BLOM1 ; 
         DBLOM0   = BLOM0 'DIFF' BLOM01 ; 
         DBLOM1   = BLOM1 'DIFF' BLOM01 ; 
 *       MAJ Blocages Mecaniques : 
         BLOMEC1  = WTAB.'BLOCAGES_MECANIQUES' ; 
         WTAB.'BLOCAGES_MECANIQUES' = (BLOMEC1 'DIFF' DBLOM0) 'ET' DBLOM1 ; 
   
 *       MAJ Operateur Resolution : 
         'SI' ('EXIS' WTAB 'RRRR') ; 
           RRRR = WTAB.'RRRR' ; 
           WTAB.'RRRR' = (RRRR 'DIFF' DBLOM0) 'ET' DBLOM1 ; 
         'FINSI' ; 
       'FINSI' ; 
     'FINSI' ; 
   
 *   Cas BLOCAGES_THERMIQUES (BLOT) 
     'SI' (WTAB.'CHAR_BLOT') ; 
 *      mess '  ***** TIRE CHAR BLOT au temps ' TI ; 
 *     BLOT du pas precedent : 
       'SI' ('EXIS' WTAB 'BLOT') ; 
         BLOT0    = WTAB . 'BLOT' ; 
       'SINON' ; 
         BLOT0    = 'VIDE' 'RIGIDITE' ; 
       'FINSI' ; 
 *     BLOT du pas courant : 
       BLOT1    = 'TIRE' WTAB.'CHARGEMENT' 'BLOT' TI ; 
       WTAB . 'BLOT' = BLOT1 ; 
   
 *     Si different, on remplace dans BLOCAGES_THERMIQUES 
       DBLOT01  = BLOT0 diff BLOT1 ; 
       'SI' ('NON' ('VIDE' DBLOT01)) ; 
 *       On ne remplace que ce qui est necessaire : 
         BLOT01   = BLOT0 'INTE' BLOT1 ; 
         DBLOT0   = BLOT0 'DIFF' BLOT01 ; 
         DBLOT1   = BLOT1 'DIFF' BLOT01 ; 
 *       MAJ Blocages THERMIQUES : 
         BLOTEC1  = WTAB.'BLOCAGES_THERMIQUES' ; 
         WTAB.'BLOCAGES_THERMIQUES' = (BLOTEC1 'DIFF' DBLOT0) 'ET' DBLOT1 ; 
       'FINSI' ; 
     'FINSI' ; 
   
 *   Cas BLOCAGES_DIFFUSIONS (BLOD) 
     'SI' (WTAB.'CHAR_BLOD') ; 
 *      mess '  ***** TIRE CHAR BLOD au temps ' TI ; 
 *     BLOD du pas precedent : 
       'SI' ('EXIS' WTAB 'BLOD') ; 
         BLOD0    = WTAB . 'BLOD' ; 
       'SINON' ; 
         BLOT0    = 'VIDE' 'RIGIDITE' ; 
       'FINSI' ; 
 *     BLOD du pas courant : 
       BLOD1    = 'TIRE' WTAB.'CHARGEMENT' 'BLOD' TI ; 
       WTAB . 'BLOD' = BLOD1 ; 
   
 *     Si different, on remplace dans BLOCAGES_DIFFUSIONS 
       DBLOD01  = BLOD0 diff BLOD1 ; 
       'SI' ('NON' ('VIDE' DBLOD01)) ; 
 *       On ne remplace que ce qui est necessaire : 
         BLOD01   = BLOD0 'INTE' BLOD1 ; 
         DBLOD0   = BLOD0 'DIFF' BLOD01 ; 
         DBLOD1   = BLOD1 'DIFF' BLOD01 ; 
 *       MAJ Blocages DIFFUSION : 
         BLODEC1  = WTAB.'BLOCAGES_DIFFUSIONS' ; 
         WTAB.'BLOCAGES_DIFFUSIONS' = (BLODEC1 'DIFF' DBLOD0) 'ET' DBLOD1 ; 
       'FINSI' ; 
     'FINSI' ; 
   
 *---on se place dans la configuration deformee 
    'SI'( WTAB.'GRANDS_DEPLACEMENTS' 'OU'  WTAB.'FEFP_FORMULATION'); 
       'SI' (WTAB.'RECALCUL'); 
         'SI' ('EGA'  ( 'TYPE' WTAB.'GE0_DEB')  'CONFIGUR'); 
           'FORM'  WTAB.'GE0_DEB'; 
         'FINSI'; 
       'FINSI'; 
     'FINSI'; 
   
 *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
 *++++++++++++++++++ BOUCLE interne de bouclage mec_ther ++++++++++++++ 
 *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
      I_BOTH = 0 ; 
      'REPETER' BO_BOTH WTAB.'BOU_METH' ; 
         I_BOTH = I_BOTH + 1 ; 
 * 
 *  re-initialisation de WTAB.'CHARGEMENT' en tete de boucle mec-ther 
 * 
        'SI' WTAB.'CONVERGENCE_MEC_THE' ; 
           WTAB.'CHARGEMENT' = WTAB . 'CHARGEMENT_I' ; 
        'FINSI'; 
   
 *######CALCUL D'UN PAS SI IL Y A DE LA THERMIQUE #################### 
        'SI' (WTAB.'FOR_THER' 'OU' WTAB.'FOR_DIFF') ; 
          'SI' WTAB.'FOR_MECA' ; 
 *---------- en cas de convergence mecanique thermique 
            'SI' (I_BOTH > 1) ; 
 *----------   reprise de la configuration meca de la derniere estimation 
 *             du pas present si coherence mecanique/thermique 
              'SI' ('EXIS' estim 'FOR' ); 
                 WTAB .'RECARI'  = VRAI ; 
                 WTAB .'RECADET' = VRAI ; 
                 WTAB.'REA_GEOM' = VRAI ; 
                'FORM' estim.'FOR'      ; 
              'FINSI'; 
            'FINSI' ; 
          'FINSI' ; 
   
          'SI' (TI 'NEG' TEMP0); 
            'SI' ('NON' ('EXISTE' PRECED 'PAS_MAX')); 
              WTAB.'TEM_CALC' = 'PROG' TI; 
            'SINON'; 
              'SI' ((TEMP0 + PRECED.'PAS_MAX') '>EG' TI); 
                 WTAB.'TEM_CALC' = 'PROG' TI; 
              'SINON'; 
                 WTAB.'TEM_CALC' = 'PROG' TEMP0 
                                    'PAS'  PRECED.'PAS_MAX'  TI; 
                 WTAB.'TEM_CALC' = 'ENLE'  WTAB.'TEM_CALC' 1; 
              'FINSI'; 
            'FINSI'; 
 *----- Appel a la procedure thermique (lineaire ou nonlineaire) ---- 
            'SI' ('NON' WTAB.'COUPLAGE'); 'MENAGE'; 'FINSI'; 
            'SI' ('EGA' WTAB.'PROCEDURE_THERMIQUE' 'NONLINEAIRE'); 
               CHTER = TRANSNON PRECED; 
            'FINSI'; 
            'SI' ('EGA' WTAB.'PROCEDURE_THERMIQUE' 'LINEAIRE'); 
              CHTER = TRANSLIN PRECED; 
            'FINSI'; 
            'SI' ('EGA' WTAB.'PROCEDURE_THERMIQUE' 'DUPONT'); 
               WTAB.'NOUV_PAS' = ('EXTR' WTAB.'TEM_CALC' 1) - TEMP0; 
               CHTER = DUPONT2 PRECED; 
            'FINSI'; 
   
 *           Verification d'une erreur en sortie 
            'SI' CHTER.'ERREUR'; 
               'ERREUR' ' '; 
            'FINSI'; 
   
 *          Modele Metallurgique (T.L. en juin 2018) 
            'SI' WTAB.'FOR_METALLU' ; 
               estim.'PROPORTIONS_PHASES' = CHTER.'PROPORTIONS_PHASES' ; 
            'FINSI'; 
   
            'SI' WTAB.'PHASE'; 
               WTAB.'PROPPHAS'          = CHTER.'PROPPHAS' ; 
               estim.'PROPORTIONS_PHASE'= CHTER.'PROPPHAS' ; 
            'FINSI' ; 
   
            'SI' WTAB.'FOR_THER' ; 
              WTAB.'TET2'=CHTER.'INITIAL(2)' ; 
              WTAB.'CLIT'=CHTER.'CLIT' ; 
              'SI' ('EGA' WTAB.'PROCEDURE_THERMIQUE' 'NONLINEAIRE') ; 
                'SI' ('NEG' WTAB.'RIBLO_T' 'INCONNU'); 
                   WTAB.'RIBLO_T'       = CHTER.'RIBLO_T'       ; 
                   WTAB.'LISEA_T'       = CHTER.'LISEA_T'       ; 
                'FINSI' ; 
              'FINSI' ; 
              'SI' WTAB.'RAYO' ; 
                 WTAB.'RAYONNEMENT' = CHTER.'RAYONNEMENT' ; 
              'FINSI' ; 
                'FINSI' ; 
            'SI' WTAB.'FOR_DIFF' ; 
              WTAB.'CO2' =CHTER.'CO2'; 
              WTAB.'CLID'=CHTER.'CLID' ; 
              'FINSI' ; 
            'FINS'; 
   
          'SI' WTAB.'FOR_THER' ; 
             estim.'TEMPERATURES' = WTAB.'TET2' ; 
             estim.'REACTIONS_THERMIQUES'='REAC' WTAB.'CLIT' WTAB.'TET2'; 
          'FINSI'; 
   
          'SI' WTAB.'FOR_DIFF' ; 
             estim.'CONCENTRATIONS' = WTAB.'CO2' ; 
             estim.'REACTIONS_DIFFUSIONS' ='REAC' WTAB.'CLID' WTAB.'CO2'; 
          'FINSI' ; 
 *** Reevaluation des donnees du calcul dependant de la temperature 
          'SI' WTAB.'PROCEDURE_REEV_THE' ; 
             REEV_THE PRECED  1 ; 
          'FINSI' ; 
   
 *-----convergence mecanique thermique : reprise configuration  ------ 
 *---------- du pas precedent pour refaire la mecanique  ------------- 
          'SI'( WTAB.'GRANDS_DEPLACEMENTS' 'OU' WTAB.'FEFP_FORMULATION'); 
            'FORM' WTAB.'GE0_DEB'; 
          'FINSI' ; 
        'FINSI' ; 
 *################## fin du calcul d'un pas thermique ################# 
   
   
 *####################################################################### 
 *#################### CALCUL D'UN PAS SI MECANIQUE ##################### 
 *####################################################################### 
       'SI' WTAB.'FOR_MECA' ; 
          'SAUT' 1 'LIGN'; 
          'MESSAGE' ' Numero du pas : ' IPAS '  Indice d evolution : ' ICHG ' -> temps :' TI; 
   
 *--------------------- calcul de la temperature --------------------- 
 * CB215821 : On met la thermique dans le Chargement pour 'TIRER' le chargement 
 *            au bon instant dans UNPAS pour la MECANIQUE 
 *            Il faudra faire de meme avec la MECANIQUE si la THERMIQUE en depend 
 *        'SI' WTAB.'FOR_THER'; 
 *           THTA1='TABLE'; 
 *           THTA2='TABLE'; 
 *           THTA1.0=TEMP0; 
 *           THTA1.1=TI; 
 *           THTA2.0= conti.'TEMPERATURES' 'ENLE' 'LX' ; 
 *           THTA2.1= estim.'TEMPERATURES' 'ENLE' 'LX' ; 
 *           CHTH='CHAR' 'T' THTA1 THTA2; 
 *           CHASANST= WTAB.'CHARGEMENT' 'ENLE' 'T'; 
 *           WTAB.'CHARGEMENT'= CHASANST 'ET' CHTH; 
 *        'FINSI'; 
         'SI' WTAB.'CHAR_THE'; 
             WTAB.'TET2' ='TIRE' WTAB.'CHARGEMENT' 'T   ' TI; 
         'FINSI'; 
   
 *------- Caracteristiques initiales en cas de grands deplacements ----- 
         'SI' WTAB.'ITCAR'; 
           'SI'  ('EGA' WTAB.'CARA'  'INCONNU'); 
              WTAB.'CARA' = WTAB.'MAT0'; 
           'FINSI'; 
         'FINSI'; 
   
 ************************************************************************ 
 ****************    APPEL A UNPAS       ******************************** 
 ************************************************************************ 
         'MENA' ; 
          TT = UNPAS  PRECED; 
   
 *---------- Mise a jour du MODELE du PAS precedent --------------- 
          WTAB.'MO_TOT_PREC' = TT.'MO_TOT_PREC' ; 
   
 *---------- retour a la configuration initiale ------------------- 
         'SI' (WTAB.'GRANDS_DEPLACEMENTS' 'OU' WTAB.'FEFP_FORMULATION'); 
           'FORM'  WTAB.'FOR0'; 
         'FINSI'; 
   
 *------- test si on a converge 
          WTAB.'CONV' = TT.'CONV'; 
         'SI' ('NON' TT.'CONV' 'ET' ('NON' WTAB.'CONVERGENCE_FORCEE')); 
 *          en dynamique et en poreux on garde le PRECED.FREA1 du dernier pas 
 *          converge (dans le cas ou on voudrait continuer le calcul) 
 *          'SI' WTAB.'DYNAMIQUE' ; WTAB.'FREA1' = F1 ; 'FINSI'; 
 *          'SI' WTAB.'CONSOLIDATION' ;WTAB.'FREA1' = FF1 ; 'FINSI'; 
             'ERREUR' 997 ; 
         'FINSI'; 
   
 *       Remplissage de la table ESTIMATION : champs en fin de pas 
          DEP0= conti.'DEPLACEMENTS'; 
 *         DEP = ENLEVER DEP0 'LX'; 
          estim.'DEPLACEMENTS'= TT.'ZU1' ; 
 *        'DETRUIRE' DEP; 
          estim.'DEFORMATIONS'= TT.'DEFF'; 
          estim.'CONTRAINTES' = TT.'SIGF'  ; 
          estim.'DFGRAD'      = TT.'DFGRAD'; 
         'SI' WTAB.'IPLAVI' ; 
            estim.'VARIABLES_INTERNES'        = TT.'VARF'; 
            estim.'DEFORMATIONS_INELASTIQUES' = TT.'DFPF'; 
         'FINSI' ; 
         'SI' WTAB.'GRANDS_DEPLACEMENTS' ; 
            estim.'FOR' = TT.'FOR' ; 
         'FINSI' ; 
         'SI'  WTAB . 'DYNAMIQUE' ; 
            estim.'VITESSES'      = TT.'VITI' ; 
            estim.'ACCELERATIONS' = TT.'ACCEI' ; 
         'FINSI'; 
 *       'SI'  WTAB .'ITCAR'; 
 *          estim.'CARA_ACTU' = TT.'CARA' ; 
 *       'FINSI'; 
 ***      Reevaluation des donnees du calcul dependant de la mecanique 
         'SI' WTAB.'PROCEDURE_REEV_MEC' ; 
            REEV_MEC PRECED 1; 
         'FINSI' ; 
       'FINSI'; 
 *####################################################################### 
 *################### FIN DU CALCUL D'UN PAS MECANIQUE ################## 
 *####################################################################### 
   
   
   
 *** 
 *** Test de la convergence mecanique thermique 
 *** 
     'SI' WTAB.'CONVERGENCE_MEC_THE' ; 
 *      je cherche la convergence thermo-mecanique : je dois au moins 
 *      calculer deux fois mon probleme 
       'SI' (I_BOTH > 1) ; 
 *       Test sur toutes les composantes (notamment, si DIFFUSION) 
         CHT1     = WTAB . 'THER_COURANT' ; 
         DUABS2   = 'ABS' (WTAB.'THER_COURANTP' - CHT1) ; 
         CRICOH1  = 0. ; 
         NBINCO1  = 'DIME' WTAB . 'PRIM_TOT' ; 
         'REPE' BINCO1 NBINCO1 ; 
           LINCOI1  = 'MOTS' ('EXTR' WTAB.'PRIM_TOT' &BINCO1) ; 
           MDUABSI1 = 'MAXI' DUABS2 'AVEC' LINCOI1 ; 
           NORMI1   = 'MAXI' 'ABS' CHT1 'AVEC' LINCOI1 ; 
           'SI' (NORMI1 '<EG' (1.E-14 * MDUABSI1)) ; 
             NORMI1   = 1. ; 
           'FINS' ; 
           CRICOHI1 = MDUABSI1 / NORMI1 ; 
           'SI' (CRICOHI1 '>' CRICOH1) ; 
             CRICOH1  = CRICOHI1 ; 
          'FINS' ; 
         'FIN' BINCO1 ; 
   
         WTAB.'CONV_THMEC' = CRICOH1 '<' (WTAB . 'CRITERE_COHERENCE') ; 
 *       Fin de boucle Si ne converge Pas 
         'SI'('NON' WTAB.'CONV_THMEC') ; 
           'SI' (I_BOTH >EG WTAB.'BOU_METH'); 
             'MESS' 'PAS DE COHERENCE TROUVEE MECANIQUE THERMIQUE' ; 
             'ERREUR' 999; 
           'FINSI' ; 
         'FINSI' ; 
       'SINON' ; 
 *       je suis sur la premiere boucle de convergence thermomecanique 
         WTAB.'CONV_THMEC' = FAUX ; 
       'FINSI' ; 
 *     THER_COURANTPrecedent dans WTAB pour test CONVERGENCE_MEC_THE 
        WTAB . 'THER_COURANTP' = WTAB . 'THER_COURANT' ; 
     'SINON' ; 
 *     ici je ne cherche pas la convergence thermomecanique 
       WTAB.'CONV_THMEC' = VRAI ; 
     'FINSI' ; 
   
     'SI' (WTAB.'CONV_THMEC') ; 
        'QUITTER' BO_BOTH ; 
     'FINSI' ; 
   
     'SI' ('NEG' ('TYPE'  WTAB.'GE0_DEB') 'MOT') ; 
       FORME WTAB.'GE0_DEB'; 
     'FINSI' ; 
   
   'FIN' BO_BOTH ; 
   
 *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
 *++++++++++++++++ fin de boucle interne de convergence mec_ther ++++++++ 
 *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
   
 *----- Preparation du pas suivant : Thermique et Diffusion 
       'SI' WTAB.'FOR_THER'; 
          WTAB.'TET2' = estim.'TEMPERATURES' ; 
          WTAB.'TET1'=WTAB.'TET2'; 
         'SI' ('EGA' WTAB.'PROCEDURE_THERMIQUE' 'DUPONT'); 
            WTAB.'TET0'              = WTAB.'TET1'              ; 
            WTAB.'VIEUXPAS'          = WTAB.'NOUV_PAS'          ; 
            WTAB.'RELAXATION_DUPONT' = CHTER.'RELAXATION_DUPONT'; 
           'SI' ('EXIS' CHTER  'INITIAL(1)') ; 
              WTAB.'TET1' = CHTER.'INITIAL(1)'; 
           'FINSI' ; 
         'FINSI'; 
       'FINSI' ; 
   
       'SI' WTAB.'FOR_DIFF'; 
         WTAB.'CO1' = WTAB.'CO2'             ; 
         WTAB.'CO2' = estim.'CONCENTRATIONS' ; 
       'FINSI' ; 
   
 *----- Preparation du pas suivant : Mecanique 
       'SI' WTAB.'FOR_MECA' ; 
          'SI' ('EXISTE' TT 'SECOND_MEMBRE'); 
            WTAB . 'SECOND_MEMBRE' = TT . 'SECOND_MEMBRE' ; 
          'FINSI' ; 
          'SI' ('EXISTE' TT 'SUCCES'); 
            WTAB . 'SUCCES' = TT . 'SUCCES' ; 
          'FINSI' ; 
          'SI' ('EXISTE' TT 'AUTOCOEF'); 
            WTAB . 'AUTOCOEF' = TT . 'AUTOCOEF' ; 
          'FINSI' ; 
          'SI' ('EXISTE' TT 'AUTOREDU'); 
            WTAB . 'AUTOREDU' = TT . 'AUTOREDU' ; 
          'FINSI' ; 
          'SI' ('EXISTE' TT 'AUTORED1'); 
            WTAB . 'AUTORED1' = TT . 'AUTORED1' ; 
          'FINSI' ; 
          'SI' ('EXISTE' TT 'RIBLO_M'); 
            WTAB . 'RIBLO_M' = TT . 'RIBLO_M' ; 
            WTAB . 'LISEA_M' = TT . 'LISEA_M' ; 
          'FINSI' ; 
          'SI' ('EXISTE' TT 'INCREMENT'); 
            WTAB . 'INCREMENT' = TT . 'INCREMENT' ; 
          'FINSI' ; 
          'SI' ('EXISTE' TT 'INITEMPS'); 
            WTAB . 'INITEMPS' = TT . 'INITEMPS' ; 
          'FINSI' ; 
          'SI' ('EXISTE' TT 'DT'); 
            WTAB . 'DT' = TT . 'DT' ; 
          'FINSI' ; 
          'SI' ('EXISTE' TT 'NBPLAS'); 
            WTAB . 'NBPLAS' = TT . 'NBPLAS' ; 
          'FINSI' ; 
          'SI' ('EXISTE' TT 'NOMBRE_ITERATIONS'); 
            WTAB . 'NOMBRE_ITERATIONS' = TT . 'NOMBRE_ITERATIONS' ; 
          'FINSI' ; 
          'SI' ('EXISTE' TT 'FFROT'); 
            WTAB . 'FFROT' = TT . 'FFROT' ; 
          'FINSI' ; 
          'SI' ('EXISTE' TT 'RESIDU'); 
            WTAB . 'RESIDU' = TT . 'RESIDU' ; 
          'FINSI' ; 
          'SI' ('EXISTE' TT 'FNONL'); 
            WTAB . 'FNONL' = TT . 'FNONL' ; 
          'FINSI' ; 
          'SI' ('EXISTE' TT 'DTPREC'); 
            WTAB . 'DTPREC' = TT . 'DTPREC' ; 
          'FINSI' ; 
 *  SP : Modification de WTAB.'TET2' suite a appel a UNPAS 
 *  CB : SI (IPILOT) ==> TET2 est TIRE entre TEMPS0 et TI 
          'SI' ('EXISTE' TT 'TET2'); 
            WTAB . 'TET2' = TT . 'TET2' ; 
          'FINSI' ; 
          'SI' ('EXISTE' TT 'XDENO'); 
            WTAB . 'XDENO'  = TT . 'XDENO'  ; 
          'FINSI' ; 
          'SI' ('EXISTE' TT 'XDENOM'); 
            WTAB . 'XDENOM' = TT . 'XDENOM' ; 
          'FINSI' ; 
          'SI' ('EXISTE' TT 'LASTKTAN'); 
            WTAB . 'LASTKTAN' = TT . 'LASTKTAN' ; 
          'FINSI' ; 
          'SI' ('EXISTE' TT 'DFGRAD'); 
            WTAB . 'DFGRAD'=  TT .'DFGRAD'; 
          'FINSI' ; 
          'SI' ('EXIS' TT 'ETHER2'); 
             WTAB.'ETHER1'= TT.'ETHER2'; 
             WTAB.'ETHER2'= TT.'ETHER2'; 
          'FINSI'; 
          'SI' ('EXIS' TT 'MSRTHER2'); 
             WTAB.'MSRTHER1'= TT.'MSRTHER2'; 
             WTAB.'MSRTHER2'= TT.'MSRTHER2'; 
          'FINSI'; 
          'SI' ('EXIS' TT 'DEFOR2'); 
             WTAB.'DEFOR1'= TT.'DEFOR2'; 
             WTAB.'DEFOR2'= TT.'DEFOR2'; 
          'FINSI'; 
          'SI'('EXIS' TT 'ETAT2'); 
             WTAB.'ETAT1'= TT.'ETAT2'; 
          'FINSI'; 
   
 * fin des reactualisations. 
 *--------------------------- deplacement ------------------------------ 
          TT.'DEPTOT' = estim.'DEPLACEMENTS' ; 
 *-------------------- forces de reaction ------------------------------ 
          TT.'REAC'= 'REAC' TT.'DEPTOT' WTAB.'CLIM'; 
          estim.'REACTIONS' = TT.'REAC' ; 
 *------------------ deformation d'origine thermique ------------------ 
          'SI' WTAB.'CHAR_THE'; 
             WTAB.'ETHER2' = TT.'ETHER2' ; 
             'SI' WTAB.'POR1' ; 
                 WTAB.'MSRTHER2' = TT.'MSRTHER2'; 
             'FINSI'; 
          'FINSI'; 
 *------- en dynamique : vitesse, forces de reactions, operateur ------- 
   
          'SI' WTAB . 'DYNAMIQUE' ; 
             'SI' WTAB . 'LIAISON_PERSISTANTE' ; 
 * corection des vitesses pour avoir des vitesses relatives nulles 
 * aux points qui sont en contact 
                 TT.'VITI' =  TT.'VITI' +  TT.'VAUX' ; 
             'SINON' ; 
 * forces d'acceleration et d'amortissement a la fin du pas    * 
              WTAB.'FREA1'  = TT.'FOPL' - TT.'REAC'; 
 *     en cas d'appuis unilateraux avec choc elastique essai de corriger 
 *     les vitesses fournies par le schema 
   
             TT.'VITI'= VITEUNIL TT.'ZRAIDV' WTAB.'MASSE' TT.'VITI' 
          tt.'DEPT'   DEP0 WTAB.'DT'  WTAB.'SECOND_MEMBRE' WTAB; 
            'SI' ( 'EXIS' WTAB 'RATE_VITEUNIL'); 
            'ERREUR' 'Probleme dans viteunil' ; 'FINSI'; 
             'FINSI' ; 
             'SI' ( 'NEG' WTAB.'REAPREC' 'INCONNU'); 
              'SI' ('EGA' ('TYPE' (EXTR TT.'REAC' 'MAIL')) 'MAILLAGE'); 
                reacdif='REDU' WTAB.'REAPREC' (EXTR TT.'REAC' 'MAIL'); 
                TT.'REAC'=  TT.'REAC' - REACDIF; 
              'FINSI' ; 
               WTAB.'REAPREC'=TT.'REAC'; 
             'SINON'; 
                WTAB . 'REAPREC'= TT.'REAC'; 
             'FINSI'; 
             estim.'VITESSES'  = TT.'VITI' ; 
             estim.'REACTIONS' = TT.'REAC' ; 
          'FINSI'; 
   
 *---------- en consolidation : operateur ------------------------------ 
          'SI' WTAB . 'CONSOLIDATION' ; 
              WTAB.'OPERATEUR'  = ROP; 
          'FINSI'; 
   
 *-------------------------- configuration ----------------------------- 
   
          'SI'   WTAB.'GRANDS_DEPLACEMENTS' ; 
             WTAB.'RECALCUL'= VRAI     ; 
             WTAB.'GE0_DEB' = TT.'FOR' ; 
            'SI' WTAB.'ITCAR' ; 
               WTAB.'CARA' = TT.'CARA' ; 
            'FINSI' ; 
          'FINSI'; 
          'FORM' WTAB.'FOR0'; 
   
 *********************************************************************** 
          'SI' ('ET' (WTAB.'FEFP_FORMULATION') 
                 (WTAB.'UPDATE_LAGRANGIAN')) ; 
 * tc            'SI' ( 'NEG' WTAB.'FOR'  'INCONNU'); DETR GEOM1; 'FINSI'; 
             WTAB.'GE0_DEB' = TT.'FOR' ; WTAB.'RECALCUL'=VRAI; 
          'FINSI'; 
 ************************************************************************ 
   
 *--------------------- destruction de l operateur ---------------------- 
   
          'SI' (WTAB . 'RECADET') ; 
 *           'DETR' RH 'ELEM'; 
             'OUBLIER'   ROP; 
          'FINSI'; 
   
 *----------------------------- temps initial -------------------------- 
               DT2 =( TI - TEMP0)/10000.; 
          'SI' (WTAB . 'AUTOMATIQUE' 'OU' ('NON' WTAB.CONV)); 
             TEMP0 = ( TI - TEMP0) *  WTAB.'AUTOCOEF' + TEMP0; 
            'MESS' ' Temps effectivement calcule et non converge : ' TEMP0; 
             WTAB.'TEMPS0' = TEMP0; 
          'SINON'; 
               TEMP0=TI; 
               WTAB.'TEMPS0' = TEMP0; 
          'FINSI'; 
   
 *----------------- Appel a une procedure personnelle ------------------- 
   
          'SI' (WTAB.'PROCEDURE_PERSO1'); 
             PRECED.'PERSO1_APPEL' = 2 ; 
             PERSO1 PRECED; 
             'SI' ('EXIS' PRECED 'ARRET') ; 
               WTAB . 'ARRET' = PRECED . 'ARRET' ; 
             'FINSI' ; 
             TEMP0 =  WTAB.'TEMPS0' ; 
          'FINSI'; 
 *----------------- On redefinit WTAB.'CHARGEMENT_I' ------------------ 
          'SI'   WTAB.'CONVERGENCE_MEC_THE' ; 
             WTAB.'CHARGEMENT_I' = WTAB.'CHARGEMENT' ; 
          'FINSI'; 
       'FINSI'; 
   
 *++++++++++++++++++ fin preparation pas suivant mecanique +++++ 
 *##################  Sauvegarde ############################### 
       'SI' ('NON' WTAB.'FOR_MECA') ; 
          DT2 =( TI - TEMP0)/10000.; 
          TEMP0=TI; 
          WTAB.'TEMPS0' = TEMP0; 
          TT = 'TABLE' ; 
       'FINSI'; 
 * pour ne pas sauvegarder la matrice de raideur si on doit la recalculer 
 'SI' ('EXIS' WTAB 'RRRR')        ; 
   'SI'  WTAB.'RECARI'            ; 
      WTAB ='ENLE' WTAB 'RRRR'    ; 
      PRECED.'WTABLE'= WTAB       ; 
     'SI' ('EXIS' estim 'FOR')    ; 
        estim ='ENLE' estim 'FOR' ; 
        PRECED.'ESTIMATION'=estim ; 
     'FINSI'; 
   'FINSI'; 
 'FINSI'; 
   
 *-- remplissage de la table de continuation et des tables de resultats 
 *-- s'il faut garder les resultats, sauvegarde incrementale et 
 *-- fantomisation si economique 
     ISAUV = PAS_RESU TEMP0 iauto PRECED ; 
   
 ******************************************* 
 *****   cas du pilotage automatique ******* 
 ******************************************* 
   
 'SI' WTAB . 'AUTOMATIQUE'; IAUTO=IAUTO+1; 
   'SI' ((WTAB . 'AUTOCOEF'   'EGA'  0.9999999D0) 'OU' 
         (TEMP0 '>EG' TI)) ; 
         TEMP0=TI; 
       'MESS' ' Objectif atteint '; 
       'MESS' ' '; 
       WTAB.'AUTODEUX' = FAUX ; 
       WTAB.AUTORED1 = 0 ; 
       WTAB.AUTOREDU = 1. ; 
       IAUTO=1; 
   'SINON'; 
       'MESS' ' Objectif non atteint: On recommence'; 
       'MESS' '  '; 
       'SI' ( IAUTO >EG WTAB.'AUTOPAS'); 
        'ERREUR' 1000; 
 *       'MESS' 'Pilotage non converge  apres ' IAUTO ' pas.'; 
       'FINSI'; 
       WTAB.'AUTODEUX'=VRAI;ICHG=ICHG - 1; 
   'FINSI'; 
 'FINSI'; 
 * 
 'SI'(WTAB.'CHAR_THE' 'OU' WTAB.'FOR_THER'); 
        WTAB.'TET1'=WTAB.'TET2'; 
       'SI' WTAB.'FOR_MECA'; 
          WTAB.'ETHER1' =WTAB.'ETHER2'; 
       'FINSI'; 
       'SI' WTAB.'POR1'; 
          WTAB.'MSRTHER1'=WTAB.'MSRTHER2'; 
       'FINSI'; 
 'FINSI' ; 
 'SI' WTAB.'CHAR_DEFI' ; WTAB.'DEFOR1'=WTAB.'DEFOR2';'FINSI'; 
 'SI' WTAB.'FOR_DIFF'  ; WTAB.'CO1'   =WTAB.'CO2'   ;'FINSI' ; 
 ************************************************************************ 
 ******  cas de la convergence forcee 
 ************************************************************************ 
 'SI' WTAB.'PAS_AJUSTE'; 
  'SI' ((TI < TIV) 'OU' ('NON' WTAB.'CONV')); ICHG=ICHG-1;'FINSI'; 
 'FINSI'; 
 'SI'  WTAB.'ARRET'; 
    'QUITTER' BEXTERN; 
 'FINSI'; 
 ************************************************************************ 
 *************** FIN DE LA BOUCLE SUR LES PAS DE TEMPS ****************** 
 ************************************************************************ 
 'FIN'  BEXTERN; 
 ************************************************************************ 
   
  'SI' ('NEG' WTAB.'AMORTISSEMENT' 'INCONNU'); 
      WTAB.'AMORTISSEMENT' = TOTO ; 
  'FINSI'; 
   
  'SI' ('NEG' ('TYPE'  WTAB.'GE0_DEB') 'MOT') ; 
    'OUBL' WTAB 'GE0_DEB' ; 
  'FINSI' ; 
   
 * on tue WTAB.'MAT1' s'il existe car il peut etre tres gourmand en place 
  WTAB.'MAT1' = 'MOT' 'INCONNU'; 
   
  'MESS' ' '; 
  'MESS' 
 '------------------- FIN DE LA PROCEDURE PASAPAS ---------------------'; 
 'SAUT' 1 'LIGNE'; 
 * 
 ************************************************************************ 
 * 
 'SI' ('EXIS' WTAB 'RRRR') ; 
 * pour forcer le calcul de la rigidite si on  rappele  pasapas 
    WTAB1= 'ENLEVER' WTAB 'RRRR'; 
     PRECED .'WTABLE'= WTAB1; 
 'FINSI'; 
   
 * Typage de la table en sortie de PASAPAS ; 
 PRECED.'SOUSTYPE' = 'MOT' 'PASAPAS' ; 
   
 'FINPROC' PRECED ; 
 * PAS_DEFA  PROCEDUR  FD218221  21/01/18    21:15:01     10853 
 DEBPROC PAS_DEFA PRECED*'TABLE'; 
 * 
 *objet de la procedure : 
 * verifications coherences donnees. 
 * initialisations des valeurs par defaut des options de calcul 
 * initialisation des variables locales 
 * 
 * verifications de quelques arguments obligatoires 
 * 
 * existence modele verification et initialisation modeles particuliers 
 * 
 * affectation des valeurs par defaut des options dans WTAB 
 * 
 INOUV=VRAI; 
 'SI' ('EXIS' PRECED 'REPRISE'); 
   'SI' (PRECED.'REPRISE' > 0.); 
      PAS_REPR PRECED; 
   'FINSI'; 
 'FINSI'; 
 'SI' ('EXIS' PRECED 'WTABLE'); 
   WTAB=PRECED.'WTABLE';WTAB.'NOUVEAU'=FAUX;INOUV=FAUX; 
 'SINON'; 
   WTAB='TABLE'; 
   PRECED.'WTABLE'=WTAB; 
 'FINSI'; 
   
 * Sous-typage automatique de la TABLE PASAPAS 
 'SI' ('NON' ('EXIS' PRECED 'SOUSTYPE')); 
    PRECED.'SOUSTYPE'='MOT' 'PASAPAS' ; 
 'FINS'; 
   
 ************************************************************************ 
 ********************* CAS D UNE NOUVELLE WTAB ************************** 
 ************************************************************************ 
 'SI' INOUV; 
   'SI' (('EXISTE' PRECED 'GRANDES_ROTATIONS'   ) 'OU' 
         ('EXISTE' PRECED 'GRANDES_DEFORMATIONS')); 
      'MESS' ' ATTENTION :' ; 
      'MESS' ' Les donnees concernant les GRANDES ROTATIONS et GRANDES DEFORMATIONS ont ete modifiees :'; 
      'MESS' ' Utilisez l''indice HYPOTHESE_DEFORMATIONS'; 
      'ERREUR' 21 ; 
   'FINSI'; 
   'SI' ( 'EXISTE' PRECED 'CONTACT' ) ; 
      'MESS' ' ATTENTION :' ; 
      'MESS' ' Les donnees concernant le CONTACT dans PASAPAS ont ete modifiees :' ; 
      'MESS' ' - L''indice CONTACT de la table de PASAPAS n''existe plus.'; 
      'MESS' ' - Il faut definir un MODELE de CONTACT.' ; 
      'ERREUR' 21 ; 
   'FINSI'; 
   'SI' (('EXISTE' PRECED 'PROCEDURE_REAC_MECA') 'OU' 
         ('EXISTE' PRECED 'PROCEDURE_CHAR_MECA') 'OU' 
         ('EXISTE' PRECED 'PROCEDURE_REAC_THER') 'OU' 
         ('EXISTE' PRECED 'PROCEDURE_CHAR_THER') 'OU' 
         ('EXISTE' PRECED 'PROCEDURE_PARA_THER')) ; 
      'MESS' ' ATTENTION :' ; 
      'MESS' ' Les donnees concernant les procedures utilisateur ont ete modifiees :' ; 
      'MESS' ' - L''indice PROCEDURE_REAC_MECA est remplace par l''indice PROCEDURE_REEV_MEC' ; 
      'MESS' ' - L''indice PROCEDURE_CHAR_MECA est remplace par l''indice PROCEDURE_CHARMECA' ; 
      'MESS' ' - L''indice PROCEDURE_REAC_THER est remplace par l''indice PROCEDURE_REEV_THE' ; 
      'MESS' ' - L''indice PROCEDURE_CHAR_THER est remplace par l''indice PROCEDURE_CHARTHER' ; 
      'MESS' ' - L''indice PROCEDURE_PARA_THER est remplace par l''indice PROCEDURE_PARATHER' ; 
      'ERREUR' 21 ; 
   'FINSI'; 
   
 * Modifs CB215821 Juillet 2020 
   'SI' ('EXISTE' PRECED 'TEMPERATURE_REFERENCE'); 
      'MESS' ' ATTENTION :' ; 
      'MESS' ' L''indice ''TEMPERATURE_REFERENCE'' de PASAPAS a ete supprime'; 
      'MESS' ' Il faut desormais fournir la composante ''TREF'' dans le materiau'; 
      'ERREUR' 21 ; 
   'FINSI'; 
   'SI' ('EXISTE' PRECED 'TALPHA_REFERENCE'); 
      'MESS' ' ATTENTION :' ; 
      'MESS' ' L''indice ''TALPHA_REFERENCE'' de PASAPAS a ete supprime'; 
      'MESS' ' Il faut desormais fournir la composante ''TALP'' dans le materiau'; 
      'ERREUR' 21 ; 
   'FINSI'; 
   
 * Adherence presence de la composante ADHE (modele contact ou cont/fro) 
   WTAB.'ADHERENCE' = FAUX ; 
 * Advection presence d'un modele thermiquee advection 
   WTAB.'ADVECTION'=FAUX; 
 * matrice d'amortissement en dynamique : pas_defa 
   WTAB.'AMORTISSEMENT'='MOT' 'INCONNU'; 
 * arret:  positionne  pour dire a pasapas de s'arreter: perso1 
   WTAB.'ARRET'=FAUX; 
 * autocrit: valeur du critere a utiliser dans autopilo(option automatique) 
   WTAB.'AUTOCRIT'= 0.005; 
 * autocoef: coefficient de pilotage 
   WTAB.'AUTOCOEF'='MOT' 'INCONNU'; 
 * autodeux=vrai si pilotage et pas premiere tentative : pasapas 
   WTAB.'AUTODEUX'=FAUX; 
 * automatique =vrai si demande de pilotage automatique : pas_defa 
   WTAB.'AUTOMATIQUE'= FAUX; 
 * autopas : nb maxi de tentative en pilotage automatique:pas_defa 
   WTAB.'AUTOPAS'= 250; 
 * autoredu  : reduit le critere de pilotage : pasapas unpas 
   WTAB.'AUTOREDU'=1.D0; 
 * autored1 : joue sur la strategie d'evolution de autoredu :pasapas unpas 
   WTAB.'AUTORED1'='MOT' 'INCONNU'; 
 * beton_ht   ( ne marche pas!) 
   WTAB.'BETON_HT' = FAUX; 
 * blocages_mecaniques; matrices : pas_defa (ou pasapas si pas dans preced) 
   WTAB.'BLOCAGES_MECANIQUES'='MOT' 'INCONNU'; 
 * blocages_thermiques; matrices : pas_defa (ou jamais) 
   WTAB.'BLOCAGES_THERMIQUES'='MOT' 'INCONNU'; 
 * blocages_diffusions; matrices : pas_defa (ou jamais) 
   WTAB.'BLOCAGES_DIFFUSIONS'='MOT' 'INCONNU'; 
 * bou_meth : valeur par defaut du nombre de bouclage mecanique-thermique 
   WTAB.'BOU_METH'=1; 
 * cafrotte logique pas_defa: veut dire il existe modele contact-frottement 
   WTAB.'CAFROTTE' = FAUX ; 
 * capaconst logique il existe une capacite constante : pas_defa 
   WTAB.'CAPACONST'=FAUX; 
 * cara stocke les caracteristiques reactualisees du dernier pas :pasapas 
   WTAB.'CARA'='MOT' 'INCONNU'; 
 * caracteristiques : 
   WTAB.'CARACTERISTIQUES'= 'MOT' 'INCONNU'; 
 * indice celsius 
   WTAB.'CELSIUS'=FAUX; 
 * ceramique presence de modele ceramique pas_defa 
   WTAB.'CERAMIQUE'=FAUX; 
 * chargement idem celui de preced ou creation d'un chargement farfelu 
   WTAB.'CHARGEMENT'='MOT' 'INCONNU'; 
 * chargement_i idem chargement  DFIS et FI si certain materiau pas_defa 
   WTAB.'CHARGEMENT_I'='MOT' 'INCONNU'; 
 * char_BLOD presence d'un chargement de BLOcages Diffusion 
   WTAB.'CHAR_BLOD'=FAUX; 
 * char_blom presence d'un chargement de BLOcages Mecaniques 
   WTAB.'CHAR_BLOM'=FAUX; 
 * char_blot presence d'un chargement de BLOcages Thermiques 
   WTAB.'CHAR_BLOT'=FAUX; 
 * char_defi presence de chargement DEFI deformation initiale  pas_defa 
   WTAB.'CHAR_DEFI'=FAUX; 
 * char_mate presence d'un chargement 'MATE' 
   WTAB.'CHAR_MATE'=FAUX; 
 * char_mode presence d'un chargement 'MODE' 
   WTAB.'CHAR_MODE'=FAUX; 
 * char_pres presence de chargement 'P   ' de pression suiveuse  pas_defa 
   WTAB.'CHAR_PRES'=FAUX; 
 * char_the presence de chargement thermique pour la mecanique pas_defa 
   WTAB.'CHAR_THE' = FAUX; 
 * char_pilo presence de chargement de pilotage indirect 
   WTAB.'CHAR_PILO' = FAUX; 
   WTAB.'DEPLACEMENTS_PILOTES' = FAUX ; 
   WTAB.'FORCES_PILOTEES' = FAUX ; 
   WTAB.'ZONE_DE_PILOTAGE' = FAUX ; 
   WTAB.'PARAMETRE_DE_PILOTAGE'= 'MOT' 'INCONNU' ; 
 * clim matrice des blocagesmecaniques y compris contact et frottement pasapas 
   WTAB.'CLIM'='MOT' 'INCONNU'; 
 * condconst logique il existe une conductivite constante : pas_defa 
   WTAB.'CONDCONST'=FAUX; 
 * conduction presence d'un modele de' conduction : pas_defa 
   WTAB.'CONDUCTION'=FAUX; 
 * consolidation presence de consolidation via preced : pas_defa 
   WTAB.'CONSOLIDATION'=FAUX; 
 * contact presence de contact automatique via preced : pas_defa 
   WTAB.'CONTACT' = FAUX ; 
 * conv logique precisant si unpas a bien converge  : unpas 
   WTAB.'CONV'=VRAI; 
 * convergence_forcee logique demandant la convergence forcee : pas_defa 
   WTAB.'CONVERGENCE_FORCEE' = VRAI; 
 * demande de convergence mecanique-thermique en cas de bouclage : pas_defa 
   WTAB.'CONVERGENCE_MEC_THE'=FAUX; 
 * logique pour imposer au residu de decroitre de facon monotone : pas_defa 
   WTAB.'CONVERGENCE_MONOTONE' = FAUX; 
 * convection presence d'un modele de convection : pas_defa 
   WTAB.'CONVECTION' = FAUX; 
 * conv_thmec on a convergee le bouclage mecanique-thermique  pasapas 
   WTAB.'CONV_THMEC'=VRAI; 
 * couplage le calcul contient des modeles thermiques et des mecaniques pas_defa 
   WTAB.'COUPLAGE' = FAUX; 
 * co1 champ de CONCENTRATION du pas precedent : pasapas 
   WTAB.'CO1'=0; 
 * co2 champ de CONCENTRATION du pas courant : pasapas 
   WTAB.'CO2'=0; 
 * cte_stefan_boltzmann valeur de la constante : pas_defa 
   WTAB.'CTE_STEFAN_BOLTZMANN' = 5.673E-8 ; 
 * deja_calc_charther indique le dernier temps pour lequel on a calcule le 
 * chargement thermique dans charther : pas_defa et charther 
   WTAB.'DEJA_CALC_CHARTHER'=0.d0; 
 * deltaiter sert au test de non convergence : pas_defa unpas 
   WTAB.'DELTAITER'=10; 
 * gradient du deplacement : pas_defa unpas 
   WTAB.'DFGRAD' = 'MOT' 'INCONNU' ; 
 * dt: valeur du delta de temps entre le dernier pas et le pas en cours:pasapas 
   WTAB.'DT'='MOT' 'INCONNU'; 
 * dtprec : dt du pas precedent: pasapas 
   WTAB.'DTPREC'='MOT' 'INCONNU'; 
 * dt_init c'est le dt initiale sert au pilotage automatique : pasapas 
   WTAB.'DT_INIT'=0.D0; 
 * dynamique calcul en dynamique :pas_defa 
   WTAB.'DYNAMIQUE'=FAUX; 
 * endommagement il esiste un tel modele de comportement: pas_defa 
   WTAB.'ENDOMMAGEMENT'=FAUX; 
 * Enregistrement de la date du depart de PASAPAS 
   WTAB.'EPOQUE' = DATE 'EPOCH'; 
 * ether1 stocke des deformations thermiques au temps precedent : pasapas 
   WTAB.'ETHER1'='MOT' 'INCONNU'; 
 * etref deformation d'origine thermique de reference : pas_epth 
   WTAB.'ETREF'='MOT' 'INCONNU'; 
 * fnonl permet forces de reequilibrage du pas precedent : unpas 
   WTAB.'FNONL'='MOT' 'INCONNU'; 
 * configuration finale  : pasapas unpas 
   WTAB.'FOR'='MOT' 'INCONNU'; 
 * configuration en debut de pas : pasapas 
   WTAB.'FOR0'='FORM'; 
 * FOR_DIFF le calcul inclus des modeles DIFFUSION:  pas_defa 
   WTAB.'FOR_DIFF' = FAUX; 
 * FOR_METALLU le calcul inclus des modeles METALLURGIE:  pas_defa 
   WTAB.'FOR_METALLU' = FAUX; 
 * utilisation de la frormulation fefp : pas_defa 
   WTAB.'FEFP_FORMULATION' = FAUX; 
 * ffrot  seuil de force de frottement  : unpas 
   WTAB.'FFROT'='MOT' 'INCONNU'; 
 * frea1 partie constante du second membre  dynamique,consolidation: pasapas 
   WTAB.'FREA1'='MOT' 'INCONNU'; 
 * frequentiel calcul en frequentiel : pas_defa 
   WTAB.'FREQUENTIEL'= FAUX; 
 * ftol desequilibre  tolere : pas_defa 
   WTAB.'FTOL'='MOT' 'INCONNU'; 
 * grands_deplacement  logique : pas_defa 
   WTAB.'GRANDS_DEPLACEMENTS' = FAUX; 
 * hypothese de calcul pour les deformations 
   WTAB.'HYPOTHESE_DEFORMATIONS'='MOT' 'LINEAIRE'; 
 * increment de charge du pas precedent : unpas 
   WTAB.'INCREMENT'='MOT' 'INCONNU'; 
 * logique le pas precedent a ete initialise par le temps : unpas 
   WTAB.'INITEMPS'= FAUX; 
 * logique pour autoriser l'Initialisation a partir du pas precedent : unpas 
   WTAB.'INITIALISATION'= VRAI; 
 * iplavi il existe un modele devant passer par COMP : pas_defa 
   WTAB.'IPLAVI'=FAUX; 
 * ipresu : listreel des temps a mettre dans les tables resultats : pas_defa 
   WTAB.'IPRESU'='MOT' 'INCONNU'; 
 * iptime  liste des temps a calculer : pas_defa 
   WTAB.'IPTIME'='MOT' 'INCONNU'; 
 * isauvega liste des temps sauvegardes (appel SAUV dans pasapas) : pas_defa 
   WTAB.'ISAUVEGA'='MOT' 'INCONNU'; 
 * logique la sauvegarde dans pasapas est activee : pas_defa 
   WTAB.'ISAUVEGL'=FAUX; 
 * itcar  des elements ont des caracteristiques geometriques :pas_defa 
   WTAB.'ITCAR'=FAUX; 
 * k_sigma il faut utiliser l'operateur KSIGMA : pas_defa 
   WTAB.'K_SIGMA'=FAUX; 
 * k_tangent il faut utiliser l'operateur KTANG : pas_defa 
   WTAB.'K_TANGENT'=FAUX; 
 * k_tangent_iter0 matrice tangente a utiliser pour iteration 0 : unpas 
   WTAB.'K_TANGENT_ITER0'='MOT' 'INCONNU'; 
 * k_tangent_pert operateur KTAN matrice tangente par perturbation : pas_defa unp 
   WTAB.'K_TANGENT_PERT'=FAUX; 
 * k_tangent_syme matrice tangente symetrisee : pas_defa unpas 
   WTAB.'K_TANGENT_SYME'=FAUX; 
 * k_tang_pert_c1 matrice tangente par perturbation coefficient C1 : unpas 
   WTAB.'K_TANG_PERT_C1'= 1.D-3; 
 * k_tang_pert_c2 matrice tangente par perturbation coefficient C2 : unpas 
   WTAB.'K_TANG_PERT_C2'='MOT' 'INCONNU'; 
 * lastktan matrice donnant la derniere matrice tangente : pasapas unpas 
   WTAB.'LASTKTAN'='MOT' 'INCONNU'; 
 * langrangien schema numerique lagrangien reactualise par defaut 
   WTAB.'LAG_TOT'=3 ; 
 * ldeva liste des variables dont dependent les materiaux : pas_defa 
   WTAB.'LDEVA'='MOT' 'INCONNU'; 
 * leconomi l'option economique est activee : pas_defa pas_sauv 
   WTAB.'LECONOMI'=FAUX; 
 * liaison_persistante si il existe des liaisons persistantes :pas_defa 
   WTAB.'LIAISON_PERSISTANTE' =FAUX; 
 * linesearch en grand deplacement 
   WTAB.'LINESEARCH' = FAUX; 
 * lisea_m  pour les contacts unilateraux en mecaniques :pasapas unpas 
   WTAB.'LISEA_M'='MOT' 'INCONNU'; 
 * lisea_t pour les changements de phase en thermique : pasapas transnon 
   WTAB.'LISEA_T'='MOT' 'INCONNU'; 
 * lpar0 liste des parametres externes a passer a COMP : pas_defa 
   WTAB.'LPAR0'='MOT' 'INCONNU'; 
 * man methode asymptotique numerique 
   WTAB.'MAN'= FAUX; 
 * massconst logique il existe des masses constantes : pas_defa 
   WTAB.'MASSCONST'=FAUX; 
 * etat0 etat au temps 0 : pasapas pas_etat 
   WTAB.'ETAT0'='MOT' 'INCONNU'; 
 * etat1 etat au temps courant : pasapas pas_etat 
   WTAB.'ETAT1'='MOT' 'INCONNU'; 
 * etat_ref etat de reference : pasapas pas_etat 
   WTAB.'ETAT_REF'='MOT' 'INCONNU'; 
 * mat0 materiau au temps 0 : pasapas pas_epth 
   WTAB.'MAT0'='MOT' 'INCONNU'; 
 * mat1  materiaux pour le pas en cours : pasapas unpas 
   WTAB.'MAT1'='MOT' 'INCONNU'; 
 * mat1  materiaux de reference 
   WTAB.'MAT_REF'='MOT' 'INCONNU'; 
 * matvar le materiau est variable  :  pas_verm 
   WTAB.'MATVAR' = FAUX; 
 * mat_con materiau des modeles de convection : pas_defa 
   WTAB.'MAT_CON'='MOT' 'INCONNU'; 
 * mat_dif materiau des modeles de diffusion : pas_defa 
   WTAB.'MAT_DIF'='MOT' 'INCONNU'; 
 * mat_mec materiau des modeles de mecanique : pas_defa 
   WTAB.'MAT_MEC'='MOT' 'INCONNU'; 
 * mat_pha materiau des modeles de changement de phase : pas_defa 
   WTAB.'MAT_PHA'='MOT' 'INCONNU'; 
 * mat_por materiau des modeles poreux : pas_defa 
   WTAB.'MAT_POR'='MOT' 'INCONNU'; 
 * mat_ray materiau des modeles de rayonnement : pas_defa 
   WTAB.'MAT_RAY'='MOT' 'INCONNU'; 
 * mat_the materiau des modeles thermiques : pas_defa 
   WTAB.'MAT_THE'='MOT' 'INCONNU'; 
 * mat_thm materiau thermohydrique : pas_defa 
   WTAB.'MAT_THM'= 'MOT' 'INCONNU'; 
 * mat_T materiau thermique + thermohydrique : pas_defa 
   WTAB.'MAT_T'  = 'MOT' 'INCONNU'; 
 * materiau des modeles convection + thermiques : pas_defa 
   WTAB.'MAT_TOT'='MOT' 'INCONNU'; 
 * maxdefor valeur limitant la deformation en cas de non convergence 
 * ou de RENORMALISATION souhaitee de ZDEP1 : pas_defa 
   WTAB.'MAXDEFOR'= 1.e-3; 
 * maxiteration nombre maximum d'iteration pour un pas de calcul :pas_defa 
   WTAB.'MAXITERATION' = 49; 
 * maxsouspas nombre maximum de sous pas en cas de non convergence :pas_defa 
   WTAB.'MAXSOUSPAS' = 100; 
 * maxisouspas nombre maximum de sous pas d'integration du fluage 
   WTAB.'MAXISOUSPAS'= 2000; 
 * ma_tot materiau des modeles mecaniques + poreux +liaison : pas_defa 
   WTAB.'MA_TOT'='MOT' 'INCONNU'; 
 * mec1 il existe au moins un modele mecanique  : pas_defa 
   WTAB.'MEC1' = FAUX; 
 * affichage messages options calcul entete procedure resolution THERMIQUE 
   WTAB.'MESSTHER' = VRAI ; 
 * modal ou statique : pas_defa 
   WTAB.'MODAL' = FAUX; 
 * mod_adv modele de thermique, advection 
   WTAB.'MOD_ADV'='MOT' 'INCONNU'; 
 * mod_con modele de thermique convection  : pas_defa 
   WTAB.'MOD_CON'='MOT' 'INCONNU'; 
 * mod_dif modele de diffusion  : pas_defa 
   WTAB.'MOD_DIF'='MOT' 'INCONNU'; 
 * mod_mec modele mecanique: pas_defa 
   WTAB.'MOD_MEC'= 'MOT' 'INCONNU'; 
 * mod_pha modele de changement de phase : pas_defa 
   WTAB.'MOD_PHA'='MOT' 'INCONNU'; 
 * mod_por modele poreux 
   WTAB.'MOD_POR'='MOT' 'INCONNU'; 
 * mod_ray modele rayonnement 
   WTAB.'MOD_RAY'='MOT' 'INCONNU'; 
 * mod_soq : modele source de chaleur 
   WTAB.'MOD_SOQ'= 'MOT' 'INCONNU'; 
 * mod_the modele thermique : pas_defa 
   WTAB.'MOD_THE'= 'MOT' 'INCONNU'; 
 * mod_thm modele thermohydrique : pas_defa 
   WTAB.'MOD_THM'= 'MOT' 'INCONNU'; 
 * mod_T modele thermique + thermohydrique (contient inconnue T): pas_defa 
   WTAB.'MOD_T'  = 'MOT' 'INCONNU'; 
 * mod_tot modele thermique : pas_defa 
   WTAB.'MOD_TOT'= 'MOT' 'INCONNU'; 
 * mo_tot modele mecanique + modele poreux : pas_defa 
   WTAB.'MO_TOT' ='MOT' 'INCONNU'; 
 * mo_tot_prec modele mecanique + modele poreux au pas precedent: pas_defa 
   WTAB.'MO_TOT_PREC' ='MOT' 'INCONNU'; 
 * MODELE ce qui est dans preced.modele  : pas_defa 
   WTAB.'MODELE'=PRECED.'MODELE'; 
 * mova nom de la variables internes dont le max est imprime : pas_defa 
   WTAB.'MOVA' = 'MOT' 'EPSE'; 
 * msrther1 deformations thermiques pour les poreux 
   WTAB.'MSRTHER1'='MOT' 'INCONNU'; 
 * msrther2 deformations thermiques pour les poreux 
   WTAB.'MSRTHER2'='MOT' 'INCONNU'; 
 * mtol valeur autorisee du desequilibre (en terme de moment): pas_defa 
   WTAB.'MTOL'='MOT' 'INCONNU'; 
 * naures valeur de preced .autoresu   : pas_defa 
   WTAB.'NAURES'=100000; 
 * nbplas nb de point ayant plastifie   : pasapas unpas 
   WTAB.'NBPLAS'='MOT' 'INCONNU'; 
 * nb_el_para nb minimum d'elements dans une zone pour accepter le parallelisme 
   WTAB.'NB_EL_PARA'=1000; 
 * premier pas de sauvegarde encore present (option economique de pasapas) 
   WTAB.'NFSOR'=0; 
 * nombre maxi d'iteration internes si k_tangent : pas_defa 
   WTAB.'NITERINTER_MAX' = 15; 
 * niter_ktangent recalcule de la matrice tangente toutes les .. iterations 
   WTAB.'NITER_KTANGENT' = 1; 
 * nloc s'il existe un modele de comportement non_local (preced.non_local) 
   WTAB.'NLOC' = FAUX ; 
 * nmaxsubsteps nb maximun de substepping si fefp  : pas_defa 
   WTAB.'NMAXSUBSTEPS' = 1; 
 * nombre_iterations nb d'iterations du pas precedent : pasapas unpas 
   WTAB.'NOMBRE_ITERATIONS'='MOT' 'INCONNU'; 
 * non_lineaire il existe un materiau utilisateur non-lineaire  : pas_defa 
   WTAB.'NON_LINEAIRE'= FAUX; 
 * non_local decrit le modele de comportement non_local (preced.non_local) 
   WTAB.'NON_LOCAL' = 'MOT' 'INCONNU' ; 
 * nouveau vrai si premier calcul    : pas_defa 
   WTAB.'NOUVEAU'=VRAI; 
 * delta temps du pas en cours pour dupont2 : pasapas 
   WTAB.'NOUV_PAS'=0.D0; 
 *  nsor numero a ecrire dans les tables de resultats : pas_ init 
   WTAB.'NSOR'=0; 
 * operateur matrice contenant l'operateur d'iterations : pasapas 
   WTAB.'OPERATEUR'='MOT' 'INCONNU'; 
 * Ordre est l'ordre de developpement de la MAN 
   WTAB.'ORDRE'=12; 
 * para_exte il existe des parametres externes  : pas_verm 
   WTAB.'PARA_EXTE' = FAUX; 
 * pas numero du pas de temps utile a transnon : pasapas 
   WTAB.'PAS'=0; 
 * pas_ajuste si ajustement automatique de longueur de pas : pas_defa 
   WTAB.'PAS_AJUSTE' = FAUX; 
 * pas_redu  en automatiqu il a fallu reduire le pas  : pasapas unpas 
   WTAB.'PAS_REDU'=FAUX; 
 * phase  il xiste du changement de phase : pas_defa 
   WTAB.'PHASE'=FAUX; 
 * plastique il exite un comportement plastique : pas_defa 
   WTAB.'PLASTIQUE' = FAUX; 
 * por1 il existe un model poreux  : pas_defa 
   WTAB.'POR1' = FAUX; 
 * precdecharge critere de decharge en opilotage automatique  : pas_defa 
   WTAB.'PRECDECHARGE' = 1.E-2; 
 * precflex critere de desequilibre sur moment autorise : pas_defa 
   WTAB.'PRECFLEX' = 1.E-4; 
 * precisinter precision pour les iterations locales (fefp): pas_defa 
   WTAB.'PRECISINTER' = 1.D-8; 
 * precision critere de convergence Thermique & Mecanique : pas_defa 
   WTAB.'PRECISION' = 1.E-4 ; 
 * predicteur 
   WTAB.'PREDICTEUR' = 'MOT' 'INCONNU'; 
 * procedure initialisation pour g_theta 
   WTAB.'PROCEDURE'='MOT' 'PASAPAS'; 
 * procedure_charmeca il faut appele la procedure charmeca  : pas_defa 
   WTAB.'PROCEDURE_CHARMECA'=FAUX; 
 * procedure_charther il faut appele la procedure charther  : pas_defa 
   WTAB.'PROCEDURE_CHARTHER'=FAUX; 
 * procedure_conv il faut appele la procedure pro_conv :  pas_defa 
   WTAB.'PROCEDURE_CONV'=FAUX; 
 * procedure_parather il faut appeler la procedure parather : pas_defa 
   WTAB.'PROCEDURE_PARATHER' = FAUX ; 
 * procedure_perso1 il faut appeler la procedur perso1:  pas_defa 
   WTAB.'PROCEDURE_PERSO1' = FAUX; 
 * procedure_perso2 il faut appeler la procedur perso2:  pas_defa 
   WTAB.'PROCEDURE_PERSO2' = FAUX; 
 * procedure_reev_mec  il faut appeler la procedur reev_mec :  pas_defa 
   WTAB.'PROCEDURE_REEV_MEC' = FAUX ; 
 * procedure_reev_the  il faut appeler la procedur reev_the :  pas_defa 
   WTAB.'PROCEDURE_REEV_THE' = FAUX ; 
 * procedur_thermique non de la procedure thermique a appeler :  pas_defa 
   WTAB.'PROCEDURE_THERMIQUE'='MOT' 'INCONNU'; 
 * processeurs pour imposer l'option de parallelisme 
   WTAB.'PROCESSEURS'='MOT' 'INCONNU'; 
 * projection le champ de temperature clcule doit etere projete:  pas_defa 
   WTAB.'PROJECTION'= FAUX; 
 * raidconst il existe des raideurs constantes :  pas_defa 
   WTAB.'RAIDCONST' = FAUX; 
 * raidaugm diffaugm theraugm il existe des raideurs augmentees :  pas_defa 
   WTAB.'RAIDAUGM' = FAUX; 
   WTAB.'DIFFAUGM' = FAUX; 
   WTAB.'THERAUGM' = FAUX; 
 * autaug  augmentation automatique :  pas_defa 
   WTAB.'AUTOAUGM' = FAUX; 
 * rayo il existe du rayonnement en thermique :  pas_defa 
   WTAB.'RAYO'=FAUX; 
 * rayonnement on y met des pre-calculs pour le rayonnement  : transnon charther 
   WTAB.'RAYONNEMENT'='MOT' 'INCONNU'; 
 * Reactualisation de la matrice en grands deplacements pour 0,1 de defor 
   WTAB.'REAC_GRANDS'= 0.1 ; 
 * logique disant pour charther si geometrie a change : pasapas 
   WTAB.'REA_GEOM' = FAUX ; 
 * reaprec utile pour les contacts unilateraux en dynamiques 
   WTAB.'REAPREC'='MOT' 'INCONNU'; 
 * recalcul =vrai il faut recalculer la raideur .. 
   WTAB.'RECALCUL'= FAUX; 
 * recaop  = recalcul operateur 
 * recadet = oubli operateur (destruction de la rigi en commentaire) 
 * recari  = recalcul rigidite 
   WTAB.'RECAOP'  = VRAI; 
   WTAB.'RECADET' = FAUX; 
   WTAB.'RECARI'  = FAUX; 
 * relaxation_dupont2 coeff de relaxation pour dupont2  :  pas_defa 
   WTAB.'RELAXATION_DUPONT'=0.25; 
 * parametre de relaxation du pas de temps en non convergence 
   WTAB.'RELAXATION_NONCONV' = 1.; 
 * relaxation_thet   coeff de relaxation pour transnon :  pas_defa  transnon 
   WTAB.'RELAXATION_THETA'= 1. ; 
 * renormalisation de l'itere pour le limiter :  pas_defa 
   WTAB.'RENORMALISATION' = FAUX; 
 * residu chpoint donnant le dernier residu d'equilibre : pasapas unpas 
   WTAB.'RESIDU'='MOT' 'INCONNU'; 
 * riblo_m  matrice de blocages des appuis unilateraux : unpas 
   WTAB.'RIBLO_M'='MOT' 'INCONNU'; 
 * riblo_t matrice de blocages des changement de phase : transnon 
   WTAB.'RIBLO_T'='MOT' 'INCONNU'; 
 * valeurr des rigidites constantes 
   WTAB.'RIGIDITE_CONSTANTE'= 'MOT' 'INCONNU'; 
 * second_membre c'est le second_membre du pas d'avant : unpas 
   WTAB.'SECOND_MEMBRE'='MOT' 'INCONNU'; 
 * sous_increment nombre de sous increment 
   WTAB.'SOUS_INCREMENT'=1 ; 
 * SOURCE_Q presence d'un modele thermique source de chaleur 
   WTAB.'SOURCE_Q'=FAUX; 
 * test stabilite de la solution 
   WTAB.'STABILITE' = VRAI; 
 * substepping  pour integrer en petites deformation :  pas_defa 
   WTAB.'SUBSTEPPING'=FAUX; 
 * succes la procedur unpas s'est bien terminee pasapas unpas 
   WTAB.'SUCCES'=VRAI; 
 * tabsauv table indiquant les options de sauv des resultats :  pas_defa 
   WTAB.'TABSAUV'='MOT' 'INCONNU'; 
 * temps0 temps de calcul precedent : pas_defa pasapas 
   WTAB.'TEMPS0'=0.D0; 
 * temps_calcules liste des tempsd a calculer  :  pas_defa 
   WTAB.'TEMPS_CALCULES'='MOT' 'INCONNU'; 
 * tem_calc liste des temps a calculer pour les proc thermique : pasapas 
   WTAB.'TEM_CALC'='MOT' 'INCONNU'; 
 * teta facteur pour la theta methode en consolidation  :  pas_defa 
   WTAB.'TETA'=  1.0D0; 
 * tet0 champ de temperature 2  pas avant   : pasapas dupont2 
   WTAB.'TET0'=0; 
 * tet1 champ de temperature 1  pas avant   : pasapas 
   WTAB.'TET1'=0; 
 * tet2 champ de temperature du pas courant : pasapas 
   WTAB.'TET2'=0; 
 * the1 le calcul inclus des modeles thermique :  pas_defa 
   WTAB.'THE1' = FAUX; 
 * ther_courant champ de temperature propose pour charther : dupont2 transnon 
   WTAB.'THER_COURANT'='MOT' 'INCONNU'; 
 * thm1 le calcul inclus des modeles thermohydriques : pas_defa 
   WTAB.'THM1' = FAUX; 
 * tref temperature de reference 0 ou 273 : transnon dupont2 
   WTAB.'TREF' = 0.D0; 
 * t_final objectif du temps a calcule si pas_ajuste pasapas 
   WTAB.'T_FINAL'=0.D0; 
 * update_lagrangian  on veut faire du lagrangien reactualise fefp: pas_defa 
   WTAB.'UPDATE_LAGRANGIAN' = FAUX; 
 * vieuxpas dt precedent  pour dupont2 
   WTAB.'VIEUXPAS'=0.D0; 
 * viscodommage il existe un modele de comportement viscodommage : pas_defa 
   WTAB.'VISCODOMMAGE'=FAUX; 
 * viscoplastique il existe un modele de comportement viscoplastique  : pas_defa 
   WTAB.'VISCOPLASTIQUE' = FAUX; 
 * visco_externe il existe un  modele de comportementvisco_externe  : pas_defa 
   WTAB.'VISCO_EXTERNE'=FAUX; 
 * xdeno valeur pour calculer le critere de convergence force : unpas 
   WTAB.'XDENO'=0.d0; 
 * xdenom valeur pour calculer le critere de convergence moment : unpa 
   WTAB.'XDENOM'=0.d0; 
   'SI' ( 'EXIS' PRECED 'CONTINUATION' ); 
 *  c'est la reprise d'un fichier cree avec l'ancien PASAPAS 
      iii = 'INDEX' PRECED;nii= 'DIME' iii; 
      'REPETER' boui nii; 
      imo=0; 
      'SI' ('EGA' ('TYPE' iii.&boui ) 'MOT     '); imo=1; 'FINSI'; 
       'SI' ('EGA' imo 1);  aa= 'MOT' iii.&boui; 
       'SINON';  aa=   iii.&boui; 'FINSI'; 
        'SI'('NON' ('EXIS' wtab aa)); 
          WTAB . aa = PRECED . aa; 
        'FINSI'; 
      'FIN' BOUI; 
   'FINSI'; 
   'SI' ('EXIS' PRECED 'REPRISE'); 
      'SI' ( > PRECED.'REPRISE' 0); 
        ii= 'INDEX' (preced.'TEMPS'); 
        nn = 'DIME' ii; nsor = ii . nn; 
        temps0= PRECED. 'TEMPS' . nsor; 
        WTAB.'NSOR' = NSOR; 
        WTAB.'TEMPS0'=temps0; 
      'FINSI'; 
   'FINSI'; 
   
 ************************************************************************ 
 ************* CAS DE LA REPRISE D UNE WTAB EXISTANTE ******************* 
 ************************************************************************ 
 'SINON'; 
 *  indices de wtab remis a leur valeur par defaut quand on re-entre 
 *  dans pasapas 
    WTAB.'AMORTISSEMENT'        ='MOT' 'INCONNU' ; 
    WTAB.'AUTOMATIQUE'          = FAUX; 
    WTAB.'CAPACONST'            = FAUX; 
    WTAB.'CHARGEMENT'           ='MOT' 'INCONNU' ; 
    WTAB.'CHAR_DEFI'            = FAUX; 
    WTAB.'CHAR_MATE'            = FAUX; 
    WTAB.'CHAR_MODE'            = FAUX; 
    WTAB.'CHAR_PRES'            = FAUX; 
    WTAB.'CHAR_THE'             = FAUX; 
    WTAB.'CHAR_PILO'            = FAUX; 
    WTAB.'CHAR_BLOD'            = FAUX; 
    WTAB.'CHAR_BLOM'            = FAUX; 
    WTAB.'CHAR_BLOT'            = FAUX; 
    WTAB.'CONDCONST'            = FAUX; 
    WTAB.'CONVERGENCE_FORCEE'   = VRAI; 
    WTAB.'CONVERGENCE_MONOTONE' = FAUX; 
    WTAB.'DYNAMIQUE'            = FAUX; 
    WTAB.'EPOQUE'               ='DATE' 'EPOCH'; 
    WTAB.'ETAT_REF'             ='MOT' 'INCONNU' ; 
    WTAB.'ETREF'                ='MOT' 'INCONNU' ; 
    WTAB.'FOR_DIFF'             = FAUX ; 
    WTAB.'FOR_METALLU'          = FAUX; 
    WTAB.'FREQUENTIEL'          = FAUX; 
    WTAB.'FTOL'                 ='MOT' 'INCONNU' ; 
    WTAB.'INITIALISATION'       = VRAI; 
    WTAB.'ISAUVEGA'             ='MOT' 'INCONNU' ; 
    WTAB.'ISAUVEGL'             = FAUX; 
    WTAB.'K_SIGMA'              = FAUX; 
    WTAB.'K_TANGENT'            = FAUX; 
    WTAB.'K_TANGENT_ITER0'      ='MOT' 'INCONNU' ; 
    WTAB.'K_TANGENT_PERT'       = FAUX ; 
    WTAB.'K_TANGENT_SYME'       = FAUX ; 
    WTAB.'K_TANG_PERT_C1'       = 1.D-3 ; 
    WTAB.'K_TANG_PERT_C2'       ='MOT' 'INCONNU' ; 
    WTAB.'LAG_TOT'              = 3; 
    WTAB.'LECONOMI'             = FAUX; 
    WTAB.'LIAISON_PERSISTANTE'  = FAUX; 
    WTAB.'LINESEARCH'           = FAUX; 
    WTAB.'MASSCONST'            = FAUX; 
    WTAB.'MESSTHER'             = VRAI; 
    WTAB.'MAT_DIF'              ='MOT' 'INCONNU' ; 
    WTAB.'MAT_REF'              ='MOT' 'INCONNU' ; 
    WTAB.'MAT_T'                ='MOT' 'INCONNU' ; 
    WTAB.'MAT_THM'              ='MOT' 'INCONNU' ; 
    WTAB.'MOD_DIF'              ='MOT' 'INCONNU' ; 
    WTAB.'MOD_T'                ='MOT' 'INCONNU' ; 
    WTAB.'MOD_THM'              ='MOT' 'INCONNU' ; 
    WTAB.'MTOL'                 ='MOT' 'INCONNU' ; 
   'SI' ('NON' ('EXISTE' WTAB  'OPERATEUR')); 
      WTAB.'OPERATEUR'          ='MOT' 'INCONNU' ; 
   'FINSI' ; 
   'SI' ('EXISTE' WTAB 'NON_LOCAL') ; 
     'SI' ('EGA' ('TYPE' WTAB.'NON_LOCAL') 'LOGIQUE') ; 
        WTAB.'NLOC'             = WTAB.'NON_LOCAL' ; 
        WTAB.'NON_LOCAL'        ='MOT' 'INCONNU'   ; 
       'SI' WTAB.'NLOC' ; 
          WTAB.'NON_LOCAL'      ='MOT' 'MOYE' ; 
       'FINSI' ; 
     'SINON' ; 
       'SI' ('NEG' ('TYPE' WTAB.'NON_LOCAL') 'MOT') ; 
          WTAB.'NLOC'           = FAUX ; 
          WTAB.'NON_LOCAL'      ='MOT' 'INCONNU' ; 
       'FINSI' ; 
     'FINS' ; 
   'SINON' ; 
     WTAB.'NLOC'                = FAUX ; 
     WTAB.'NON_LOCAL'           ='MOT' 'INCONNU' ; 
   'FINS' ; 
    WTAB.'PAS_AJUSTE'           = FAUX ; 
    WTAB.'PAS_REDU'             = FAUX ; 
    WTAB.'PROCEDURE_CHARMECA'   = FAUX ; 
    WTAB.'PROCEDURE_CHARTHER'   = FAUX ; 
    WTAB.'PROCEDURE_PARATHER'   = FAUX ; 
    WTAB.'PROCEDURE_PERSO1'     = FAUX ; 
    WTAB.'PROCEDURE_PERSO2'     = FAUX ; 
    WTAB.'PROCEDURE_REEV_MEC'   = FAUX ; 
    WTAB.'PROCEDURE_REEV_THE'   = FAUX ; 
    WTAB.'PROCESSEURS'          ='MOT' 'INCONNU' ; 
    WTAB.'PROJECTION'           = FAUX ; 
    WTAB.'RAIDCONST'            = FAUX ; 
    WTAB.'RAIDAUGM'             = FAUX ; 
    WTAB.'DIFFAUGM'             = FAUX ; 
    WTAB.'THERAUGM'             = FAUX ; 
    WTAB.'AUTOAUGM'             = FAUX ; 
    WTAB.'RAYO'                 = FAUX ; 
    WTAB.'RELAXATION_NONCONV'   = 1.   ; 
    WTAB.'RENORMALISATION'      = FAUX ; 
    WTAB.'STABILITE'            = VRAI ; 
    WTAB.'TEMPS_CALCULES'       ='MOT' 'INCONNU' ; 
    WTAB.'THM1'                 = FAUX ; 
   'SI'('NON' ('EXIS' WTAB 'REAC_GRANDS')); 
      WTAB.'REAC_GRANDS'        = 0.1 ; 
   'SINO' ; 
     'SI' ('NEG' ('TYPE' WTAB . 'REAC_GRANDS') 'FLOTTANT') ; 
        WTAB.'REAC_GRANDS'      = 0.1 ; 
     'FINS' ; 
   'FINSI'; 
   'SI' ('NON' ('EXISTE' WTAB 'TET_INI')) ; 
      WTAB.'TET_INI'            ='MOT' 'INCONNU' ; 
   'FINSI'; 
 'FINSI'; 
   
 ************************************************************************ 
 ************* REMPLISSAGE DE WTAB EN FONCTION DE PRECED **************** 
 ************************************************************************ 
   
 *----------- calcul en frequentiel --------------------- 
 WTAB.'FREQUENTIEL' = 'EGA' ('VALE' 'MODE') 'FREQ' ; 
   
 * verification donnee du modele ------------------------------ 
 'SI' ( 'EXISTE' PRECED 'MODELE'); 
     MO= PRECED.'MODELE'; 
     TYP1 = 'TYPE' MO; 
    'SI' ('NEG' TYP1 'MMODEL  '); 
       'ERREUR' 'Le type du MODELE est incorrect'; 
    'FINSI'; 
 *   En cas de reprise, l'indice modele_initial (voir PAS_MODL) permet 
 *   de savoir si l'utilisateur a change le modele en entree de la table 
    'SI' ('EXIS' WTAB 'MODELE_INITIAL') ; 
       'SI' ('NEG' MO WTAB.'MODELE_INITIAL') ; 
          WTAB.'MODELE'=MO; 
       'FINSI' ; 
    'FINSI' ; 
 'SINON'; 
    'ERREUR' 'Il manque la donnee du modele.'; 
 'FINSI'; 
   
 * verification existence chargement sinon creation  ------------ 
 'SI' ('EXISTE' PRECED 'CHARGEMENT'); 
    TYP1 = 'TYPE' (PRECED.'CHARGEMENT'); 
    'SI' ('NEG' TYP1 'CHARGEME'); 
       'ERREUR' 'Le type du CHARGEMENT est incorrect'; 
    'FINSI'; 
    WTAB.'CHARGEMENT'=PRECED.'CHARGEMENT'; 
 'SINON'; 
    MAGEO= 'EXTR' MO 'MAILLAGE' ; 
    WTAB.'CHARGEMENT' = 'CHAR' 'FARFELU' ('MANU' 'CHPO' MAGEO 1 'FARF' 0.) ('EVOL' 'MANU'  ('PROG' 0. 10.e15 ) ('PROG' 0. 10.e15)); 
 'FINSI'; 
 *  verification donnee caracteristiques et initialisation MA 
 'SI' ('EXISTE' PRECED 'CARACTERISTIQUES'); 
    MA= PRECED.'CARACTERISTIQUES'  ; 
    TYP1 = 'TYPE' MA ; 
    'SI' ('NEG' TYP1 'MCHAML  '); 
       'ERREUR' 'Le type du champ de materiau est incorrect'; 
    'FINSI'; 
    WTAB.'CARACTERISTIQUES'=MA ; 
 'SINON'; 
    'ERREUR' 'Il manque la donnee du materiau.'; 
 'FINSI'; 
 * verification type des temps_calcules (il peut ne pas y en avoir) 
 'SI' ('EXISTE' PRECED 'TEMPS_CALCULES'); 
    TYP1 = 'TYPE' PRECED.'TEMPS_CALCULES'; 
    'SI' ('NEG' TYP1 'LISTREEL'); 
       'ERREUR' 'Le type de TEMPS_CALCULES est incorrect'; 
    'FINSI'; 
    WTAB.'TEMPS_CALCULES'= PRECED.'TEMPS_CALCULES'; 
 'FINSI'; 
 * 
 * Modele FREQUENTIEL : liste automatique temps_calcules 
 * 
 'SI' (WTAB.'FREQUENTIEL' 'ET' 
                  ('NON' ('EXISTE' PRECED 'TEMPS_CALCULES'))); 
  l_zf = 'PROG' ; l_ii = 'PROG' 1. 'PAS' 0.3 4. 'PAS' 1. 10. ; 
  'SI' ('EXISTE' WTAB.'CARACTERISTIQUES' 'FREQ') ; 
   ccfr1 = 'EXCO' WTAB.'CARACTERISTIQUES' 'FREQ' 'NOID' ; 
   'SI' ('EGA' ('TYPE' ccfr1) 'MCHAML  ') ; 
  ncfr1 = 'EXTR' ccfr1 'NBZO' ; 
   'REPE' vfr1 ncfr1 ; 
 ** hypothese 1 modele = 1 mode !! 
    f1 = 'EXTR' ccfr1 'FREQ' &vfr1 1 1 ; 
 * 
 log_f1 = ('LOG' f1) / ('LOG' 10.) ; 
   
 e10_f1 = 'ENTI' log_f1 ; 
   'SI' (log_f1 < 0.) ; e10_f1 = e10_f1 - 1 ; 'FINSI' ; 
   'SI'((log_f1 - e10_f1) 'EGA' 0.) ; e10_f1 = e10_f1 - 1 ; 'FINSI' ; 
 p10_f1 = 10. ** e10_f1 ; 
 l_zf1 = 'PROG' (f1 - (p10_f1/10.)) (f1 - (p10_f1/100.)) 
       (f1 - (p10_f1/1000.)) (f1 + (p10_f1/1000.)) ; 
 *      (f1 + (p10_f1/100.)) (f1 + (p10_f1/10.)) ; 
   
           l_i10 = l_ii * p10_f1 ; 
    'SI' (('DIME' l_zf) 'EGA' 0) ; 
       e10_min = e10_f1 ; e10_max = e10_f1 + 1 ; 
      l_zf = 'ORDO' (l_i10 'ET' l_zf1) 'UNIQ' ; 
    'SINON' ; 
      l_zf0 = l_zf ; 
      'SI' ((e10_f1 '>EG' e10_min) 'ET' (e10_f1 < e10_max)) ; 
       l_zf = 'ORDO' (l_zf 'ET' l_zf1) 'UNIQ' ; 
      'SINON' ; 
        'SI' (e10_f1 < e10_min) ; 
         e10_u = e10_f1 ; 
         'REPE'  b_lz ; 
          l_zf0 = l_i10 'ET' l_zf0 ; e10_u = e10_u + 1 ; 
          'SI' (e10_u 'EGA' e10_min) ; 'QUIT' b_lz ; 'FINSI'  ; 
          l_i10 = l_i10 * 10 ; 
         'FIN'  b_lz ; 
         e10_min = e10_f1 ; 
         l_zf = 'ORDO' (l_zf0 'ET' l_zf1) 'UNIQ' ; 
        'FINSI'  ; 
        'SI' (e10_f1 '>EG' e10_max) ; 
         e10_u = e10_f1 ; 
         'REPE'  b_lz ; 
          l_zf0 = l_i10 'ET' l_zf0 ; e10_u = e10_u - 1 ; 
          'SI' (e10_u < e10_max) ; 'QUIT' b_lz ; 'FINSI'  ; 
          l_i10 = l_i10 / 10 ; 
         'FIN'  b_lz ; 
         e10_max = e10_f1 + 1; 
         l_zf = 'ORDO' (l_zf0 'ET' l_zf1) 'UNIQ' ; 
        'FINSI'  ; 
      'FINSI'  ; 
    'FINSI'  ; 
   'FIN'  vfr1 ; 
   'SINON' ; 
   l_zf = l_ii ; 
   'FINSI' ; 
   WTAB.'TEMPS_CALCULES' = l_zf ; 
  'SINON' ; 
   WTAB.'TEMPS_CALCULES' = l_ii ; 
  'FINSI' ; 
 'FINSI' ; 
 'SI' (WTAB.'FREQUENTIEL') ; 
   'REPETER' BTFRE ; 
     TI = 'EXTRAIRE'  WTAB.'TEMPS_CALCULES' &BTFRE ; 
     'SI' (TI '>' 0.D0) ; 
        WTAB.'TEMPS0' = TI ; 
        'QUITTER' BTFRE ; 
     'FINSI' ; 
  'FIN' BTFRE ; 
 'FINSI'; 
 * 
 *-------   initialisation deltaiter 
 'SI' ('EXISTE' PRECED 'DELTAITER'); 
    WTAB.'DELTAITER'=PRECED.'DELTAITER'; 
 'FINSI' ; 
 *------ existe-t-il une demande de pas automatique? 
 'SI' ('EXISTE' PRECED 'AUTOMATIQUE'); 
   WTAB.'AUTOMATIQUE'= PRECED.'AUTOMATIQUE'; 
 *   par defaut pas de controle de stabilite en pilotage 
   WTAB.'STABILITE'= FAUX; 
 'FINSI' ; 
 *------------ y-a-t-il la donnee FTOL puis MTOL? 
 'SI' ('EXISTE' PRECED 'FTOL' ); 
    WTAB.'FTOL' = PRECED.'FTOL'; 
 'FINSI'; 
 'SI' ('EXISTE' PRECED 'MTOL' ); 
    WTAB.'MTOL' = PRECED.'MTOL'; 
 'FINSI'; 
 *------------ y-a-t-il l'option 'PAS_AJUSTE'? 
 'SI' ('EXISTE' PRECED 'PAS_AJUSTE'); 
     WTAB.'PAS_AJUSTE' =  PRECED.'PAS_AJUSTE'; 
 'SINON'; 
    'SI'  (('NON' ( 'EXISTE' PRECED 'TEMPS_CALCULES' )) 
      'ET' ('EGA' ('TYPE' WTAB.'TEMPS_CALCULES') 'MOT')) ; 
          WTAB.'PAS_AJUSTE' = VRAI; 
         'SI'  ( 'NON' ( 'EXISTE' PRECED 'TEMPS_SAUVES' )); 
             'ERREUR' 
           'Il manque la donnee des temps a sauver ou a calculer'; 
         'FINSI'; 
         WTAB.'TEMPS_CALCULES'= PRECED.'TEMPS_SAUVES'; 
         WTAB.'TEMPS_SAUVES' = PRECED.'TEMPS_SAUVES'; 
    'FINSI'; 
 'FINSI'; 
 'SI' WTAB.'AUTOMATIQUE';  WTAB.'PAS_AJUSTE'= FAUX; 'FINSI'; 
   
 * ---------- verif existence des termps a calculer 
 'SI' ( 'EGA' WTAB.'TEMPS_CALCULES' 'INCONNU'); 
     'ERREUR' 'Il manque la donnee des TEMPS_CALCULES '; 
 'FINSI'; 
   
 *----------faut-il calculer l'operateur de resolutions? 
   'SI' ('NEG' WTAB.'OPERATEUR' 'INCONNU'); 
      WTAB.'RECAOP' = FAUX ; 
   'FINSI' ; 
 *-----------existe-t-il une procedure chargement mecanique? 
 'SI'  ('EXISTE' PRECED  'PROCEDURE_CHARMECA'); 
   WTAB.'PROCEDURE_CHARMECA'= PRECED . 'PROCEDURE_CHARMECA'; 
 'FINSI'; 
   
 *-----------a-t-on  une option de parallelisme 
 'SI'  ('EXISTE' PRECED  'PROCESSEURS'); 
   WTAB.'PROCESSEURS'= 'MOT' PRECED  . 'PROCESSEURS'; 
 'FINSI'; 
   
 *---------existe-t-il une procedure chargement thermique? 
 'SI'  ('EXISTE' PRECED  'PROCEDURE_CHARTHER'); 
   WTAB.'PROCEDURE_CHARTHER'= PRECED . 'PROCEDURE_CHARTHER'; 
 'FINSI'; 
   
 *----- Existe-t-il une procedure parametres externes en thermique ? 
 'SI' ('EXISTE' PRECED 'PROCEDURE_PARATHER') ; 
   WTAB.'PROCEDURE_PARATHER' = PRECED.'PROCEDURE_PARATHER' ; 
 'FINSI'; 
   
 *----------la procedure a utilisee en thermique est-elle precisee 
 *-----------si non mettre  nonlineaire 
 WTAB. 'PROCEDURE_THERMIQUE' = 'NONLINEAIRE'; 
 'SI' ('EXISTE' PRECED 'PROCEDURE_THERMIQUE'); 
    WTAB. 'PROCEDURE_THERMIQUE' = PRECED.'PROCEDURE_THERMIQUE'; 
 'FINSI'; 
 * 
 *---------- y-a-t-il des elements de capacite constante ? --------- 
    'SI' ( 'EXISTE' PRECED 'CAPACITE_CONSTANTE'); 
        WTAB.'CAPACITE_CONSTANTE'=PRECED.'CAPACITE_CONSTANTE'; 
        WTAB.'CAPACONST'=VRAI; 
    'FINSI'; 
 *---------- y-a-t-il des elements de conductivite constante ? --------- 
    'SI' ( 'EXISTE' PRECED 'CONDUCTIVITE_CONSTANTE'); 
        WTAB.'CONDUCTIVITE_CONSTANTE'=PRECED.'CONDUCTIVITE_CONSTANTE'; 
        WTAB.'CONDCONST'=VRAI; 
    'FINSI'; 
 * 
 *-------------------------- Appel a PAS_MODL --------------------------* 
 * Initialisation des indices relatifs aux sous-modeles (formulations, 
 * materiaux...) : Appel a PAS_MODL 
   
 * Dans PAS_DEFA, on oublie l'indice MODEL_COURANT pour re-initialiser la table : 
   si (exis WTAB 'MODELE_COURANT') ; 
     oubl WTAB 'MODELE_COURANT' ; 
   fins ; 
   
 * Indice 'MO_TOT_PREC' gere par UNPAS 
 * On le supprime dans PAS_DEFA pour le re-initialiser 
   si (exis WTAB 'MO_TOT_PREC') ; 
     oubl WTAB 'MO_TOT_PREC' ; 
   fins ; 
   
   PAS_MODL PRECED ; 
   
 * Si formulation THERMIQUE ou THERMOHYDRIQUE : 
 'SI'  (WTAB.'FOR_THER') ; 
    'SI'('EXIS' PRECED 'CELSIUS'); 
       WTAB.'CELSIUS'=PRECED.'CELSIUS'; 
       WTAB.'TREF'   = 273.15 ; 
    'FINSI'; 
    'SI' WTAB.'RAYO' ; 
       WTAB.'RAYONNEMENT' = 'PRRA' WTAB.'MOD_RAY'; 
    'FINSI'; 
    'SI' ( 'EXIS' PRECED 'BLOCAGES_THERMIQUES' ); 
       WTAB. 'BLOCAGES_THERMIQUES' = PRECED. 'BLOCAGES_THERMIQUES'; 
    'FINSI'; 
 'FINSI'; 
   
 * BLOCAGES_DIFFUSIONS : 
 'SI' (WTAB.'FOR_DIFF') ; 
   'SI' ('EXIS' PRECED 'BLOCAGES_DIFFUSIONS') ; 
     WTAB . 'BLOCAGES_DIFFUSIONS' = PRECED .  'BLOCAGES_DIFFUSIONS'; 
   'FINSI' ; 
 'FINSI' ; 
   
 * PROCEDURE_THERMIQUE : 
 'SI' ((WTAB.'PHASE') 'OU' (WTAB.'FOR_DIFF') 'OU' (WTAB.'THM1')) ; 
    WTAB.'PROCEDURE_THERMIQUE'='NONLINEAIRE'; 
 'FINSI'; 
   
 * Noms des inconnues passees a TRANSNON : 
 'SI' ('NEG' WTAB.'MOD_TOT' 'INCONNU') ; 
   WTAB.'PRIM_TOT' ='EXTR' WTAB.'MOD_TOT' 'DEPL' ; 
   WTAB.'DUAL_TOT' ='EXTR' WTAB.'MOD_TOT' 'FORC' ; 
   WTAB.'PRIM_TOT' = WTAB.'PRIM_TOT' 'ET' ('MOTS' 'LX') ; 
   WTAB.'DUAL_TOT' = WTAB.'DUAL_TOT' 'ET' ('MOTS' 'FLX') ; 
 'FINS' ; 
   
 'SI' WTAB . 'FOR_THER' ; 
   WTAB.'PRIM_T' ='EXTR' WTAB.'MOD_T' 'DEPL' ; 
   WTAB.'DUAL_T' ='EXTR' WTAB.'MOD_T' 'FORC' ; 
   WTAB.'PRIM_T' = WTAB.'PRIM_T' 'ET' ('MOTS' 'LX') ; 
   WTAB.'DUAL_T' = WTAB.'DUAL_T' 'ET' ('MOTS' 'FLX') ; 
 'FINS' ; 
   
 'SI' WTAB . 'FOR_DIFF' ; 
   WTAB.'PRIM_DIF' ='EXTR' WTAB.'MOD_DIF' 'DEPL' ; 
   WTAB.'DUAL_DIF' ='EXTR' WTAB.'MOD_DIF' 'FORC' ; 
   WTAB.'PRIM_DIF' = WTAB.'PRIM_DIF' 'ET' ('MOTS' 'LX') ; 
   WTAB.'DUAL_DIF' = WTAB.'DUAL_DIF' 'ET' ('MOTS' 'FLX') ; 
 'FINS' ; 
   
 * GRANDS_DEPLACEMENTS si CONTACT : 
 'SI' (WTAB.'CONTACT') ; 
    WTAB.'GRANDS_DEPLACEMENTS' = VRAI; 
 'FINSI'; 
   
 * Si formulation POREUX : 
 'SI' (WTAB.'POR1') ; 
    WTAB.'MAI_POR' = 'EXTR' WTAB.'MOD_POR' 'MAIL'; 
    WTAB.'MOT_POR' = 'MOTS' 'FP' 'FPQ' 'FTP' ; 
 'FINSI'; 
   
 * Verif. CHARGEMENT si formulation CHARGEMENT : 
 'SI' ('EXIS' WTAB 'MOD_CHA') ; 
    'SI' ('NON' ('EXIS' (WTAB.'CHARGEMENT') 'PRES')) ; 
       'ERREUR' 'Il manque la donnee d un chargement de pression'; 
       'ERREUR' '-> voir la notice de l operateur CHAR'; 
    'FINSI' ; 
 'FINSI' ; 
   
 *----------- Test sur les differentes formulation du modele ------- 
 *                                                                     * 
 'SI' ('NON' (WTAB.'FOR_MECA' 'OU' WTAB.'FOR_THER' 'OU' WTAB.'FOR_DIFF')) ; 
    'ERREUR' 'Le modele ne correspond a aucune formulation valable'; 
 'FINSI'; 
   
 *---------- Calcul purement thermique / diffusion ? ou couplage? ------- 
 'SI' (WTAB.'FOR_THER' 'OU' WTAB.'FOR_DIFF'); 
   'SI'  WTAB.'FOR_MECA' ; 
      WTAB.'COUPLAGE' = VRAI; 
     'SI' ('EXIS' PRECED 'PROJECTION'); 
        WTAB.'PROJECTION'=PRECED.'PROJECTION'; 
     'FINSI'; 
   'SINON'; 
      WTAB.'PAS_AJUSTE'=FAUX; 
   'FINSI'; 
 'FINSI'; 
   
 *------------- existe-t-il un chargement thermique ? ----------- 
  WTAB.'CHAR_THE' = ('EXISTE' (WTAB.'CHARGEMENT') 'T'); 
   
 *------------ existe-t-il un chargement en deformations ?  -------- 
 'SI' ('EXISTE' (WTAB.'CHARGEMENT') 'DEFI'); 
    WTAB.'CHAR_DEFI' = VRAI; 
 'FINSI'; 
   
 *------------ existe-t-il un chargement de materiau ?  -------- 
 'SI' ('EXISTE' (WTAB.'CHARGEMENT') 'MATE'); 
    WTAB.'CHAR_MATE' = VRAI; 
 'FINSI'; 
   
 *------------ existe-t-il un chargement de modele ?  -------- 
 'SI' ('EXISTE' (WTAB.'CHARGEMENT') 'MODE'); 
    WTAB.'CHAR_MODE' = VRAI; 
 'FINSI'; 
   
 *------------ existe-t-il un chargement en pression suiveuse ?  -------- 
 'SI' ('EXISTE' WTAB 'MOD_PRE'); 
    WTAB.'CHAR_PRES' = VRAI; 
 'FINSI'; 
   
 *------------ existe-t-il un chargement en pilotage indirect ?  -------- 
 'SI' (  'EXISTE' PRECED 'PILOTAGE_INDIRECT') ; 
    WTAB.'CHAR_PILO' = VRAI; 
   
 *--------- et des deplacements pilotes 
   'SI' ('EXISTE' PRECED 'DEPLACEMENTS_PILOTES' ); 
      WTAB.'DEPLACEMENTS_PILOTES' = PRECED.'DEPLACEMENTS_PILOTES' ; 
   'SINON' ; 
      WTAB.'DEPLACEMENTS_PILOTES' = 'VIDE' 'CHPOINT' / 'DISCRET' ; 
   'FINSI'; 
   
 *--------- et des forces pilotees 
   'SI' ('EXISTE' PRECED 'FORCES_PILOTEES' ); 
      WTAB.'FORCES_PILOTEES' = PRECED.'FORCES_PILOTEES'; 
   'SINON' ; 
      WTAB.'FORCES_PILOTEES' = 'VIDE' 'CHPOINT' / 'DISCRET' ; 
   'FINSI'; 
   
 *--------- et une region de recherche 
   'SI' ('EXISTE' PRECED 'ZONE_DE_PILOTAGE' ); 
      WTAB.'ZONE_DE_PILOTAGE' = PRECED.'ZONE_DE_PILOTAGE'; 
   'FINSI'; 
   
 *--------- et le parametre de pilotage 
   'SI' ('EXISTE' PRECED 'PARAMETRE_DE_PILOTAGE' ); 
      WTAB.'PARAMETRE_DE_PILOTAGE' = PRECED.'PARAMETRE_DE_PILOTAGE'; 
   'FINSI'; 
 'FINSI'; 
   
   
 *------------ existe-t-il un chargement de bloccages ?  -------- 
 'SI' ('EXISTE' (WTAB.'CHARGEMENT') 'BLOD'); 
    WTAB.'CHAR_BLOD' = VRAI; 
 'FINSI'; 
 'SI' ('EXISTE' (WTAB.'CHARGEMENT') 'BLOM'); 
    WTAB.'CHAR_BLOM' = VRAI; 
 'FINSI'; 
 'SI' ('EXISTE' (WTAB.'CHARGEMENT') 'BLOT'); 
    WTAB.'CHAR_BLOT' = VRAI; 
 'FINSI'; 
   
 *-------- y a t-il de la dynamique --------------------- 
 'SI' (  'EXISTE' PRECED 'DYNAMIQUE') ; 
    WTAB.'DYNAMIQUE' = PRECED.'DYNAMIQUE'; 
   
 *--------- et de l'amortissement 
   'SI' ('EXISTE' PRECED 'AMORTISSEMENT' ); 
      WTAB.'AMORTISSEMENT' = 'EXTR' PRECED.'AMORTISSEMENT' 'RIGI' 'NOMU'; 
   'FINSI'; 
 'FINSI'; 
   
 *-------- y a t-il de la liaison persistante ? --------- 
 'SI' ( 'EXISTE' PRECED 'LIAISON_PERSISTANTE' ) ; 
    WTAB.'LIAISON_PERSISTANTE' = PRECED.'LIAISON_PERSISTANTE'; 
 'FINSI'; 
   
 *-- Dans le cas de la formulation POREUX y-a-t-il consolidation ? -- 
 *--- Dans ce cas il faut donner la matrice de permeabilite et ne --- 
 *--------------------- pas etre en dynamique ----------------------- 
 'SI' ('EXISTE' PRECED 'CONSOLIDATION')  ; 
     WTAB.'CONSOLIDATION' =  PRECED.'CONSOLIDATION'  ; 
 'FINSI'; 
 'SI' WTAB.'POR1'; 
    'SI' (WTAB.'CONSOLIDATION'); 
        'SI' ('NON' ('EXISTE' PRECED 'PERMEABILITE')); 
           'ERREUR' 'Il faut donner la matrice de permeabilite'; 
         'SINON'; 
            WTAB.'PERMEABILITE'=PRECED.'PERMEABILITE'; 
        'FINSI'; 
        'SI' (  'EXISTE' PRECED 'TETA' ) ; 
           WTAB.'TETA' = PRECED.'TETA'; 
        'FINSI'; 
        'SI' ( WTAB.'DYNAMIQUE' ); 
           'ERREUR' ' On ne peut pas etre en dynamique.' ; 
        'FINSI'; 
    'FINSI'; 
 'FINSI'; 
   
 *------ Est on en convergence forcee ? ---------------------------- 
 'SI' ( 'EXISTE' PRECED 'CONVERGENCE_FORCEE'); 
    WTAB.'CONVERGENCE_FORCEE'= PRECED.'CONVERGENCE_FORCEE'; 
 'SINON'; 
     'SI' ( 'NON'  WTAB.'AUTOMATIQUE'); 
         WTAB.'CONVERGENCE_FORCEE' = VRAI; 
     'FINSI'; 
 'FINSI'; 
   
 *------ A t'on un predicteur? ---------------------- 
 'SI' ( 'EXISTE' PRECED 'PREDICTEUR'); 
    WTAB.'PREDICTEUR'= 'MOT' PRECED.'PREDICTEUR'; 
 'FINSI'; 
   
 *------ test stabilite ---------------------- 
 'SI' ( 'EXISTE' PRECED 'STABILITE'); 
  'SI' ('EGA' PRECED.'STABILITE' FAUX); 
    WTAB.'STABILITE'= FAUX; 
  'SINON'; 
    WTAB.'STABILITE'= VRAI; 
  'FINSI'; 
 'FINSI'; 
   
 *------ LINESEARCH ---------------------- 
 'SI' ( 'EXISTE' PRECED 'LINESEARCH'); 
  'SI' ('EGA' PRECED.'LINESEARCH' VRAI); 
    WTAB.'LINESEARCH'= VRAI; 
    WTAB.'GRANDS_DEPLACEMENTS' = VRAI; 
  'SINON'; 
    WTAB.'LINESEARCH'= FAUX; 
  'FINSI'; 
 'FINSI'; 
   
 *------ INITIALISATION ---------------------- 
 'SI' ( 'EXISTE' PRECED 'INITIALISATION'); 
    WTAB.'INITIALISATION' = PRECED.'INITIALISATION'; 
 'FINSI'; 
 *------ RENORMALISATION ---------------------- 
 'SI' ( 'EXISTE' PRECED 'RENORMALISATION'); 
    WTAB.'RENORMALISATION' = PRECED.'RENORMALISATION'; 
 'FINSI'; 
 *------ CONVERGENCE_MONOTONE ---------------------- 
 'SI' ( 'EXISTE' PRECED 'CONVERGENCE_MONOTONE'); 
    WTAB.'CONVERGENCE_MONOTONE' = PRECED.'CONVERGENCE_MONOTONE'; 
 'FINSI'; 
   
 *------------- MAXDEFOR ------------- 
 'SI' (WTAB.'CONVERGENCE_FORCEE' 'OU' WTAB.'RENORMALISATION'); 
     WTAB.'MAXITERATION' = 250; 
    'SI' ('EXISTE' PRECED 'MAXDEFOR'); 
         WTAB.'MAXDEFOR'=PRECED.'MAXDEFOR' ; 
    'FINSI'; 
    'SI' WTAB.'CONVERGENCE_FORCEE'; 
       'SI' ('EXISTE' PRECED 'RELAXATION_NONCONV'); 
            WTAB.'RELAXATION_NONCONV'=PRECED.'RELAXATION_NONCONV' ; 
       'FINSI'; 
    'FINSI'; 
 'FINSI'; 
   
 *----- est-on en convergence MEC_THE?   ------------- 
 'SI'  ('EXISTE' PRECED 'CONVERGENCE_MEC_THE'); 
    WTAB.'CONVERGENCE_MEC_THE'=PRECED.'CONVERGENCE_MEC_THE'; 
 'FINSI'; 
 'SI' WTAB.'CONVERGENCE_MEC_THE'; 
    WTAB.'AUTOMATIQUE'=FAUX; 
    WTAB.'CONVERGENCE_FORCEE' =FAUX; 
    'SI'(WTAB.'PAS_AJUSTE'); 
    'ERREUR'  'Options CONVERGENCE_MEC_THE et PAS_AJUSTE incompatibles'; 
    'FINSI'; 
    'SI' ('EXISTE' PRECED 'CRITERE_COHERENCE') ; 
      WTAB.'CRITERE_COHERENCE'=PRECED.'CRITERE_COHERENCE' ; 
    'SINO' ; 
      'SI' ('EXISTE' PRECED 'PRECISION') ; 
        WTAB.'CRITERE_COHERENCE' = PRECED.'PRECISION' ; 
      'SINO' ; 
        WTAB.'CRITERE_COHERENCE' = WTAB.'PRECISION' ; 
      'FINS' ; 
    'FINSI' ; 
    'SI' ('EXISTE' PRECED 'PROCEDURE_CONV') ; 
       WTAB.'PROCEDURE_CONV'=PRECED.'PROCEDURE_CONV' ; 
    'FINSI' ; 
    'SI' ('EXISTE' PRECED 'NB_BOTH'); 
      WTAB.'BOU_METH'=PRECED.'NB_BOTH'; 
    'SINON'; 
      WTAB.'BOU_METH'=10; 
    'FINSI'; 
 'FINSI'; 
   
 *---- Existe-t-il une procedure de reactualisation de 
 *---- donnees materiaux 
 'SI' ('EXISTE' PRECED 'PROCEDURE_REEV_MEC'); 
     WTAB.'PROCEDURE_REEV_MEC'=PRECED.'PROCEDURE_REEV_MEC' ; 
 'FINSI' ; 
 'SI' ('EXISTE' PRECED 'PROCEDURE_REEV_THE'); 
     WTAB.'PROCEDURE_REEV_THE' =PRECED.'PROCEDURE_REEV_THE' ; 
 'FINSI' ; 
   
 *-------  Initialisation du nombre maximum de sous-pas autorisees ------ 
 'SI' ( 'EXISTE' PRECED 'MAXSOUSPAS'); 
    WTAB.'MAXSOUSPAS' = PRECED.'MAXSOUSPAS' ; 
 'FINSI'; 
   
 *-------  Initialisation du nombre maximum d'iterations autorisees ---- 
 'SI' ( 'EXISTE' PRECED 'MAXITERATION') ; 
    WTAB.'MAXITERATION' = PRECED.'MAXITERATION'; 
   
 'SINON'; 
    'SI' ((WTAB.'AUTOMATIQUE') 'OU' (WTAB.'PAS_AJUSTE')) ; 
       WTAB.'MAXITERATION' = 250; 
    'FINSI'; 
 'FINSI'; 
   
 *----------  initialisation nombre de sous-increment 
 'SI' ('EXIS' PRECED 'SOUS-INCREMENT' ); 
       WTAB.'SOUS-INCREMENT'=PRECED.'SOUS-INCREMENT'; 
 'FINSI'; 
   
 *----------------------blocages mecaniques ------------------- 
 'SI' ('EXIS' PRECED 'BLOCAGES_MECANIQUES'); 
     WTAB.'BLOCAGES_MECANIQUES'= PRECED.'BLOCAGES_MECANIQUES'; 
 'SINON'; 
     WTAB.'BLOCAGES_MECANIQUES'= 'VIDE' 'RIGIDITE'/'RIGIDITE'; 
 'FINSI'; 
   
 *---------------------- definit on la reactualisation de la matrice 
 'SI' ('EXIS' PRECED 'REAC_GRANDS'); 
   'SI' ('EGA' ('TYPE' PRECED . 'REAC_GRANDS') 'FLOTTANT') ; 
      WTAB.'REAC_GRANDS' = PRECED.'REAC_GRANDS'; 
   'FINSI'; 
 'FINSI'; 
   
 *--- y-a-t-il liste des temps ou on doit garder : les resultats ? 
 * --   les sauvegardes les fantomiser 
 *-------------- Par default on les sauve tous -------------------- 
   
 'SI' ( 'EXISTE' PRECED 'TEMPS_SAUVES' ); 
    WTAB.'IPRESU'=PRECED.'TEMPS_SAUVES'; 
 'SINON'; 
    WTAB.'IPRESU'= WTAB.'TEMPS_CALCULES'; 
 'FINSI'; 
 WTAB.'IPTIME'= WTAB.'TEMPS_CALCULES'; 
 'SI' ( 'EXISTE' PRECED 'TEMPS_SAUVEGARDES'); 
    WTAB.'ISAUVEGL'=VRAI; WTAB.'ISAUVEGA'=PRECED.'TEMPS_SAUVEGARDES'; 
 'FINSI'; 
 'SI' ( 'EXISTE' PRECED 'ECONOMIQUE'); 
     WTAB.'LECONOMI'=PRECED. 'ECONOMIQUE'; 
 'FINSI'; 
   
 'SI' ( 'EXIS' PRECED 'MES_SAUVEGARDES'); 
     TABSAUV = PRECED .'MES_SAUVEGARDES'; 
     WTAB.'TABSAUV' = TABSAUV ; 
    'SI' ('NON' ( 'EXIS' TABSAUV 'DEFIN')); 
       WTAB.'TABSAUV'.'DEFIN' = FAUX; 
    'FINSI'; 
    'SI' ('NON' ( 'EXIS' TABSAUV 'DEFTO')); 
       WTAB.'TABSAUV'.'DEFTO' = FAUX; 
    'FINSI'; 
 'SINON'; 
     WTAB.'TABSAUV'='TABL' ; 
     WTAB.'TABSAUV'.'DEFIN' = FAUX; 
     WTAB.'TABSAUV'.'DEFTO' = FAUX; 
 'FINSI'; 
 'SI' ('EXIS' PRECED 'DEFTO'); 
    'MESS' 'defto positionne'; 
     WTAB.'TABSAUV'.'DEFTO' = PRECED.'DEFTO'; 
 'FINSI'; 
   
 LOGERR1='DANS' 'QUEL' wtab.'IPRESU' wtab.'IPTIME'; 
 LOGERR2=VRAI; 
 'SI' WTAB.'ISAUVEGL'; 
    LOGERR2= 'DANS' 'QUEL' WTAB.'ISAUVEGA' wtab.'IPTIME'; 
 'FINSI'; 
 'SI' ('NON' ( LOGERR1 'ET' LOGERR2)); 
   'ERRE' 1013; 
 'FINSI'; 
   
 *                                                                      * 
 * Precision demandee par l'utilisateur : 
 'SI' ('EXISTE' PRECED 'PRECISION') ; 
   WTAB.'PRECISION' = PRECED.'PRECISION' ; 
 'FINS' ; 
 *                                                                      * 
 *--------  Existe-t-il des procedure utilisateur perso? 
 'SI' ('EXISTE' PRECED 'PROCEDURE_PERSO1'); 
    WTAB.'PROCEDURE_PERSO1'=PRECED.'PROCEDURE_PERSO1'; 
 'FINSI'; 
 'SI' ('EXISTE' PRECED 'PROCEDURE_PERSO2'); 
    WTAB.'PROCEDURE_PERSO2'=PRECED.'PROCEDURE_PERSO2'; 
 'FINSI'; 
   
   
   
 ************************************************************************ 
 *--Verifications et initialisations supplementaires pour la THERMIQUE--* 
 ************************************************************************ 
 'SI' WTAB.'FOR_THER' ; 
   'SI'  WTAB.'RAYO' ; 
     'SI' ('NON' ('EXISTE' (PRECED.'CARACTERISTIQUES') 'EMIS')); 
        'ERREUR' ' Il manque la donnee des facteurs d emissivite'; 
     'FINSI'; 
     'SI'('EXISTE' PRECED 'CTE_STEFAN_BOLTZMANN') ; 
        WTAB.'CTE_STEFAN_BOLTZMANN'=PRECED.'CTE_STEFAN_BOLTZMANN'; 
       'SAUT' 1 'LIGN' ; 
       'MESS' 'ATTENTION ! Constante de Stefan-Boltzmann en unites SI'; 
       'MESS' '            soit ' (WTAB . 'CTE_STEFAN_BOLTZMANN') ; 
     'FINSI' ; 
   'FINSI'; 
   
   'SI' ('EXIS'  PRECED  'RELAXATION_THETA' ); 
        WTAB.'RELAXATION_THETA'=PRECED.'RELAXATION_THETA' ; 
   'FINSI'; 
   'SI' ('EXIS'  PRECED  'RELAXATION_DUPONT'); 
       WTAB.'RELAXATION_DUPONT'=  PRECED . 'RELAXATION_DUPONT' ; 
   'FINSI'; 
   
   
   'SI' ( 'EXISTE' PRECED 'THERMIQUE_AUGMENTEE'); 
      WTAB.'THERAUGM' =VRAI; 
      WTAB.'THERMIQUE_AUGMENTEE'=PRECED.'THERMIQUE_AUGMENTEE'; 
      RR= PRECED.'THERMIQUE_AUGMENTEE'; 
      MNOMU = ('EXTR' RR 'MAILLAGE' 'NOMU') 'NBNO'; 
      MAVMU = ('EXTR' RR 'MAILLAGE'       ) 'NBNO'; 
     'SI' ( MNOMU 'NEG' MAVMU) ; 
         'ERREUR' 'Il ne faut pas de multiplicateur dans THERMIQUE_AUGMENTEE'; 
     'FINSI'; 
   'FINSI'; 
 'FINSI'; 
   
   
 ************************************************************************ 
 *--Verifications et initialisations supplementaires pour la DIFFUSION--* 
 ************************************************************************ 
 'SI' WTAB.'FOR_DIFF' ; 
   'SI' ('EXIS' PRECED 'RELAXATION_THETA' ); 
      WTAB.'RELAXATION_THETA'=PRECED.'RELAXATION_THETA' ; 
   'FINSI'; 
   'SI' ('EXIS'  PRECED  'RELAXATION_DUPONT'); 
       WTAB.'RELAXATION_DUPONT'=  PRECED . 'RELAXATION_DUPONT' ; 
   'FINSI'; 
   'SI' ( 'EXISTE' PRECED 'DIFFUSION_AUGMENTEE'); 
       WTAB.'DIFFAUGM' =VRAI; 
       WTAB.'DIFFUSION_AUGMENTEE'=PRECED.'DIFFUSION_AUGMENTEE'; 
       RR= PRECED.'DIFFUSION_AUGMENTEE'; 
       MNOMU = ('EXTR' RR 'MAILLAGE' 'NOMU') 'NBNO'; 
       MAVMU = ('EXTR' RR 'MAILLAGE'       ) 'NBNO'; 
       'SI' ( MNOMU 'NEG' MAVMU) ; 
           'ERREUR' 
        'Il ne faut pas de multiplicateur dans DIFFUSION_AUGMENTEE'; 
       'FINSI'; 
   'FINSI'; 
 'FINSI'; 
   
   
   
 ************************************************************************ 
 *--Verifications et initialisations supplementaires pour la MECANIQUE--* 
 ************************************************************************ 
 'SI' WTAB.'FOR_MECA' ; 
 *--------------- Initialisation des differentes precisions ------------ 
    'SI' ('EXISTE' PRECED 'PRECISION') ; 
       WTAB.'PRECFLEX'  = PRECED.'PRECISION' ; 
    'FINSI'; 
    'SI' ('EXISTE' PRECED 'PRECFLEX') ; 
       WTAB.'PRECFLEX' = PRECED.'PRECFLEX'; 
    'FINSI'; 
    'SI' ('EXISTE' PRECED 'PRECDECHARGE') ; 
       WTAB.'PRECDECHARGE' = PRECED.'PRECDECHARGE' ; 
    'FINSI'; 
 *-------------- y-a-t-il iteration ktangent ? ----------- 
   
    'SI' (  'EXISTE' PRECED 'K_TANGENT'); 
       WTAB.'K_TANGENT' = PRECED.'K_TANGENT'; 
    'FINSI'; 
    'SI' ('EXISTE' PRECED 'K_TANGENT_PERT') ; 
       WTAB.'K_TANGENT_PERT' = PRECED.'K_TANGENT_PERT' ; 
       'SI' WTAB.'K_TANGENT_PERT' ; 
          WTAB.'K_TANGENT' = VRAI ; 
       'FINSI' ; 
    'FINSI' ; 
    'SI' ('EXISTE' PRECED 'K_TANG_PERT_C1') ; 
       WTAB.'K_TANG_PERT_C1' = PRECED.'K_TANG_PERT_C1' ; 
    'FINSI' ; 
    'SI' ('EXISTE' PRECED 'K_TANG_PERT_C2') ; 
       WTAB.'K_TANG_PERT_C2' = PRECED.'K_TANG_PERT_C2' ; 
    'FINSI' ; 
 *  Par defaut, C2 = C1/100 (C1 donne ou par defaut 1.D-3) 
    'SI' ('EGA' WTAB.'K_TANG_PERT_C2' 'INCONNU') ; 
       WTAB.'K_TANG_PERT_C2' = WTAB.'K_TANG_PERT_C1' / 1.D+02 ; 
    'FINSI' ; 
 * Matrice tangente a utiliser pour iteration 0 dans UNPAS 
 * Par defaut, matrice tangente precedemment calculee si existe 
    'SI' ('EXISTE' PRECED 'K_TANGENT_ITER0') ; 
       WTAB.'K_TANGENT_ITER0' = PRECED.'K_TANGENT_ITER0' ; 
    'FINSI' ; 
 * Utilisation matrice tangente symetrisee 
    'SI' ('EXISTE' PRECED 'K_TANGENT_SYME') ; 
       WTAB.'K_TANGENT_SYME' = PRECED.'K_TANGENT_SYME' ; 
    'FINSI' ; 
    'SI' (  'EXISTE' PRECED 'NITER_KTANGENT'); 
       WTAB.'NITER_KTANGENT' =PRECED.'NITER_KTANGENT' ; 
    'FINSI'; 
 *-------------y-a-t-il du substepping?----------- 
    'SI' (  'EXISTE' PRECED 'SUBSTEPPING'); 
       WTAB.'SUBSTEPPING'=PRECED.'SUBSTEPPING' ; 
    'FINSI'; 
    'SI' (  'EXISTE' PRECED 'PRECISINTER'); 
       WTAB.'PRECISINTER' = PRECED.'PRECISINTER'; 
    'FINSI'; 
    'SI' ( 'EXISTE' PRECED 'NITERINTER_MAX'); 
       WTAB.'NITERINTER_MAX' =PRECED.'NITERINTER_MAX'; 
    'FINSI'; 
    'SI' ( 'EXISTE' PRECED  'NMAXSUBSTEPS'); 
       WTAB.'NMAXSUBSTEPS'=PRECED.'NMAXSUBSTEPS'; 
    'FINSI'; 
 *------------- quelle est l'hypothese de calcul des deformations ? 
    'SI' ( 'EXISTE' PRECED 'HYPOTHESE_DEFORMATIONS' ); 
       HYPDEF = MOT PRECED.'HYPOTHESE_DEFORMATIONS'; 
       'SI' (('EGA' HYPDEF ('MOT' 'LINEAIRE'))  'OU' ('EGA' HYPDEF ('MOT' 'QUADRATIQUE')) 'OU' 
             ('EGA' HYPDEF ('MOT' 'TRUESDELL')) 'OU' ('EGA' HYPDEF ('MOT' 'JAUMANN'))     'OU' 
             ('EGA' HYPDEF ('MOT' 'UTILISATEUR'))); 
         WTAB.'HYPOTHESE_DEFORMATIONS'='MOT' HYPDEF; 
       'SINON'; 
         'MESS' 'Les valeurs permises pour HYPOTHESE_DEFORMATIONS sont :'; 
         'MESS' 'LINEAIRE, QUADRATIQUE, TRUESDELL, JAUMANN, UTILISATEUR'; 
         'ERRE' 308; 
       'FINSI'; 
    'FINSI'; 
 *------------- y-a-t-il du grand deplacement ? 
    'SI' ( 'EXISTE' PRECED 'GRANDS_DEPLACEMENTS' ); 
       'SI' (WTAB.'CONTACT' 'ET' ('NON' PRECED.'GRANDS_DEPLACEMENTS')); 
         'MESS' 'Un calcul avec un modele de CONTACT doit necessairement' 
         'MESS' 'etre realise en GRANDS_DEPLACEMENTS !'; 
         'MESS' 'Arret de pasapas'; 
         'ERRE' 21; 
       'FINSI'; 
       WTAB.'GRANDS_DEPLACEMENTS' = PRECED.'GRANDS_DEPLACEMENTS'; 
    'FINSI'; 
 *------------- quelques reglages forces en grands deplacements 
    'SI' ( WTAB.'GRANDS_DEPLACEMENTS' ); 
 *    par defaut, on active K_SIGMA en grands deplacements 
      WTAB.'K_SIGMA'=VRAI; 
 *  PV Quel interet d'avoir les deformations? 
 **   par defaut, on sauvegarde des def. totales en grands deplacements 
 **   'SI' ('NON' ('EXIS' PRECED 'MES_SAUVEGARDES')); 
 **     WTAB.'TABSAUV'.'DEFTO'= VRAI; 
 **   'FINS'; 
 *    par defaut, on calcule avec une deformation quadratique en grands deplacements 
 *    mais on laisse faire l'utilisateur s'il souhaite autrement 
      'SI' ('NON' ('EXIS' PRECED 'HYPOTHESE_DEFORMATIONS')); 
        WTAB.'HYPOTHESE_DEFORMATIONS'='MOT' 'QUADRATIQUE'; 
      'FINSI'; 
    'FINSI'; 
 * ---------- y-a-t-il une demande sur K_SIGMA ? 
    'SI' (  'EXISTE' PRECED 'K_SIGMA'); 
       WTAB.'K_SIGMA' = PRECED.'K_SIGMA'; 
    'FINSI'; 
 * ---------- y-a-t-il une demande sur LAGRANGIEN ? 
    'SI' (  'EXISTE' PRECED 'LAGRANGIEN'); 
      'SI' ('EGA' preced.'LAGRANGIEN' 'TOTAL'); 
       WTAB.'LAG_TOT' = 1; 
      'SINON'; 
        'SI' ('EGA' preced.'LAGRANGIEN' 'FIN_PAS'); 
          WTAB.'LAG_TOT' = 2; 
        'SINON'; 
          'SI' (('EGA' preced.'LAGRANGIEN' 'REACTUALISE') 'OU' 
                ('EGA' preced.'LAGRANGIEN' 'MI_PAS')); 
           WTAB.'LAG_TOT' = 3; 
          'SINON'; 
            'ERRE' 'Seules les valeurs TOTAL, REACTUALISE (a MI_PAS) et FIN_PAS sont permises'; 
          'FINSI'; 
        'FINSI'; 
      'FINSI'; 
    'FINSI'; 
 *----------y-a-t-il demande de la MAN? 
    'SI' ( 'EXISTE' PRECED 'MAN' ); 
       WTAB.'MAN'= PRECED.'MAN'; 
    'SINON'; 
      WTAB.'MAN'=FAUX; 
    'FINSI'; 
   
 *  MOdele TOTal si FOR_MECA : 
    MO_TOT = WTAB.'MO_TOT' ; 
 *--------- initialisation des comportements d'apres le modele 
    'SI' ('EXISTE' MO_TOT 'MATE' 'PLASTIQUE'); 
       WTAB.'PLASTIQUE'      = VRAI; 
       WTAB.'IPLAVI'         = VRAI; 
    'FINSI'; 
    'SI' ('EXISTE' MO_TOT 'MATE' 'PLASTIQUE_ENDOM'); 
       WTAB.'PLASTIQUE'      = VRAI; 
       WTAB.'IPLAVI'         = VRAI; 
       WTAB.'ENDOMMAGEMENT'  = VRAI; 
    'FINSI'; 
    'SI' (('EXISTE' MO_TOT 'MATE' 'VISCOPLASTIQUE') 'OU' 
          ('EXISTE' MO_TOT 'MATE' 'FLUAGE'        )); 
       WTAB.'VISCOPLASTIQUE' = VRAI; 
       WTAB.'IPLAVI'         = VRAI; 
    'FINSI'; 
    'SI' ('EXISTE' MO_TOT 'MATE' 'VISCODOMMAGE'); 
       WTAB.'VISCODOMMAGE'   = VRAI; 
       WTAB.'IPLAVI'         = VRAI; 
    'FINSI'; 
    'SI' (('EXISTE' MO_TOT 'MATE' 'ENDOMMAGEMENT') 'OU' 
         ('EXISTE' MO_TOT 'MATE' 'ENDOMMAGEABLE')); 
       WTAB.'ENDOMMAGEMENT'  = VRAI; 
       WTAB.'IPLAVI'         = VRAI; 
    'FINSI'; 
    NOLIUTIL = faux ; 
    'SI' ('EXISTE' MO_TOT 'MATE' 'NON_LINEAIRE') ; 
       WTAB.'NON_LINEAIRE'   = VRAI; 
       WTAB.'IPLAVI'         = VRAI; 
       NOLIUTIL = 'EXISTE' MO_TOT 'MATE' 'UTILISATEUR' ; 
    'FINSI'; 
   'SI' NOLIUTIL; 
     WTAB.'DFGRAD' = 'MOT' 'DFGRAD' ; 
   'FINSI'; 
    'SI' ('EXISTE' MO_TOT 'MATE' 'VISCO_EXTERNE') ; 
       WTAB.'VISCO_EXTERNE'  = VRAI; 
       WTAB.'IPLAVI'         = VRAI; 
    'FINSI'; 
   'SI' ('EXISTE' MO_TOT 'MATE' 'CERAMIQUE'); 
       WTAB.'CERAMIQUE'      = VRAI; 
       WTAB.'IPLAVI'         = VRAI; 
    'FINSI'; 
    'SI' (('EXISTE' MO_TOT 'MATE' 'MODAL') 'OU' 
              ('EXISTE' MO_TOT 'MATE' 'STATIQUE' )); 
       WTAB.'MODAL'          = VRAI; 
       WTAB.'IPLAVI'         = VRAI; 
   'FINSI'; 
    'SI' ('EXISTE' MO_TOT 'MATE' 'IMPEDANCE'); 
       WTAB.'IMPEDANCE'      = VRAI; 
       WTAB.'IPLAVI'         = VRAI; 
   'FINSI'; 
   
    MAI_TOT            = 'EXTR' MO_TOT 'MAIL'       ; 
    WTAB.'LDEVA'       = 'EXTR' WTAB.'MA_TOT' 'DEVA'; 
    WTAB.'LPAR0'       = 'EXTR' MO_TOT 'PARA'       ; 
   'SI' ('NEG' 0 ('DIME'  WTAB.'LPAR0'))     ; 
      WTAB.'PARA_EXTE'=VRAI; 
   'FINSI'; 
   
 *--------------y-a-t-il une formulation feFP 
    'SI' (  'EXISTE' PRECED 'FEFP_FORMULATION'  ); 
       WTAB.'FEFP_FORMULATION' = PRECED.'FEFP_FORMULATION'; 
    'FINSI'; 
    'SI' WTAB.'FEFP_FORMULATION'; 
       'MESS' ' *** FORMULACION FeFp ***' ; 
       WTAB.'GRANDS_DEPLACEMENTS'  = FAUX ; 
       WTAB.'K_SIGMA'              = VRAI ; 
       WTAB.'K_TANGENT'            = VRAI ; 
       WTAB.'SUBSTEPPING'          = FAUX ; 
    'FINSI'; 
    'SI' ( 'EXISTE' PRECED 'UPDATE_LAGRANGIAN'  ); 
       WTAB.'UPDATE_LAGRANGIAN' = PRECED.'UPDATE_LAGRANGIAN' ; 
    'FINSI'; 
    'SI' WTAB.'UPDATE_LAGRANGIAN'; 
       'MESS' ' *** UPDATE LAGRANGIAN ***' ; 
    'FINSI'; 
 *--------- y-a-t-il un sauver automatique des resultats ? --------- 
    'SI' ( 'EXISTE'  PRECED 'AUTORESU'); 
       WTAB.'NAURES' = PRECED . 'AUTORESU'; 
    'FINSI'; 
 *---------- en cas de pas automatique ? 
    'SI'  WTAB . 'AUTOMATIQUE' ; 
        'SI' (  'EXISTE' PRECED 'AUTOCRIT'); 
            WTAB.'AUTOCRIT'= PRECED.'AUTOCRIT'; 
        'FINSI'; 
        'SI' ( 'EXISTE' PRECED 'AUTOPAS'); 
            WTAB.'AUTOPAS'= PRECED.'AUTOPAS'; 
        'FINSI'; 
        WTAB.'DELTAITER'=WTAB.'MAXITERATION'; 
     'FINSI'; 
 *------ y-a-t-il un nom de variable interne specifique ? 
    'SI' (  'EXISTE' PRECED 'MOVA'); 
       WTAB.'MOVA' =PRECED.'MOVA'; 
    'SINON'; 
     'SI'( WTAB.'VISCO_EXTERNE'  'OU' NOLIUTIL); 
          WTAB.MOVA = 'MOT' 'RIEN'; 
     'FINSI'; 
      'SI' ('NON' ('EXISTE' ('EXTR' WTAB.'MODELE' 'VARI') 'EPSE')); 
          WTAB.'MOVA' = 'MOT' 'RIEN'; 
      'FINSI'  ; 
   
    'FINSI'; 
 * --------------------a-t-on preciser l'oredre de la MAN? 
   'SI' ( 'EXISTE' PRECED 'ORDRE'); 
        WTAB.'ORDRE'=PRECED.'ORDRE'; 
    'FINSI'; 
 *---------- y-a-t-il des elements de rigidite constante ? -------- 
    'SI' ( 'EXISTE' PRECED 'RIGIDITE_CONSTANTE'); 
        WTAB.'RAIDCONST' =VRAI; 
        WTAB.'RIGIDITE_CONSTANTE'=PRECED.'RIGIDITE_CONSTANTE'; 
        RR= PRECED.'RIGIDITE_CONSTANTE'; 
        MNOMU = ('EXTR' RR 'MAILLAGE' 'NOMU') 'NBNO'; 
        MAVMU = ('EXTR' RR 'MAILLAGE' ) 'NBNO'; 
        'SI' ( MNOMU 'NEG' MAVMU) ; 
            'ERREUR' 
         'Il ne faut pas de multiplicateur dans RIGIDITE_CONSTANTE'; 
        'FINSI'; 
    'FINSI'; 
 *---------- y-a-t-il des elements de rigidite augmentee ? -------- 
    'SI' ( 'EXISTE' PRECED 'RIGIDITE_AUGMENTEE'); 
        WTAB.'RAIDAUGM' =VRAI; 
        WTAB.'RIGIDITE_AUGMENTEE'=PRECED.'RIGIDITE_AUGMENTEE'; 
        RR= PRECED.'RIGIDITE_AUGMENTEE'; 
        MNOMU = ('EXTR' RR 'MAILLAGE' 'NOMU') 'NBNO'; 
        MAVMU = ('EXTR' RR 'MAILLAGE' ) 'NBNO'; 
        'SI' ( MNOMU 'NEG' MAVMU) ; 
            'ERREUR' 
         'Il ne faut pas de multiplicateur dans RIGIDITE_AUGMENTEE'; 
        'FINSI'; 
    'SINON'; 
      'SI' ('EXISTE' PRECED 'AUGMENTATION_AUTOMATIQUE'); 
         WTAB.'RIGIDITE_AUGMENTEE'='MASSE' WTAB.'MODELE' WTAB.'CARACTERISTIQUES'; 
      'FINSI'; 
    'FINSI'; 
   
    'SI' ( 'EXISTE' PRECED 'AUGMENTATION_AUTOMATIQUE'); 
     'SI' PRECED.'AUGMENTATION_AUTOMATIQUE'; 
        WTAB.'AUTOAUGM'  = VRAI; 
        WTAB.'STABILITE' = VRAI ; 
 ***  'SI' ('NON' WTAB.'RAIDAUGM'); 
 ***    'ERREUR' 'il faut donner la matrice d augmentation dans RIGIDITE_AUGMENTEE'; 
 ***  'FINSI'; 
     'FINSI'; 
    'FINSI'; 
 *---------- y-a-t-il des elements de masse constante ? --------- 
    'SI' ( 'EXISTE' PRECED 'MASSE_CONSTANTE'); 
        WTAB.'MASSE_CONSTANTE'=PRECED.'MASSE_CONSTANTE'; 
        WTAB.'MASSCONST'=VRAI; 
    'FINSI'; 
 *---------- y-a-t-il un sous_increment ? --------- 
    'SI' ( 'EXISTE' PRECED 'SOUS_INCREMENT'); 
      LOGERR = FAUX ; 
      'SI' ('EXIS' WTAB 'DYNAMIQUE') ; 
        'SI' WTAB.'DYNAMIQUE' ; 
        WTAB.'SOUS_INCREMENT'=PRECED.'SOUS_INCREMENT'; 
        'SINON' ; 
          LOGERR = VRAI ; 
        'FINSI' ; 
      'SINON' ; 
        LOGERR = VRAI ; 
      'FINSI' ; 
      'SI' LOGERR ; 
        'MESS' ' Option SOUS_INCREMENT utilisable QUE en DYNAMIQUE '; 
        'MESS' ' Arret de Cast3M'; 
        'ERREUR' 5 ; 
      'FINSI' ; 
    'FINSI'; 
   
 *------------------- Cas du nonlocal : 
 *   Si Non-Local SB : 
    'SI' ('EGA' WTAB.'NON_LOCAL' 'SB') ; 
        MOD_SB = WTAB.'NLOC_MODL' ; 
        CHM_1 = 'MANU' 'CHML' MOD_SB 'LONG' 1.0 'STRESSES' 
                                     'TYPE' 'CARACTERISTIQUES' ; 
        CHM_L = 'INTG' 'ELEM' MOD_SB CHM_1 'LONG' ; 
        CHM_L = 'CHAN' 'COMP' 'LONG' CHM_L ; 
        CHM_L = 'CHAN' 'STRESSES' MOD_SB CHM_L ; 
        TAIL1 = CHM_L ** (1. / ('VALE' 'DIME')) ; 
        FTCH  = 'EXCO' WTAB.'MA_TOT' 'SBFT' 'SBFT' ; 
        FTCH  = 'CHAN' 'STRESSES' MOD_SB FTCH ; 
        MALVIA = TAIL1 '+' FTCH ; 
        WTAB.'NLOC_SB_REGU' = 'CHAN' MALVIA 
                            'TYPE' 'VARIABLES INTERNES' ; 
    'FINSI' ; 
 * 
    'SI' WTAB.'NLOC' ; 
      'SI' ( 'EXISTE'  PRECED 'CONN' ); 
         'MESS' 'On garde les connectivites dans TAB CONN'; 
          WTAB.'CONN'=PRECED . 'CONN' ; 
      'SINON'; 
         'MESS' 'Calcul des connectivites en mode normal.'; 
          WTAB.'CONN'='CONN' WTAB.'NLOC_MODL' 
             (REDU WTAB.'MA_TOT' WTAB.'NLOC_MODL') 'NORMAL' ; 
      'FINSI' ; 
    'FINSI' ; 
   
 *------Y-a-t-il des elements dont il faudra reactualiser les caracteristiques? 
    'SI' WTAB.'GRANDS_DEPLACEMENTS' ; 
        MOCA = 'MOTS' 'VECT' 'VX  ' 'VY  ' 'VZ  ' 'VXF ' 'VYF ' 'VZF ' 
                      'V1X ' 'V1Y ' 'V1Z ' 'V2X ' 'V2Y ' 'V2Z '; 
        'REPETER' BOU_CAR ('DIME' MOCA); 
           ITE2 = &BOU_CAR; 
           MOT1 = 'EXTR' MOCA ITE2; 
           'SI' ('EXIS' WTAB.'MA_TOT' MOT1); 
              WTAB.'ITCAR' = VRAI; 
              'QUITTER' BOU_CAR; 
           'FINSI'; 
        'FIN' BOU_CAR; 
 *       'SI' ITCAR; 
 *          'SI' ('NON' ('EXIS' PRECED 'CARA_ACTU')); 
 *             PRECED.'CARA_ACTU' = TABLE; 
 *          'FINSI'; 
 *       'FINSI'; 
    'FINSI'; 
 *  En grands deplacements, on se met dans la config. initiale. 
    'SI'( WTAB.'GRANDS_DEPLACEMENTS' 'OU'  WTAB.'FEFP_FORMULATION'); 
        WTAB.'RECALCUL'= VRAI ; 
    'FINSI'; 
 *- existe-t-il un chargement de flux neutronique pour le modele mistral 
 *- existe-t-il un chargement de densite de fissions pour gatt_monerie & uo2 
 *----  si oui on sort si non on le cree a zero 
 * 
    'SI' ('EXIS'  MO_TOT  'MATE' 'MISTRAL'); 
      'SI' ('NON' ('EXISTE' (WTAB.'CHARGEMENT') 'FI  ')) ; 
       FIZER='MANU' 'CHPO' MAI_TOT 1 'FI  ' 0. 'NATURE' 'DIFFUS' ; 
       WTAB.'CHARGEMENT'= WTAB.'CHARGEMENT' 'ET' ('CHAR' 'FI' FIZER 
       ('EVOL' 'MANU'  ('PROG' 0. 10.e10 ) ('PROG' 1. 1.))); 
      'FINSI'; 
    'FINSI'; 
    'SI' (('EXIS'  MO_TOT  'MATE' 'UO2') 'OU' 
          ('EXIS'  MO_TOT  'MATE' 'GATT_MONERIE') ) ; 
       'SI' ('NON' ('EXISTE' (WTAB.'CHARGEMENT') 'DFIS')) ; 
      DFISZER='MANU' 'CHPO'  MAI_TOT 1 'DFIS' 0. 'NATURE' 'DIFFUS' ; 
       WTAB.'CHARGEMENT'= WTAB.'CHARGEMENT' 'ET' ('CHAR' 'DFIS' DFISZER 
          ('EVOL' 'MANU'   ('PROG' 0. 10.e10 ) ('PROG' 1. 1.))) ; 
      'FINSI'; 
    'FINSI'; 
 'FINSI'; 
 WTAB.'CHARGEMENT_I'=WTAB.'CHARGEMENT'; 
   
   
 ****************************************************************** 
 ********** Recapitulation des options de calcul choisies ********* 
 ****************************************************************** 
 'SAUTER' 1 'LIGNE'; 
 'SI' WTAB.'FOR_MECA' ; 
    'SI' WTAB.'FOR_THER'; 
        'MESS'  'Couplage THERMIQUE-MECANIQUE'; 
    'SINON'   ; 
        'MESS'   'Calcul MECANIQUE'; 
    'FINSI'; 
    'MESS'   ' *** Hypothese calcul des deformations :' ' ' wtab.'HYPOTHESE_DEFORMATIONS' ' ***'; 
    'SI' ('NEG' WTAB.'PREDICTEUR' 'INCONNU'); 
        'MESS'   ' *** Predicteur :' ' ' wtab.'PREDICTEUR' ' ***' ; 
    'FINSI'; 
    'SI' WTAB.'K_SIGMA'; 
        'MESS'   ' *** K_SIGMA *** '; 
    'FINSI'; 
    'SI' WTAB.'GRANDS_DEPLACEMENTS'; 
      'SI' (WTAB.'LAG_TOT' 'EGA' 1) ; 
          'MESS'   ' *** Calcul en lagrangien total *** '; 
      'FINSI'; 
      'SI' (WTAB.'LAG_TOT' 'EGA' 2) ; 
          'MESS'   ' *** Calcul en lagrangien reactualise *** '; 
      'FINSI'; 
      'SI' (WTAB.'LAG_TOT' 'EGA' 3) ; 
          'MESS'   ' *** Calcul en configuration mi-pas *** '; 
      'FINSI'; 
    'FINSI'; 
    'SI' WTAB.'STABILITE'; 
        'MESS'   ' *** Controle de la stabilite *** '; 
    'FINSI'; 
    'SI' WTAB.'LINESEARCH'; 
        'MESS'   ' *** Linesearch  *** '; 
    'FINSI'; 
    'SI' (non WTAB.'INITIALISATION'); 
        'MESS'   ' *** Initialisation a partir du pas precedent' 
                 ' interdite *** '; 
    'FINSI'; 
    'SI' (WTAB.'CONVERGENCE_MONOTONE'); 
        'MESS'   ' *** Convergence monotone imposee *** '; 
    'FINSI'; 
    'SI' (WTAB.'RENORMALISATION'); 
        'MESS'   ' *** Renormalisation des iteres *** '; 
    'FINSI'; 
    'SI' WTAB.'POR1'; 
       'MESS' ' *** POREUX ***'; 
    'FINSI'; 
    'SI'(WTAB.'DYNAMIQUE'); 
       'MESSAGE' ' *** DYNAMIQUE PAS A PAS ***'; 
    'FINSI' ; 
    'SI' (WTAB.'FREQUENTIEL') ; 
       'MESSAGE' ' *** FREQUENTIEL PAS A PAS ***' ; 
    'FINSI' ; 
    'SI'(WTAB.'LIAISON_PERSISTANTE'); 
       'MESSAGE' ' *** LIAISON PERSISTANTE ***'; 
    'FINSI' ; 
    'SI'(WTAB.'CONSOLIDATION'); 
       'MESSAGE' ' *** CONSOLIDATION ***'; 
    'FINSI' ; 
    'SI'(WTAB.'PLASTIQUE'); 
      'MESSAGE' ' *** PLASTICITE ***'; 
    'FINSI'; 
    'SI'(WTAB.'VISCOPLASTIQUE'); 
       'MESSAGE' ' *** VISCO - PLASTICITE ***'; 
    'FINSI' ; 
    'SI' WTAB.'NON_LINEAIRE'; 
       'SI' NOLIUTIL; 
          'MESS' ' *** MODELE DE COMPORTEMENT NON LINEAIRE EXTERNE ***'; 
       'SINON'; 
          'MESS' ' *** ELASTICITE NON_LINEAIRE ***'; 
       'FINSI'; 
    'FINSI' ; 
    'SI' WTAB.'VISCO_EXTERNE'; 
       'MESSAGE' ' *** VISCO - PLASTICITE, MODELE EXTERNE ***'; 
    'FINSI' ; 
    'SI' WTAB.'CHAR_THE'; 
       'MESSAGE' ' *** CHARGEMENT THERMIQUE ***'; 
    'FINSI'; 
    'SI' WTAB.'CHAR_DEFI'; 
       'MESSAGE' ' *** CHARGEMENT PAR DES DEFORMATIONS ***'; 
    'FINSI'; 
    'SI' WTAB.'CHAR_PRES'; 
       'MESSAGE' ' *** CHARGEMENT PAR UNE PRESSION SUIVEUSE ***'; 
    'FINSI'; 
    'SI' WTAB.'CHAR_PILO'; 
       'MESSAGE' ' *** CHARGEMENT PAR PILOTAGE INDIRECT ***'; 
    'FINSI'; 
    'SI' WTAB.'PARA_EXTE'; 
       'MESSAGE' ' *** LE MODELE DEPEND DE PARAMETRES EXTERNES ***'; 
    'FINSI'; 
    'SI'(WTAB.'GRANDS_DEPLACEMENTS'); 
       'MESSAGE' ' *** GRANDS DEPLACEMENTS ***'; 
       'SI' ('NEG' WTAB.'HYPOTHESE_DEFORMATIONS' 'QUADRATIQUE'); 
         'MESS' '     ATTENTION : l''hypothese de deformations choisie est' ' ' PRECED.'HYPOTHESE_DEFORMATIONS'; 
         'MESS' '                 on recommande plutot l''hypothese QUADRATIQUE'; 
       'FINSI'; 
    'FINSI'; 
    'SI'(WTAB.'CONVERGENCE_FORCEE'); 
       'MESSAGE' ' *** CONVERGENCE FORCEE   ***'; 
    'FINSI'; 
    'SI'(WTAB.'ENDOMMAGEMENT'); 
       'MESSAGE' ' *** PLASTICITE + ENDOMMAGEMENT ***'; 
    'FINSI'; 
    'SI'(WTAB.'VISCODOMMAGE'); 
       'MESSAGE' ' *** VISCO-PLASTICITE + ENDOMMAGEMENT ***'; 
    'FINSI'; 
    'SI'(WTAB.'CERAMIQUE'); 
       'MESSAGE' ' ***CERAMIQUE FLUAGE  + ENDOMMAGEMENT ***'; 
       'MESSAGE' ' ***             +OTTOSEN             ***'; 
    'FINSI'; 
 *   'SI' IUO2; 
 *      'MESSAGE' ' *** VISCO-PLASTICITE + OTTOSEN ***'; 
 *   'FINSI'; 
    'SI' WTAB.'NLOC' ; 
        'MESS' ' *** EN NON-LOCAL *** ' ; 
    'FINSI'; 
    'SI' WTAB.'CONTACT'; 
       'MESS' ' *** CONTACT ***'; 
    'FINSI'; 
    'SI' (WTAB.'SOUS_INCREMENT' > 1); 
       'MESS'  ' *** SOUS_INCREMENT : ' WTAB.SOUS_INCREMENT; 
    'FINSI'; 
    'SI' WTAB.'CAFROTTE'; 
       'MESS' ' *** FROTTEMENT ***'; 
    'FINSI'; 
    'SI' WTAB.'K_TANGENT' ; 
      'SI' WTAB.'K_TANGENT_PERT' ; 
        'MESS' ' *** MATRICE TANGENTE PAR PERTURBATION ***' ; 
      'SINON' ; 
        'MESS' ' *** MATRICE TANGENTE (COHERENTE) ***' ; 
      'FINSI' ; 
      'MESS' '     MATRICE EVALUEE TOUTES LES' WTAB.'NITER_KTANGENT' 
             'ITERATIONS' ; 
      'SI' WTAB.'K_TANGENT_SYME' ; 
        'MESS' '     PARTIE SYMETRIQUE DE LA MATRICE TANGENTE UTILISEE'; 
      'FINSI' ; 
    'FINSI'; 
    'SI' WTAB.'SUBSTEPPING'; 
      'MESSAGE' ' *** SUBSTEPPING *** NUM_MAXI_SUBSTEPS = ' 
                WTAB.'NMAXSUBSTEPS' ; 
      'MESSAGE' ' *** SUBSTEPPING *** NUM_ITER_INTERNAS = ' 
                WTAB.'NITERINTER_MAX' ; 
    'FINSI'; 
 'SINON'; 
    'MESS' 'Calcul  THERMIQUE '; 
 'FINSI'; 
   
 ************************************************************************ 
 *-------------  option de parallelisation 
 ************************************************************************ 
 * Note : Il faudrait separer la thermique de la mecanique pour la //. 
 NBPART = 'VALEUR' 'ASSI' ; 
 WTAB.'NBPART' = NBPART ; 
 b_PARA = 0 ; 
 'SI' ('EGA' 'INCONNU' WTAB.'PROCESSEURS') ; 
   'SI' (NBPART > 1); 
 *  anciennes valeurs: 2000 200 
     NBELMIN = 200 ; NBELMM = 400; 
     toutmo = 'EXTR' PRECED.'MODELE' 'ZONE' ; 
     IMOD = ('DIME' toutmo) / 2 ; 
     MINELE = 1000000 ; MAXELE = 0 ; 
     'REPE' BOUCMO IMOD ; 
       BBB = 'NBEL' TOUTMO . (&BOUCMO * 2); 
       'SI' (MINELE > BBB); MINELE = BBB; 'FINSI'; 
       'SI' (MAXELE < BBB); MAXELE = BBB; 'FINSI'; 
     'FIN' BOUCMO ; 
     NBTMP = (MINELE / NBELMM) ; 
 **  mess 'nbtmp' ' ' nbtmp; 
     SI (NBTMP < NBPART); NBPART = NBTMP; 'FINSI'; 
     WTAB.'NBPART' = NBPART ; 
     'SI' ( '<EG'  NBPART 1); 
       b_PARA=0; 
     'SINON'; 
     MINELE=MINELE/NBPART ; MAXELE=MAXELE/NBPART; 
 **  mess 'minele maxele' ' ' minele ' ' maxele; 
     'SI' (MINELE > NBELMIN) ; 
       b_PARA = 2 ; 
     'SINON'; 
       'SI'( (MINELE > NBELMM) 'OU' (MAXELE > NBELMM)) ; 
 * on effectue la partition du modele utilisee seulement pour COMP 
         b_PARA = 1 ; 
       'FINSI'; 
       'FINSI'; 
     'FINSI'; 
   'FINSI'; 
 'SINON' ; 
   'SI' ('>' NBPART 1) ; 
     'SI' ('EGA' WTAB.'PROCESSEURS' 'COMPORTEMENT'); 
       b_PARA = 1 ; 
     'SINON' ; 
       'SI' ('EGA' WTAB.'PROCESSEURS' 'AUTOMATIQUE'); 
         b_PARA = 2 ; 
       'FINSI'; 
     'FINSI'; 
   'FINSI'; 
 'FINSI'; 
 'SAUTER' 1 'LIGNE'; 
 'SI' ('EGA' b_PARA 0) ; 
   WTAB.'PROCESSEURS' = 'MOT' 'MONO_PROCESSEUR' ; 
   'MESS' ' *** Pas de parallelisation ***' ; 
 'SINON' ; 
   'SI' ('EGA' b_PARA 1) ; 
     'MESS' ' *** Parallelisation du comportement sur ' nbpart ' assistants ***'; 
     WTAB.'PROCESSEURS' = 'MOT' 'COMPORTEMENT' ; 
   'SINON' ; 
     'SI' ('EGA' b_PARA 2) ; 
       WTAB.'PROCESSEURS' = 'MOT' 'AUTOMATIQUE' ; 
       'MESS' ' *** Parallelisation automatique sur ' nbpart ' assistants ***' ; 
     'SINON' ; 
       'MESS' ' *** Cas // non prevu' ; 'ERREUR' 5 ; 
     'FINSI' ; 
   'FINSI' ; 
 'FINSI' ; 
   
 'SAUTER' 1 'LIGNE'; 
 'FINPROC' ; 
 * PAS_MODL  PROCEDUR  PASCAL    20/07/01    21:15:02     10631 
 DEBPROC PAS_MODL TPASA1*'TABLE' ; 
 * 
 *----------------------- Objet de la procedure ------------------------* 
 * 
 * Initialise ou met a jour les indices relatifs aux modeles de 
 * la table WTABLE de PASAPAS, ainsi que les caracteristiques 
 * associees (MAT_...). 
 * 
 * Pour plus de details, voir la notice. 
 * 
 *--------------------------- Initialisations --------------------------* 
   
 wtab     = TPASA1.'WTABLE' ; 
   
 * MODELE en entree : 
 si (exis wtab 'MODELE') ; 
   mod0     = wtab.modele ; 
 sino ; 
   mod0     = TPASA1.modele ; 
 fins ; 
   
 * Indice modele_courant : 
 si (exis wtab 'MODELE_COURANT') ; 
   si (ega mod0 (wtab.modele_courant)) ; 
     quit PAS_MODL ; 
   sino ; 
     wtab.modele_courant = mod0 ; 
   fins ; 
 sino ; 
   wtab.modele_courant = mod0 ; 
 fins ; 
   
 *mess '*****  Appel a PAS_MODL ' ; 
   
 * Indice modele_initial : 
 si (exis wtab 'MODELE_INITIAL') ; 
   si (TPASA1.modele neg wtab.modele_initial) ; 
     wtab.modele_initial = TPASA1.modele ; 
   fins ; 
 sino ; 
   wtab.modele_initial = TPASA1.modele ; 
 fins ; 
   
 si (exis wtab 'CARACTERISTIQUES') ; 
   mat0     = wtab.caracteristiques ; 
 sino ; 
   mat0     = TPASA1.caracteristiques ; 
 fins ; 
   
   
 *------------------------ Indices pour TRANSNON -----------------------* 
   
 * Formulation THERMIQUE & THERMOHYDRIQUE : 
   
 'SI' ('EXISTE' mod0 'FORM' 'THERMIQUE'); 
   
    WTAB.'THE1'    = VRAI; 
    WTAB.'MOD_THE' = 'EXTR' mod0 'FORM' 'THERMIQUE'; 
    WTAB.'MAT_THE' = 'REDU' mat0 WTAB.'MOD_THE'; 
    WTAB.'MOD_T'   = WTAB.'MOD_THE' ; 
    WTAB.'MAT_T'   = WTAB.'MAT_THE' ; 
   
    WTAB.'THM1'    = 'EXIS' mod0 'FORM' 'THERMOHYDRIQUE' ; 
    'SI' WTAB.'THM1' ; 
      WTAB.'MOD_THM' = 'EXTR' mod0 'FORM' 'THERMOHYDRIQUE' ; 
      WTAB.'MAT_THM' = 'REDU' mat0 WTAB.'MOD_THM'; 
      WTAB.'MOD_T'   = WTAB.'MOD_T' 'ET' WTAB.'MOD_THM' ; 
      WTAB.'MAT_T'   = WTAB.'MAT_T' 'ET' WTAB.'MAT_THM' ; 
    'FINSI' ; 
    WTAB.'MOD_TOT' = WTAB.'MOD_T' ; 
    WTAB.'MAT_TOT' = WTAB.'MAT_T' ; 
   
    'SI' ( 'EXISTE' WTAB.'MOD_THE' 'MATE' 'CONVECTION'); 
        WTAB.'MOD_CON'    = 'EXTR' WTAB.'MOD_THE' 'MATE' 'CONVECTION'; 
        WTAB.'MAT_CON'    = 'REDU' WTAB.'MAT_TOT' WTAB.'MOD_CON'; 
        WTAB.'CONVECTION' = VRAI; 
    'FINSI'; 
   
    'SI' ( 'EXISTE' WTAB.'MOD_THE' 'MATE' 'RAYONNEMENT'); 
        WTAB.'RAYO'        = VRAI; 
        WTAB.'MOD_RAY'     = 'EXTR' WTAB.'MOD_THE' 'MATE' 'RAYONNEMENT'; 
        WTAB.'MAT_RAY'     = 'REDU' WTAB.'MAT_TOT' WTAB.'MOD_RAY'; 
    'FINSI'; 
   
    'SI' ( 'EXISTE' WTAB.'MOD_THE' 'MATE' 'ADVECTION'); 
        WTAB.'MOD_ADV'   = 'EXTR' WTAB.'MOD_THE' 'MATE' 'ADVECTION'; 
        WTAB.'MAT_ADV'   = 'REDU' WTAB.'MAT_TOT' WTAB.'MOD_ADV'; 
        WTAB.'ADVECTION' = VRAI; 
    'FINSI'; 
   
    'SI' ( 'EXISTE' WTAB.'MOD_THE' 'MATE' 'CONDUCTION'); 
        WTAB.'MOD_COND'   = 'EXTR' WTAB.'MOD_THE' 'MATE' 'CONDUCTION'; 
        WTAB.'MAT_COND'   = 'REDU' WTAB.'MAT_TOT' WTAB.'MOD_COND'; 
        WTAB.'CONDUCTION' = VRAI; 
     'FINSI'; 
   
    'SI' ( 'EXISTE' WTAB.'MOD_THE' 'MATE' 'SOURCE'); 
        WTAB.'MOD_SOQ'  = 'EXTR' WTAB.'MOD_THE' 'MATE' 'SOURCE'; 
        WTAB.'MAT_SOQ'  = 'REDU' WTAB.'MAT_TOT' WTAB.'MOD_SOQ'; 
        WTAB.'SOURCE_Q' = VRAI; 
     'FINSI'; 
   
 'SINON' ; 
   
   'SI' ('EXISTE' mod0 'FORM' 'THERMOHYDRIQUE'); 
   
     WTAB.'THE1' = FAUX; 
     WTAB.'THM1' = VRAI; 
     WTAB.'MOD_THM' = 'EXTR' mod0 'FORM' 'THERMOHYDRIQUE'; 
     WTAB.'MAT_THM' = 'REDU' mat0 WTAB.'MOD_THM'; 
     WTAB.'MOD_T'   = WTAB.'MOD_THM' ; 
     WTAB.'MAT_T'   = WTAB.'MAT_THM' ; 
     WTAB.'MOD_TOT' = WTAB.'MOD_T' ; 
     WTAB.'MAT_TOT' = WTAB.'MAT_T' ; 
   
     'SI' ('EXISTE' mod0 'MATE' 'CONVECTION'); 
       WTAB.'MOD_CON' = 'EXTR' mod0 'MATE' 'CONVECTION'; 
       WTAB.'MAT_CON' = 'REDU' mat0 WTAB.'MOD_CON'; 
       WTAB.'MOD_TOT' = WTAB.'MOD_TOT' 'ET' WTAB.'MOD_CON'; 
       WTAB.'MAT_TOT' = WTAB.'MAT_TOT' 'ET' WTAB.'MAT_CON'; 
       WTAB.'CONVECTION' = VRAI; 
     'FINSI'; 
   
     'SI' ('EXISTE' mod0 'MATE' 'RAYONNEMENT'); 
       WTAB.'RAYO'    = VRAI; 
       WTAB.'MOD_RAY' = 'EXTR'  mod0 'MATE' 'RAYONNEMENT'; 
       WTAB.'MAT_RAY' = 'REDU' mat0 WTAB.'MOD_RAY'; 
       WTAB.'MOD_TOT' = WTAB.'MOD_TOT' 'ET' WTAB.'MOD_RAY'; 
       WTAB.'MAT_TOT' = WTAB.'MAT_TOT' 'ET' WTAB.'MAT_RAY'; 
     'FINSI'; 
   
     'SI' ('EXISTE' mod0 'MATE' 'CONDUCTION'); 
       WTAB.'MOD_COND' = 'EXTR' mod0 'MATE' 'CONDUCTION'; 
       WTAB.'MAT_COND' = 'REDU' mat0 WTAB.'MOD_COND'; 
       WTAB.'MOD_TOT'  = WTAB.'MOD_TOT' 'ET' WTAB.'MOD_COND'; 
       WTAB.'MAT_TOT'  = WTAB.'MAT_TOT' 'ET' WTAB.'MAT_COND'; 
       WTAB.'CONVECTION' = VRAI; 
     'FINSI'; 
   
     'SI' ('EXISTE' mod0 'MATE' 'ADVECTION'); 
       WTAB.'MOD_ADV' = 'EXTR' mod0 'MATE' 'ADVECTION'; 
       WTAB.'MAT_ADV' = 'REDU' mat0 WTAB.'MOD_ADV'; 
       WTAB.'MOD_TOT' = WTAB.'MOD_TOT' 'ET' WTAB.'MOD_ADV'; 
       WTAB.'MAT_TOT' = WTAB.'MAT_TOT' 'ET' WTAB.'MAT_ADV'; 
       WTAB.'ADVECTION' = VRAI; 
     'FINSI'; 
   
     'SI' ('EXISTE' mod0 'MATE' 'SOURCE'); 
       WTAB.'MOD_SOQ' = 'EXTR' mod0 'MATE' 'SOURCE'; 
       WTAB.'MAT_SOQ' = 'REDU' mat0 WTAB.'MOD_SOQ'; 
       WTAB.'MOD_TOT' = WTAB.'MOD_TOT' 'ET' WTAB.'MOD_SOQ'; 
       WTAB.'MAT_TOT' = WTAB.'MAT_TOT' 'ET' WTAB.'MAT_SOQ'; 
       WTAB.'SOURCE_Q' = VRAI; 
     'FINSI'; 
   
   'FINSI'; 
   
 'FINSI'; 
   
 * FOR_THER = VRAI : on doit resoudre de la thermique/THM 
 WTAB.'FOR_THER' = WTAB.'THE1' 'OU' WTAB.'THM1' ; 
   
 * Formulation  DIFFUSION : 
 * On ajoute la formulation diffusion a la thermique pour TRANSNON : 
   
 'SI' ('EXIS' mod0 'FORM' 'DIFFUSION') ; 
   
    WTAB.'FOR_DIFF' = VRAI ; 
    WTAB.'MOD_DIF'  ='EXTR' mod0 'FORM' 'DIFFUSION' ; 
    WTAB.'MAT_DIF'  ='REDU' mat0 WTAB.'MOD_DIF'     ; 
   
   'SI' WTAB.'THE1' ; 
   
     WTAB.'MOD_THE' = WTAB.'MOD_THE' 'ET' WTAB.'MOD_DIF' ; 
     WTAB.'MAT_THE' = WTAB.'MAT_THE' 'ET' WTAB.'MAT_DIF' ; 
     WTAB.'MOD_TOT' = WTAB.'MOD_TOT' 'ET' WTAB.'MOD_DIF' ; 
     WTAB.'MAT_TOT' = WTAB.'MAT_TOT' 'ET' WTAB.'MAT_DIF' ; 
   
   'SINON' ; 
   
     WTAB.'MOD_THE' = WTAB.'MOD_DIF' ; 
     WTAB.'MAT_THE' = WTAB.'MAT_DIF' ; 
   
     'SI' WTAB.'THM1' ; 
        WTAB.'MOD_TOT' = WTAB.'MOD_TOT' 'ET' WTAB.'MOD_DIF' ; 
        WTAB.'MAT_TOT' = WTAB.'MAT_TOT' 'ET' WTAB.'MAT_DIF' ; 
     'SINON' ; 
        WTAB.'MOD_TOT' = WTAB.'MOD_DIF' ; 
        WTAB.'MAT_TOT' = WTAB.'MAT_DIF' ; 
     'FINSI' ; 
   
   'FINSI' ; 
   
 'FINSI' ; 
   
 * Formulation Metallurgie (T.L. en juin 2018) : 
 'SI' ('EXIS' mod0 'FORM' 'METALLURGIE'); 
   WTAB.'MOD_MET'    ='EXTR' mod0 'FORM' 'METALLURGIE'; 
   WTAB.'MAT_MET'    ='REDU' mat0  WTAB.'MOD_MET'     ; 
   WTAB.'FOR_METALLU'= VRAI ; 
   WTAB.'MOD_TOT'    = WTAB.'MOD_TOT' 'ET' WTAB.'MOD_MET' ; 
   WTAB.'MAT_TOT'    = WTAB.'MAT_TOT' 'ET' WTAB.'MAT_MET' ; 
 'FINS'; 
   
 * Formulation CHANGEMENT_PHASE (CB215821 2019) : 
 WTAB.'PHASE' = FAUX ; 
 'SI' ('EXIS' mod0 'FORM' 'CHANGEMENT_PHASE'); 
    WTAB.'PHASE'   = VRAI        ; 
    WTAB.'MOD_PHA' = 'EXTR' mod0 'FORM' 'CHANGEMENT_PHASE' ; 
    WTAB.'MAT_PHA' = 'REDU' mat0  WTAB.'MOD_PHA'           ; 
   
   'SI' ('EGA' ('TYPE' WTAB.'MOD_THE') 'MMODEL'); 
      WTAB.'MOD_THE' = WTAB.'MOD_THE' 'ET' WTAB.'MOD_PHA' ; 
      WTAB.'MAT_THE' = WTAB.'MAT_THE' 'ET' WTAB.'MAT_PHA' ; 
   'SINO'; 
      WTAB.'MOD_THE' = WTAB.'MOD_PHA' ; 
      WTAB.'MAT_THE' = WTAB.'MAT_PHA' ; 
   'FINS'; 
    WTAB.'MOD_TOT' = WTAB.'MOD_TOT' 'ET' WTAB.'MOD_PHA' ; 
    WTAB.'MAT_TOT' = WTAB.'MAT_TOT' 'ET' WTAB.'MAT_PHA' ; 
 'FINSI'; 
   
 *------------------------- Indices pour UNPAS -------------------------* 
   
 * Formulation MECANIQUE : 
   
 'SI' ('EXISTE' mod0 'FORM' 'MECANIQUE'); 
   
    WTAB.'MEC1'=VRAI; 
    WTAB.'MOD_MEC' = 'EXTR' mod0 'FORM' 'MECANIQUE'; 
    WTAB.'MAT_MEC' = 'REDU' mat0  WTAB.'MOD_MEC'; 
   
    'SI' ('EXISTE' mod0 'FORM' 'MELANGE'); 
       'SI' ('EXISTE' mod0 'MATE' 'PARALLELE'); 
          MOPAL1 = 'EXTR' mod0 'MATE' 'PARALLELE' ; 
          'SI' ('EXISTE' MOPAL1 'FORM' 'MECANIQUE'); 
             MAPAL1 = 'REDU' 'STRI' mat0 MOPAL1 ; 
             WTAB.'MOD_MEC' = MOPAL1 'ET' WTAB.'MOD_MEC' ; 
             WTAB.'MAT_MEC' = MAPAL1 'ET' WTAB.'MAT_MEC' ; 
          'FINSI' ; 
       'FINSI' ; 
    'FINSI'; 
   
 'FINSI'; 
   
 * Formulation CONTACT : 
 'SI' ('EXIS' mod0 'FORM' 'CONTACT' ) ; 
      WTAB.'CONTACT' = VRAI ; 
      WTAB.'MODCONTA' = 'EXTR' mod0  'FORM' 'CONTACT'; 
      MATCONTA = 'REDU' mat0 WTAB.'MODCONTA' ; 
      NBCOMP = 'EXTR' MATCONTA 'COMP' ; 
      'SI' ('NEG' ('DIME' NBCOMP) 0) ; 
        WTAB.'MATCONTA' = MATCONTA ; 
 *      A t-on la composante ADHE? 
        WTAB.'ADHERENCE' = 'EXIS' ('EXTR' MATCONTA 'COMP') 'ADHE' ; 
      'FINSI' ; 
      'SI' ( ('EXIS' WTAB.'MODCONTA' 'MATE' 'COULOMB') 'OU' 
             ('EXIS' WTAB.'MODCONTA' 'MATE' 'FROCABLE') ) ; 
        WTAB.'CAFROTTE' = VRAI ; 
      'FINSI'; 
 'FINSI'; 
   
 * Formulation POREUX : 
 'SI' ('EXISTE' mod0 'FORM' 'POREUX'); 
      WTAB.'POR1'=VRAI; 
      WTAB.'MOD_POR' = 'EXTR' mod0 'FORM' 'POREUX'; 
      WTAB.'MAT_POR' = 'REDU' mat0  WTAB.'MOD_POR'; 
 'FINSI'; 
   
 * Formulation CHARGEMENT : 
 'SI' ('EXIS' mod0 'FORM' 'CHARGEMENT') ; 
     WTAB.'MOD_CHA' = 'EXTR' mod0 'FORM' 'CHARGEMENT' ; 
     WTAB.'MAT_CHA' = 'REDU' mat0 WTAB.'MOD_CHA' ; 
     'SI' ('EXIS' WTAB.'MOD_CHA' 'MATE' 'PRESSION') ; 
       WTAB.'MOD_PRE' = 'EXTR' (WTAB.'MOD_CHA') 'COMP' 'PRESSION' ; 
 *       A t-on un MATE associe? 
       MATZ = 'REDU' mat0 WTAB.'MOD_PRE' ; 
       'SI' ('NEG' ('DIME' ('EXTR' MATZ 'COMP')) 0) ; 
         WTAB.'MAT_PRE' = MATZ ; 
       'FINSI' ; 
     'FINSI' ; 
 'FINSI' ; 
   
 * Formulation LIAISON : 
 'SI' ('EXISTE' mod0 'FORM' 'LIAISON'); 
      WTAB.'MOD_LIA' = 'EXTR' mod0 'FORM' 'LIAISON' ; 
      WTAB.'MAT_LIA' = 'REDU' mat0 WTAB.'MOD_LIA' ; 
 'FINSI' ; 
   
   
 * FOR_MECA = VRAI : on doit resoudre de la MECANIQUE 
 WTAB . 'FOR_MECA' = (WTAB.'MEC1') 'OU' (WTAB.'POR1') 'OU' 
                     ('EXIS' WTAB 'MOD_CHA') ; 
   
 'SI' (WTAB.'FOR_MECA') ; 
   
    'SI' (WTAB.'MEC1' 'ET' WTAB.'POR1') ; 
       MO_TOT = WTAB.'MOD_MEC' 'ET' WTAB.'MOD_POR'; 
    'SINON'; 
      'SI' WTAB.'MEC1'; 
         MO_TOT = WTAB.'MOD_MEC'; 
      'FINSI'; 
      'SI' WTAB.'POR1'; 
         MO_TOT = WTAB.'MOD_POR'; 
      'FINSI'; 
    'FINSI'; 
    'SI' ('EXISTE' WTAB 'MOD_LIA') ; 
       MO_TOT = MO_TOT 'ET' WTAB.'MOD_LIA'; 
    'FINSI' ; 
   
    WTAB.'MO_TOT'      = MO_TOT ; 
    WTAB.'MOD_REF'     = MO_TOT ; 
    WTAB.'MA_TOT'      = 'REDU' mat0 MO_TOT ; 
   
 *  Uniquement initialisation, sinon indice gere par UNPAS 
    'SI' ('NON' ('EXIS' WTAB 'MO_TOT_PREC')) ; 
       WTAB.'MO_TOT_PREC' = MO_TOT ; 
    'FINSI' ; 
   
 *  Non-LOCal : 
 *  On verifie que l'on a bien un seul type de formulation non locale 
    lognlmo = 'EXIS' MO_TOT 'NON_LOCAL' 'MOYE' ; 
    lognlsb = 'EXIS' MO_TOT 'NON_LOCAL' 'SB  ' ; 
    lognlhe = 'EXIS' MO_TOT 'NON_LOCAL' 'HELM' ; 
    'SI' ((lognlmo 'ET' lognlsb) 'OU' (lognlsb 'ET' lognlhe) 
                                 'OU' (lognlhe 'ET' lognlmo)) ; 
      'ERREUR' 
      'On ne peut pas avoir deux formulations non locales differentes' ; 
    'FINSI' ; 
   
 *  Cas 'MOYE' 
    'SI' lognlmo ; 
        WTAB.'NLOC' = VRAI ; 
        WTAB.'NON_LOCAL' = 'MOYE' ; 
        WTAB.'NLOC_MODL' = 'EXTR' MO_TOT 'NON_LOCAL' 'MOYE' ; 
    'FINSI' ; 
   
 *  Cas 'SB' 
    'SI' lognlsb ; 
        WTAB.'NLOC' = VRAI ; 
        WTAB.'NON_LOCAL' = 'SB' ; 
        WTAB.'NLOC_MODL' = 'EXTR' MO_TOT 'NON_LOCAL' 'SB' ; 
    'FINSI' ; 
   
 *  Cas 'HELM' 
    'SI' lognlhe ; 
        WTAB.'NLOC' = VRAI ; 
        WTAB.'NON_LOCAL' = 'HELM' ; 
        WTAB.'NLOC_MODL' = 'EXTR' MO_TOT 'NON_LOCAL' 'HELM' ; 
    'FINSI' ; 
   
 'FINSI' ; 
   
 finp TPASA1 ; 
 * PAS_INIT  PROCEDUR  FD218221  21/01/15    21:15:00     10848 
 'DEBPROC' PAS_INIT   PRECED*'TABLE'  ; 
 * cette procedure cree l'etat initial des inconnues, le met dans conti. 
 * initialise au passage les tables de sorties en mettant l'etat 
 * initial sous l'indice 0 
 * on fait complique car on veut pouvoir continuer des 
 * calculs sauvegardes avant que la table de continuation n'existe 
 WTAB = PRECED.'WTABLE'; 
   
 TABSAUV=WTAB  .'TABSAUV'; 
 'SI' ( 'EXIS' PRECED 'CONTINUATION'); 
    conti=PRECED.'CONTINUATION'; 
    inouv=faux; 
    WTAB.'TEMPS0'=conti.'TEMPS'; 
 'SINON'; 
 *  il suffit d'initialiser a zero ou de reprendre ce qui est donne 
 *  par l'utilisateur ( vitesses initiales ,temperatuires initiales etc.. 
    conti='TABL'; 
    inouv=vrai; 
    PRECED.'CONTINUATION'= CONTI; 
 'FINSI'; 
   
 *---------- initialisation du temps et table sortie temps 
 'SI' ('EXIS' PRECED TEMPS) ; 
    NSOR= ('DIME' (PRECED . 'TEMPS' )) - 1; 
    WTAB.'NSOR'=NSOR; 
   'SI' ('EXIS' conti 'TEMPS'); 
      WTAB.'TEMPS0'=conti.'TEMPS'; 
      TEMP0=WTAB.'TEMPS0'; 
   'SINON'; 
     TEMP0=PRECED.'TEMPS' . NSOR; 
     WTAB.'TEMPS0'=TEMP0; 
   'FINSI'; 
 'SINON'; 
    NSOR= 0;   PRECED.'TEMPS'='TABLE'; 
       'SI' WTAB.'FREQUENTIEL' ; 
    TEMP0 = WTAB.'TEMPS0' ; 
       'SINON' ; 
    TEMP0 = 0.D0 ; 
       'FINSI' ; 
    PRECED.'TEMPS' . 0 = TEMP0 ; 
    WTAB.'TEMPS0'=TEMP0; 
    WTAB.'NSOR'=NSOR; 
 'FINSI'; 
 conti.'TEMPS'=WTAB.'TEMPS0'; 
   
 * Cas de MODELEs passe dans un CHARGEMENT : indice MODELES 
 'SI' (WTAB.'CHAR_MODE') ; 
   'SI' ('NON' ('EXIS' PRECED 'MODELES')) ; 
      PRECED.'MODELES'     = 'TABLE' ; 
      PRECED.'MODELES' . 0 = 'TIRE' WTAB.'CHARGEMENT' 'MODE' TEMP0 ; 
 *     PRECED.'MAILLAGES'     = 'TABLE' ; 
 *     PRECED.'MAILLAGES' . 0 = 'EXTR' (PRECED.'MODELES' . 0) 'MAIL' ; 
   'FINSI' ; 
   'SI' inouv ; 
      conti.'MODELES'   = PRECED.'MODELES' . NSOR ; 
 *     conti.'MAILLAGES' = PRECED.'MAILLAGES' . NSOR ; 
   'FINSI' ; 
 'FINSI' ; 
   
 ************************************************************************ 
 *--------  pour la mecanique 
 ************************************************************************ 
 'SI' WTAB.'FOR_MECA' ; 
    MO_TOT=WTAB.'MO_TOT'; 
 *---------- initialisation du deplacement et table sortie 
   'SI' ('NON' ('EXIS' PRECED 'DEPLACEMENTS' )); 
      DDDD = 'ZERO' MO_TOT 'DEPLACEM'; 
      DEP_COUR = 'CHANGER' 'CHPO'  MO_TOT DDDD; 
      'DETRUIRE' DDDD; 
      PRECED.'DEPLACEMENTS' = 'TABLE'; 
      PRECED.'DEPLACEMENTS'. 0 = DEP_COUR; 
   'FINSI'; 
 *  WTAB.'FOR'= 'FORM' PRECED.'DEPLACEMENTS'. NSOR ; 
   'FORM' WTAB.'FOR0'; 
   'SI' inouv; 
      conti.'DEPLACEMENTS'= PRECED. 'DEPLACEMENTS' . NSOR; 
 *    conti.'GEODEB'=WTAB.'FOR';conti.'GEOFIN'=conti.'GEODEB'; 
   'FINS'; 
 *--------- initialisation des contraintes et table de sortie 
   'SI' ('NON' ('EXIS' PRECED 'CONTRAINTES')); 
       SIG_COUR = 'ZERO' MO_TOT 'CONTRAIN'; 
       PRECED.'CONTRAINTES' = 'TABLE'; 
       PRECED.'CONTRAINTES'. 0 = SIG_COUR; 
   'FINSI'; 
   'SI' inouv; 
      conti.'CONTRAINTES' = PRECED.'CONTRAINTES'.NSOR; 
   'FINS'; 
 *---------  initialisation des vitesses et table de sortie 
   'SI' (WTAB.'DYNAMIQUE' 'OU' ('EXISTE' WTAB 'MOD_LIA')); 
     'SI'  ('EXISTE' PRECED 'VITESSES')  ; 
        TABINT=INDEX (PRECED.'VITESSES'); 
        IND0=TABINT.('DIME' TABINT); 
        VIT_COUR=PRECED.'VITESSES' . IND0; 
     'SINON'; 
        DDDD = 'ZERO' MO_TOT 'DEPLACEMENTS'; 
        VIT_COUR = 'CHANGER' 'CHPO'  MO_TOT DDDD; 
        'DETRUIRE' DDDD; 
        PRECED.'VITESSES'=TABLE; 
        PRECED.'VITESSES'. 0 = VIT_COUR; 
     'FINSI'; 
     'SI' inouv; 
        conti.'VITESSES'=VIT_COUR; 
     'FINS'; 
   'FINSI'; 
   'SI' WTAB.'DYNAMIQUE'; 
     'SI'  ('EXISTE' PRECED 'ACCELERATIONS') ; 
        TABINT=INDEX (PRECED.'ACCELERATIONS') ; 
        IND0=TABINT.('DIME' TABINT); 
        ACC_COUR=PRECED.'ACCELERATIONS' . IND0; 
     'SINON'; 
        DDDD = 'ZERO' MO_TOT 'DEPLACEMENTS'; 
        ACC_COUR = 'CHANGER' 'CHPO'  MO_TOT DDDD; 
        'DETRUIRE' DDDD; 
        PRECED.'ACCELERATIONS'=TABLE; 
        PRECED.'ACCELERATIONS'. 0 = ACC_COUR; 
     'FINSI'; 
     'SI' inouv; 
        conti.'ACCELERATIONS'=ACC_COUR; 
     'FINS'; 
   'FINSI'; 
 *----------  REACTIONS  et table de sortie 
   'SI' ('NON' ('EXIS' PRECED 'REACTIONS')); 
     'SI' ('EXIS' PRECED 'BLOCAGES_MECANIQUES'); 
      REA_COUR='REAC' PRECED.'BLOCAGES_MECANIQUES' conti.'DEPLACEMENTS'; 
     'SINON' ; 
      REA_COUR = 'CHAN' 'CHPO' MO_TOT ('ZERO'  MO_TOT 'FORCES') ; 
     'FINSI' ; 
      PRECED.'REACTIONS' = TABLE; 
      PRECED.'REACTIONS' . 0 = REA_COUR; 
   'FINSI'; 
   'SI' inouv; 
      conti.'REACTIONS'=PRECED.'REACTIONS'.NSOR; 
   'FINS'; 
 *------------ variables_internes et table de sortie 
   'SI' WTAB.'IPLAVI'; 
     'SI' ('EXIS' PRECED 'VARIABLES_INTERNES' ); 
        TABINT  =INDEX (PRECED.'VARIABLES_INTERNES'); 
        IND0    =TABINT.('DIME' TABINT) ; 
        VAR_COUR=PRECED.'VARIABLES_INTERNES' . IND0; 
     'SINON'; 
        VAR_COUR='ZERO' MO_TOT 'VARINTER'; 
        PRECED.'VARIABLES_INTERNES'    = 'TABL'; 
        PRECED.'VARIABLES_INTERNES'. 0 = VAR_COUR; 
     'FINSI'; 
     'SI' inouv; 
        conti.'VARIABLES_INTERNES'=VAR_COUR; 
     'FINS'; 
   'FINSI'; 
   
 *----------  Parametre de pilotage indirect et table de sortie 
   'SI' WTAB.'CHAR_PILO'; 
     'SI' ('NON' ('EXIS' PRECED 'COEFFICIENT_DE_PILOTAGE')); 
        PRECED.'COEFFICIENT_DE_PILOTAGE' = PROG 0. ; 
     'FINSI'; 
   'FINSI' ; 
   
 *--------- initialisation des tables pour un tracking 
   'SI' ('EXIS' PRECED.'MODELE' 'MATE' 'EFEM'); 
     'SI' ('EXIS' PRECED 'TRACKING'); 
       'SI' (PRECED.'TRACKING'); 
          'SI' ('NON' ('EXIS' PRECED 'PROOTS')); 
              PRECED.'PROOTS' = 'TABLE'; 
              PRECED.'PROOTS'. 0 = 0.; 
          'FINSI'; 
 *         'SI' inouv; conti.'PROOTS' = PRECED.'PROOTS'.NSOR;'FINS'; 
          'SI' ('NON' ('EXIS' PRECED 'EROOTS')); 
              PRECED.'EROOTS' = 'TABLE'; 
              PRECED.'EROOTS'. 0 = 0.; 
          'FINSI'; 
 *         'SI' inouv; conti.'PROOTS' = PRECED.'PROOTS'.NSOR;'FINS'; 
          'SI' ('NON' ('EXIS' PRECED 'NROOTS')); 
              PRECED.'NROOTS' = 0; 
          'FINSI'; 
 *         'SI' inouv; conti.'EROOTS' = PRECED.'EROOTS'.NSOR;'FINS'; 
          'SI' ('NON' ('EXIS' PRECED 'TABISO')); 
              PRECED.'TABISO' = 'TABLE'; 
              PRECED.'TABISO'. 0 = 0.; 
          'FINSI'; 
 *         'SI' inouv; conti.'TABISO' = PRECED.'TABISO'.NSOR;'FINS'; 
          'SI' ('NON' ('EXIS' PRECED 'RESTH')); 
              PRECED.'RESTH' = 'TABLE'; 
              PRECED.'RESTH'. 0 = 0.; 
          'FINSI'; 
 *         'SI' inouv; conti.'RESTH' = PRECED.'RESTH'.NSOR;'FINS'; 
          'SI' ('NON' ('EXIS' PRECED 'ISOTEST')); 
              PRECED.'ISOTEST' = 'TABLE'; 
              PRECED.'ISOTEST'. 0 = 0.; 
          'FINSI'; 
 *         'SI' inouv; conti.'ISOTEST' = PRECED.'ISOTEST'.NSOR;'FINS'; 
          'SI' ('NON' ('EXIS' PRECED 'ISOTOT')); 
              PRECED.'ISOTOT' = 'TABLE'; 
              PRECED.'ISOTOT'. 0 = 0.; 
          'FINSI'; 
 *         'SI' inouv; conti.'ISOTOT' = PRECED.'ISOTOT'.NSOR;'FINS'; 
          'SI' ('NON' ('EXIS' PRECED 'MESH_ISO')); 
              PRECED.'MESH_ISO' = 'TABLE'; 
              PRECED.'MESH_ISO'. 0 = 0.; 
          'FINSI'; 
 *         'SI' inouv; conti.'MESH_ISO' = PRECED.'MESH_ISO'.NSOR;'FINS'; 
          'SI' ('NON' ('EXIS' PRECED 'MESH')); 
              PRECED.'MESH' = 'TABLE'; 
              PRECED.'MESH'. 0 = 0.; 
          'FINSI'; 
 *         'SI' inouv; conti.'MESH' = PRECED.'MESH'.NSOR;'FINS'; 
       'FINSI'; 
     'FINSI'; 
   'FINSI'; 
 *--------- initialisation de table pour non-local HELM 
   'SI' WTAB.'NLOC' ; 
     'SI' ('EGA' WTAB.'NON_LOCAL' 'HELM'); 
        WTAB.'HELMHOLTZ' = 'TABLE' ; 
        MOLVIA = 'EXTR' WTAB.'NLOC_MODL' 'NLOC' ; 
        NHELM = 'DIME' MOLVIA ; 
        WTAB.'HELMHOLTZ' . 'N_VARI_NL'= NHELM ; 
        GEOHELM = 'EXTR' WTAB.'NLOC_MODL' 'MAIL' ; 
        MAHELM = 'REDU' WTAB.'CARACTERISTIQUES' WTAB.'NLOC_MODL' ; 
        DDVA = 'EXTR' MAHELM 'COVA' ; 
 * 
       'REPE' BH NHELM ; 
          WTAB.'HELMHOLTZ'. &BH  = 'TABLE' ; 
          LEMO  = 'EXTR' MOLVIA &BH ; 
          WTAB.'HELMHOLTZ'. &BH. 'NOM' = LEMO ; 
         'SI' ('EXIS' DDVA LEMO) ; 
            WTAB.'HELMHOLTZ'. &BH. 'CTE' = FAUX ; 
         'SINON' ; 
            WTAB.'HELMHOLTZ'. &BH. 'CTE' = VRAI ; 
         'FINSI' ; 
          MOPRE = 'EXTR' LEMO 1 3 ; 
         'SI' ('NEG' MOPRE 'ERF') ; 
            LEMOD = 'MODE' GEOHELM 'THERMIQUE' 'ISOTROPE' ; 
         'SINON' ; 
           'SI' ( 'NEG' ('VALE' 'DIME') 3 ); 
             'ERRE' 'formulation non-locale indisponible' ; 
           'FINSI' ; 
            LEMOD = 'MODE' GEOHELM 'THERMIQUE' 'ANISOTROPE' ; 
         'FINSI' ; 
          WTAB.'HELMHOLTZ'. &BH . 'H_MODELE' = LEMOD ; 
         'SI' ('EGA' &BH 1 ) ; 
            WTAB.'HELMHOLTZ'. 'H_CAPA' ='CAPA' LEMOD ('MATE' LEMOD 'RHO' 1. 'C' 1.) ; 
         'FINSI' ; 
       'FIN' BH ; 
     'FINSI'; 
   'FINSI'; 
 *---------- deformations inelastiques et table de sortie 
   'SI' ('EXISTE' PRECED 'DEFORMATIONS_INELASTIQUES'); 
      TABINT=INDEX (PRECED.'DEFORMATIONS_INELASTIQUES'); 
      IND0=TABINT.('DIME' TABINT); 
      DEI_COUR=PRECED.'DEFORMATIONS_INELASTIQUES' . IND0; 
   'SINON'; 
      DEI_COUR = 'ZERO' MO_TOT 'DEFINELA'; 
     'SI' ('EXIS' TABSAUV  'DEFIN'); 
       'SI' TABSAUV.'DEFIN'; 
          PRECED.'DEFORMATIONS_INELASTIQUES'    ='TABLE'; 
          PRECED.'DEFORMATIONS_INELASTIQUES' . 0=DEI_COUR; 
       'FINSI'; 
     'FINSI'; 
   'FINSI'; 
   'SI' inouv; 
      conti.'DEFORMATIONS_INELASTIQUES'=DEI_COUR; 
   'FINS'; 
 *-----------  deformations  totales et table de sortie 
   'SI' ('EXISTE' PRECED 'DEFORMATIONS'); 
      TABINT=INDEX (PRECED.'DEFORMATIONS'); 
      IND0=TABINT.('DIME' TABINT); 
      DEF_COUR=PRECED.'DEFORMATIONS' . IND0; 
   'SINON'; 
      DEF_COUR = 'ZERO' MO_TOT 'DEFORMATIONS'; 
     'SI' ('EXIS' TABSAUV  'DEFTO'); 
       'SI' TABSAUV.'DEFTO'; 
          PRECED.'DEFORMATIONS'    ='TABLE'; 
          PRECED.'DEFORMATIONS' . 0=DEF_COUR; 
       'FINSI'; 
     'FINSI'; 
   'FINSI'; 
   'SI' inouv; 
      conti.'DEFORMATIONS'=DEF_COUR; 
   'FINS'; 
 *  en cas de chargement thermique initialisation de wtab.tet1 et wtab.tet2 
   'SI' WTAB.'CHAR_THE'; 
      WTAB.'TET1' = 'TIRE' WTAB.'CHARGEMENT' 'T' TEMP0; 
      WTAB.'TET2' = WTAB.'TET1'; 
   'FINSI'; 
 *  en cas de chargement de deformations initiales initialisation de defor1 et defor2 
   'SI' WTAB.'CHAR_DEFI'; 
      WTAB.'DEFOR1' = 'TIRE' WTAB.'CHARGEMENT' 'DEFI' WTAB.'TEMPS0'; 
      WTAB.'DEFOR2' =  WTAB.'DEFOR1'; 
   'FINSI'; 
 *  En presence de THERMIQUE (CHARGEMENT ou FORMULATION) initialisation de TEMPERATURE_REFERENCE 
   'SI' (WTAB.'CHAR_THE' 'OU'  WTAB.'FOR_THER') ; 
 *    On prend la temperature de reference dans le MATERIAU 
      'SI' ('EXIS' WTAB.'MA_TOT' 'TREF'); 
         TREF = 'ZERO' WTAB.'MO_TOT' 'TEMPERAT' ; 
         TSZ = 'EXTR' WTAB.'MO_TOT' 'ZONE' ; 
         ISZ = 1 ; 
         'REPE' BSZ (('DIME' TSZ) / 2) ; 
            MOSZI = TSZ . ISZ ; 
            MOTSTEMP = 'EXTR' MOSZI 'TEMP' ; 
            'REPE' BMO ('DIME' MOTSTEMP) ; 
               MOTEMPI = 'EXTR' MOTSTEMP &BMO ; 
               TREFI = 'CHAN' 'STRESSES' MOSZI ('EXCO' ('REDU' WTAB.'MA_TOT' MOSZI) 'TREF' MOTEMPI) ; 
               TREF = TREF + TREFI ; 
            'FIN' BMO ; 
            ISZ = ISZ + 2 ; 
         'FIN' BSZ ; 
         WTAB.'TEMPERATURE_REFERENCE' = 'CHAN' 'TYPE' TREF 'TEMPERATURES' ; 
      'SINO'; 
         ERREUR 77 'AVEC' ('MOT' 'TREF') ('MOT' 'de MATERIAU'); 
      'FINS'; 
      'SI' ('EGA' WTAB.'ETHER1' 'INCONNU'); 
 *       On initialise les deformations thermiques a ZERO 
         WTAB.'ETHER1' = 'ZERO' MO_TOT 'DEFORMATIONS' ; 
 *       CB215821 : Pour une reprise propre, il faudrait mettre DEFORMATION_THERMIQUE dans CONTI 
      'FINS' ; 
   'FINS'; 
 'FINS'; 
   
 ************************************************************************ 
 *-----------pour la formulation THERMIQUE 
 ************************************************************************ 
 'SI' WTAB.'FOR_THER'; 
 *---------- initialisation de la temperatuure et table de sortie 
   'SI' ('EXISTE' PRECED 'TEMPERATURES'); 
      TABINT  = INDEX (PRECED.'TEMPERATURES'); 
      IND0    = TABINT.('DIME' TABINT ); 
      TH_COUR = PRECED.'TEMPERATURES' . IND0; 
     'SI' (IND0 '>EG' 2) ; 
        WTAB.'TET0'=PRECED.'TEMPERATURES' . (IND0 - 2); 
     'FINSI'; 
   'SINON'; 
      'SI' ('EXIS' WTAB.'MAT_T' 'TINI') ; 
        DDDD = 'EXCO' WTAB.'MAT_T' 'TINI' 'T' ; 
      'SINO' ; 
        DDDD = 'ZERO' WTAB.'MOD_T' 'TEMPERAT' ; 
      'FINS' ; 
      TH_COUR = 'CHANGER' 'CHPO' WTAB.'MOD_T' DDDD; 
      PRECED.'TEMPERATURES'    = 'TABL'; 
      PRECED.'TEMPERATURES'. 0 = TH_COUR; 
   'FINSI'; 
   'SI' INOUV ; 
      CONTI.'TEMPERATURES' ='CHAN' 'ATTRIBUT' TH_COUR 'NATURE' 'DIFFUS'; 
   'FINS'; 
   
    WTAB.'TET1'   = TH_COUR; 
    WTAB.'TET2'   = TH_COUR; 
   'SI' ('NON' ('EXIS' PRECED 'REACTIONS_THERMIQUES')) ; 
     'SI' ('EXIS' PRECED 'BLOCAGES_THERMIQUES') ; 
        QTH_COUR ='REAC' PRECED.'BLOCAGES_THERMIQUES' TH_COUR ; 
     'SINON' ; 
        QTH_COUR ='CHAN' 'CHPO' WTAB.'MOD_T' ('ZERO' WTAB.'MOD_T' 'FORCES') ; 
     'FINSI' ; 
      PRECED.'REACTIONS_THERMIQUES'     ='TABL'    ; 
      PRECED.'REACTIONS_THERMIQUES' . 0 = QTH_COUR ; 
   'FINS' ; 
   'SI' inouv; 
     conti.'REACTIONS_THERMIQUES' = PRECED.'REACTIONS_THERMIQUES'.NSOR ; 
   'FINS'; 
 'FINS'; 
   
 ************************************************************************ 
 *-----------pour la formulation METALLURGIE (T.L. en juin 2018) 
 ************************************************************************ 
 'SI' WTAB.'FOR_METALLU' ; 
 *  PROPORTIONS de PHASES metallurgique 
   'SI' ('EXIS' PRECED 'PROPORTIONS_PHASES') ; 
      TAB_PROP ='INDE' (PRECED.'PROPORTIONS_PHASES');  'COMM' 'TAB_PROP est une table dan le quel on range les NOMS des indexs de la table PRECED.PROPORTIONS_PHASES'; 
      IND0     = TAB_PROP. ('DIME' TAB_PROP)        ;  'COMM' 'IND0  = le nom du dernier index de la table PRECED.PROPORTIONS_PHASES'; 
      CHMET0   = PRECED.'PROPORTIONS_PHASES'.IND0   ;  'COMM' 'CHMET0= la valeur du dernier indice de PRECED.PROPORTIONS_PHASES'; 
   'SINO' ; 
 *    Valeurs par defaut : ZERO pour toutes les phases sauf la premiere : 1.D0 
      CHMET0  ='ZERO' WTAB.'MOD_MET' 'VARINTER'; 
      LISCO   ='EXTR' WTAB.'MOD_MET' 'VARI'; 
      CMP1    ='EXCO' CHMET0 ('EXTR' LISCO 1) ('EXTR' LISCO 1); 
      CHMET0  = CHMET0 + (CMP1 + 1.D0); 
      PRECED.'PROPORTIONS_PHASES'    ='TABL' ; 
      PRECED.'PROPORTIONS_PHASES'. 0 = CHMET0; 
   'FINS' ; 
   'SI' INOUV ; 
      conti . 'PROPORTIONS_PHASES' = CHMET0 ; 
   'FINS' ; 
 'FINSI' ; 
   
   
 ************************************************************************ 
 *-----------pour la formulation DIFFUSION 
 ************************************************************************ 
 'SI' WTAB.'FOR_DIFF' ; 
   'SI' ('EXIS' PRECED 'CONCENTRATIONS') ; 
     TABIND0  = 'INDE' (PRECED.'CONCENTRATIONS') ; 
     IND0     = TABIND0 . ('DIME' TABIND0) ; 
     CHCO0    = PRECED. 'CONCENTRATIONS' . IND0 ; 
   'SINO' ; 
     CHCO0    = 'ZERO' WTAB. 'MOD_DIF' 'DEPLACEMENTS' ; 
     CHCO0    = 'CHAN' 'CHPO' WTAB. 'MOD_DIF' CHCO0   ; 
     PRECED.'CONCENTRATIONS'    = 'TABL' ; 
     PRECED.'CONCENTRATIONS'. 0 = CHCO0  ; 
   'FINS' ; 
   'SI' INOUV ; 
     CONTI . 'CONCENTRATIONS' ='CHAN' 'ATTRIBUT' CHCO0  'NATURE' 'DIFFUS'; 
   'FINS' ; 
   WTAB . 'CO1' = CHCO0 ; 
   WTAB . 'CO2' = CHCO0 ; 
   'SI' ('NON' ('EXIS' PRECED 'REACTIONS_DIFFUSIONS')) ; 
     'SI' ('EXIS' PRECED 'BLOCAGES_DIFFUSIONS') ; 
       QDI_COUR = 'REAC' PRECED.'BLOCAGES_DIFFUSIONS' CHCO0 ; 
     'SINON' ; 
       QDI_COUR = 'CHAN' 'CHPO' WTAB.'MOD_DIF' 
         ('ZERO' WTAB.'MOD_DIF' 'FORCES') ; 
     'FINSI' ; 
     PRECED.'REACTIONS_DIFFUSIONS'   = 'TABL' ; 
     PRECED.'REACTIONS_DIFFUSIONS' . 0 = QDI_COUR ; 
   'FINS' ; 
   'SI' INOUV ; 
     CONTI . 'REACTIONS_DIFFUSIONS' = 
       PRECED . 'REACTIONS_DIFFUSIONS'. NSOR ; 
   'FINS' ; 
 'FINS' ; 
   
 ************************************************************************ 
 *-----------pour la formulation CHANGEMENT_PHASE (CB215821 2019) 
 *-----------Doit etre place en dernier car peut necessiter les autres 
 *-----------champs 
 ************************************************************************ 
 'SI' WTAB.'PHASE'; 
    MO_COVA ='EXTR' WTAB.'MAT_PHA' 'COVA'; 
   'SI' (('DIME' MO_COVA) > 0); 
      CHAI1 ='CHAI' ' Le materiau du modele CHANGEMENT_PHASE ne peut pas varier'; 
     'ERRE' CHAI1 ; 
   'FINS'; 
   
   'SI' ( 'EXISTE' PRECED 'PROPORTIONS_PHASE')  ; 
      TABINT = INDEX (PRECED.'PROPORTIONS_PHASE'); 
      IND0   = TABINT.('DIME' TABINT)            ; 
      CHPHA0 ='REDU' WTAB.'MOD_PHA' PRECED.'PROPORTIONS_PHASE'.IND0 ; 
   'SINON'; 
 *    On met un etat qui a du sens physique pour la proportion de phases 
      TABPHA ='EXTR' WTAB.'MOD_PHA' 'ZONE'; 
      CHPHA0 ='VIDE' 'MCHAML'; 
     'REPE' SURi (('DIME' TABPHA) / 2); 
 *      Boucle sur les modeles CHANGEMENT_PHASE 
        MODEi  = TABPHA.((&SURi-1)*2 + 1) ; 
        MATEi  =('REDU' MODEi WTAB.'MAT_PHA' ) 'EXCO' 'PRIM'; 
        LMOPRIM='EXTR' MODEi 'DEPL'; 
        MOPRIM ='EXTR' LMOPRIM 1; 
       'SI' ('EXIS' WTAB.'CHARGEMENT' MOPRIM); 
 *        On regarde dans le CHARGEMENT si la PRIMALE existe 
          CHPRIM ='TIRE' WTAB.'CHARGEMENT' MOPRIM TEMP0; 
         'SI' ('EXIS' ('EXTR' CHPRIM 'COMP') MOPRIM); 
            CHPRIM='CHAN'  'CHAM'  CHPRIM MODEi 'NOEUD'; 
            CHPRIM= CHPRIM 'NOMC' 'PRIM'; 
            CHPHAi=('MASQ' (MATEi-CHPRIM) 'EGINFE' 0.D0) 'NOMC' 'PPHA'; 
            CHPHA0= CHPHAi 'ET' CHPHA0; 
           'ITER' SURi ; 
         'FINS'; 
       'FINS'; 
   
 *      On regarde dans les indices connus de la TABLE PRECED 
       'SI' ('EXIS' PRECED 'TEMPERATURES'); 
          CHPRIM = TH_COUR; 
         'SI' ('EXIS' ('EXTR' CHPRIM 'COMP') MOPRIM); 
            CHPRIM='CHAN'  'CHAM'  CHPRIM MODEi 'NOEUD'; 
            CHPRIM= CHPRIM 'NOMC' 'PRIM'; 
            CHPHAi=('MASQ' (MATEi-CHPRIM) 'EGINFE' 0.D0) 'NOMC' 'PPHA'; 
            CHPHA0= CHPHAi 'ET' CHPHA0; 
           'ITER' SURi ; 
         'FINS'; 
       'FINS'; 
   
       'SI' ('EXIS' PRECED 'CONCENTRATIONS'); 
          CHPRIM = CHCO0; 
         'SI' ('EXIS' ('EXTR' CHPRIM 'COMP') MOPRIM); 
            CHPRIM='CHAN'  'CHAM'  CHPRIM MODEi 'NOEUD'; 
            CHPRIM= CHPRIM 'NOMC' 'PRIM'; 
            CHPHAi=('MASQ' (MATEi-CHPRIM) 'EGINFE' 0.D0) 'NOMC' 'PPHA'; 
            CHPHA0= CHPHAi 'ET' CHPHA0; 
           'ITER' SURi ; 
         'FINS'; 
       'FINS'; 
   
 *      Si on arrive ici c'est qu'on n'a pas trouve le champ primal : on met zero 
        CHPHAi='ZERO' MODEi 'VARINTER'; 
        CHPHA0= CHPHAi 'ET' CHPHA0; 
     'FIN'  SURi; 
   
      PRECED.'PROPORTIONS_PHASE'     ='TABL' ; 
      PRECED.'PROPORTIONS_PHASE' . 0 = CHPHA0; 
   'FINSI'; 
   
   'SI' INOUV; 
      conti.'PROPORTIONS_PHASE'=CHPHA0; 
   'FINS'; 
    WTAB.'PROPPHAS' = CHPHA0               ; 
    WTAB.'BLO_PHASE'='PMAT' WTAB.'MOD_PHA' ; 
 'FINSI'; 
   
  PRECED.'ESTIMATION'='COPIER' conti; 
 'FINP'; 
 * PAS_ETAT  PROCEDUR  CB215821  20/07/29    21:16:00     10668 
 'DEBPROC' PAS_ETAT PRECED*'TABLE' TI*'FLOTTANT' MOREF/'MOT'   ; 
 ************************************************************************ 
 * Cette procedure cree un MCHAML qui contient l'ETAT au sens 
 * THERMODYNAMIQUE ‡ un instant donne (TI) 
 * 
 * MOREF : MOT optionnel pouvant prendre la valeur de 'REFERENCE' 
 *         si l'etat a calculer est l'etat de REFERENCE 
 * 
 * Partie 1 : Interpolation entre le debut du PAS (CONTINUATION) 
 *                             et la fin   du PAS (ESTIMATION  ) 
 * Partie 2 : Tire dans le CHARGEMENT 
 * on  interpole entre le dernier pas (dans la table estimation) 
 * et les dernieres valeurs convergees (dans continuation). 
 * 
 ************************************************************************ 
  WTAB = PRECED. 'WTABLE'; 
   
  CONTI = PRECED. 'CONTINUATION'; 
  ESTIM = PRECED. 'ESTIMATION'  ; 
  NCONT ='DIME' CONTI           ; 
   
  IND   ='INDE' CONTI           ; 
  TDEB  = CONTI.'TEMPS'         ; 
  TFIN  = ESTIM.'TEMPS'         ; 
  IAD   = FAUX                  ; 
  IAC   = FAUX                  ; 
   
 'SI' ( 'NEG' TFIN TDEB)                       ; 
    XPRO  = (TI  '-' TDEB) '/' (TFIN '-' TDEB) ; 
    UNXPRO= 1.D0 '-' XPRO                      ; 
    IAD   = ('ABS' UNXPRO) '>' ('VALE' 'PREC') ; 
    IAC   = ('ABS' XPRO  ) '>' ('VALE' 'PREC') ; 
 'FINS'                                        ; 
   
 * Evaluation de l'ETAT courant 
  ETAT1   = 'VIDE'  'MCHAML'      ; 
 'REPE' BOU NCONT; 
    BOOL1 = FAUX; 
    MO    ='MOT' IND. &BOU ; 
 *   pas decide si grave d'avoir les reactions !!!! ni les temperatures ni les 
    'SI' ( 'EGA' MO 'GEOFIN')                   ; 'ITER' BOU;'FINSI'; 
    'SI' ( 'EGA' MO 'GEODEB')                   ; 'ITER' BOU;'FINSI'; 
    'SI' ( 'EGA' MO 'REACTIONS')                ; 'ITER' BOU;'FINSI'; 
    'SI' ( 'EGA' MO 'DEFORMATIONS_INELASTIQUES'); 'ITER' BOU;'FINSI'; 
    'SI' ( 'EGA' MO 'DEFORMATIONS')             ; 'ITER' BOU;'FINSI'; 
    'SI' ( 'EGA' MO 'VITESSES')                 ; 'ITER' BOU;'FINSI'; 
 *  'SI' ( 'EGA' MO 'CARA_ACTU')                ; 'ITER' BOU;'FINSI'; 
    'SI' ( 'EGA' MO 'PROPORTIONS_PHASES')       ; 'ITER' BOU;'FINSI'; 
    'SI' ( 'EGA' MO 'PROPORTIONS_PHASE ')       ; 'ITER' BOU;'FINSI'; 
   
     TYPMO ='TYPE' CONTI.MO ; 
   
    'SI' (('NEG' TYPMO 'ENTIER') 'ET' ('NEG' TYPMO 'FLOTTANT') 'ET' ('NEG' TYPMO 'MCHAML')  'ET' ('NEG' TYPMO 'CHPOINT')); 
 *     On ne traite que les types qui nous plaisent :) 
       'ITER' BOU ; 
    'FINS'; 
   
    'SI' (('EGA' MO 'TEMPERATURES') 'ET' ('EGA' MOREF ('MOT' 'REFERENCE'))); 
 *     On utilise TEMPERATURE_REFERENCE au lieu de la TEMPERATURE 
       VAD = WTAB.'TEMPERATURE_REFERENCE'; 
   
    'SINO'; 
      'SI' IAD; 
         'SI' IAC ; 
            VAD =(CONTI.MO '*' UNXPRO) '+' (ESTIM.MO '*' XPRO) ; 
         'SINO'; 
            VAD = CONTI.MO; 
         'FINS'; 
      'SINON' ; 
         VAD = ESTIM. MO; 
      'FINSI'; 
    'FINS'; 
   
    'SI' (( 'EGA' ( 'TYPE' VAD) ('MOT' 'FLOTTANT')) 'OU' 
          ( 'EGA' ( 'TYPE' VAD) ('MOT' 'ENTIER'  ))); 
       BOOL1 = VRAI; 
    'FINSI'; 
   
    'SI' (BOOL1); 
       ETAT1 = ETAT1 'ADET' WTAB. 'MODELE'  MO VAD ; 
    'SINON'; 
      'SI' ( 'EGA' ( 'TYPE' VAD) ('MOT' 'MCHAML')); 
         ETAT1= 'ADET' ETAT1 WTAB.'MODELE' (REDU VAD WTAB.'MODELE'); 
      'SINON'; 
         ETAT1= 'ADET' ETAT1 WTAB.'MODELE'       VAD ; 
      'FINSI'; 
    'FINS'; 
 'FIN' BOU; 
   
 * ------------------------------------------------------------------- 
 * Debut Calcul de l etat pour le Tracking dans le cas du modele PBFEM 
 * ------------------------------------------------------------------- 
 * Switch selon la methode de tracking si existence de PBFEM avec option Tracking active 
 'SI' ('EXIS' PRECED.'MODELE' 'MATE' 'EFEM'); 
   'SI' ('EXIS' PRECED 'TRACKING'); 
     'SI' (PRECED.'TRACKING'); 
 *      Cas du tracking global (Oliver, 2002) - determination de l etat 
       'SI' ('EGA' PRECED.'TYP_TRAC' 'fixed_HC'); 
          MCH_TRA = FIXHC PRECED; 
   
       'SINON'; 
 *        Cas du tracking global - diffusion-convection isotrope - determination de l et 
         'SI' ('EGA' PRECED.'TYP_TRAC' 'variable_HC'); 
            MCH_TRA = VARIHC PRECED; 
   
         'SINON'; 
 *          Cas du tracking global - diffusion-convection anisotrope - determination de l 
           'SI' ('EGA' PRECED.'TYP_TRAC' 'variable_HCD_SU'); 
              MCH_TRA = VARIHCSU PRECED; 
           'FINSI'; 
         'FINSI'; 
       'FINSI'; 
   
 *      On rempli ETAT1 pour ensuite realiser l instanciation dans PAS_MATE 
        ETAT1= 'ADET' ETAT1 WTAB.'MODELE' MCH_TRA; 
     'FINSI'; 
   'FINSI'; 
 'FINSI'; 
 * ----------------------------------------------------------------- 
 * Fin Calcul de l etat pour le Tracking dans le cas du modele PBFEM 
 * ----------------------------------------------------------------- 
   
 * Ajout du CHARGEMENT au temps TI 
 'SI' ('EXIS' WTAB 'CHARGEMENT')                           ; 
    ETAT1 ='ADET' ETAT1 WTAB.'MODELE' WTAB.'CHARGEMENT' TI ; 
 'FINS'                                                    ; 
   
 *Verification qu'on dispose de toutes les composantes ; 
  PAS_VERM PRECED ETAT1                                ; 
   
 'FINP' ETAT1; 
 * PAS_VERM  PROCEDUR  PASCAL    20/06/10    21:15:02     10624 
 'DEBPROC' PAS_VERM PRECED*'TABLE' chetat1*'MCHAML'; 
 *---------- verifications qu'il existe bien les donnees necessaires 
 *---------- au matÈriaux 
 conti=PRECED.'CONTINUATION'; 
 WTAB=PRECED.'WTABLE'; 
 LDEVA = 'EXTR' WTAB.'CARACTERISTIQUES' 'DEVA'; 
 LPAR0 = 'EXTR' WTAB.'MODELE' 'PARA'; 
 LDEVA_DI = 'DIME' LDEVA; 
 nocom='EXTR'  CHETAT1 'COMP'; 
 'SI' ('NEG' LDEVA_DI 0); 
   
    'REPETER' BOU_VA1 LDEVA_DI; 
         ITE1 = &BOU_VA1; 
         NOM1 = 'EXTR' LDEVA ITE1; 
         'SI' (WTAB.'FREQUENTIEL' 'ET' ('EGA' NOM1 'FREQ')) ; 
         'SINON'; 
          'SI' ('NON' ('EXISTE'   nocom NOM1)); 
             'MESS' 'Il manque la variable ' NOM1 ; 
             'ERRE'  ' '; 
          'FINSI' ; 
         'FINSI'; 
    'FIN' BOU_VA1; 
    'SI' WTAB.'FOR_MECA' ; 
      MA = 'VIDE' 'MCHAML' ; 
      'SI' WTAB.'MEC1' ; 
        MA = MA 'ET' (WTAB.'MAT_MEC') ; 
      'FINSI' ; 
      'SI' WTAB.'POR1' ; 
        MA = MA 'ET' WTAB.'MAT_POR' ; 
      'FINSI' ; 
      'SI' ('EXIS' WTAB 'MAT_CHA') ; 
        MA = MA 'ET' WTAB.'MAT_CHA' ; 
      'FINSI' ; 
      LDEVAM='EXTR' MA 'DEVA'; 
      LDEVA_DM = 'DIME' LDEVAM; 
      'SI' ('NEG' LDEVA_DM 0); 
         'SI' ('NON' (('EGA' LDEVA_DM 1) 'ET' 
              ( 'EGA' (LDEVAM 'EXTR' 1) 'ALPH' ) )); 
             WTAB.'RECALCUL'= VRAI; 
         'FINSI'; 
         WTAB.'MATVAR'=VRAI;WTAB.'LDEVA'=LDEVAM; 
         'SI' WTAB.'FREQUENTIEL' ; WTAB.'MATVAR'= FAUX; 'FINSI'; 
      'FINSI'; 
    'FINSI'; 
 'FINSI'; 
 *------- le modËle depend-t-il de parametres externes? Si oui verification 
 *------- de leur presence. 
 'SI' WTAB.'PARA_EXTE'; 
     TEMP0=conti.'TEMPS'; 
     LPAR0_DI = 'DIME' LPAR0; 
    'REPETER' BOU_PA1 LPAR0_DI; 
        NOM1 = 'EXTR' LPAR0 &BOU_PA1; 
        'SI' ('NON' ('EXISTE'   nocom NOM1)); 
             'MESS' 'Il manque la variable ' NOM1  ; 
             'ERRE'  ' '; 
        'FINSI'; 
    'FIN' BOU_PA1; 
    'SI' WTAB.'FOR_MECA' ; 
      WTAB.'PARA_EXTE'=FAUX; 
      'SI'  WTAB.'MEC1' ; 
         MO=WTAB.'MOD_MEC'; 
         'SI' WTAB.'POR1' ; 
           MO= MO 'ET' WTAB.'MOD_POR'; 
         'FINSI'; 
      'SINON'; 
         MO=WTAB.'MOD_POR'; 
      'FINSI'; 
      LPAR0 = 'EXTR' MO 'PARA'; 
      LPAR0_DI = 'DIME' LPAR0; 
      'SI' ( LPAR0_DI  'NEG' 0) ; 
        WTAB.'PARA_EXTE'=VRAI; 
        WTAB.'LPAR0'= LPAR0 ; 
      'FINSI'; 
    'FINSI'; 
 'FINSI'; 
 'FINPROC'; 
 * PAS_MATE  PROCEDUR  KICH      20/01/03    21:15:08     10477 
 'DEBP' PAS_MATE PRECED*'TABLE'  ETAT*'MCHAML'; 
 WTAB=PRECED.'WTABLE'; 
   
 'SI' (WTAB.'MATVAR' 'OU' WTAB.'MODAL' 'OU' WTAB.'FREQUENTIEL'); 
   
 'SI' WTAB.'MEC1'; 
    MA=WTAB.'MAT_MEC'; 
    MO=WTAB.'MOD_MEC'; 
   'SI'  WTAB.'POR1' ; 
      MA=MA 'ET' WTAB.'MAT_POR'; 
      MO=MO 'ET' WTAB.'MOD_POR'; 
   'FINSI'; 
 'SINON'; 
    MA=WTAB.'MAT_POR'; 
    MO=WTAB.'MOD_POR'; 
 'FINSI'; 
   
 'SI' ('EXISTE' WTAB 'MOD_LIA') ; 
    MO = MO 'ET' WTAB.'MOD_LIA' ; 
    MA = MA 'ET' WTAB.'MAT_LIA' ; 
 'FINSI' ; 
   
 'SI' ('EXISTE' WTAB 'MOD_CHA') ; 
    MO = MO 'ET' WTAB.'MOD_CHA' ; 
    MA = MA 'ET' WTAB.'MAT_CHA' ; 
 'FINSI' ; 
   
 *Pour certains materiaux on ne fait aucune instanciation 
 *pour les passer a l'operateur 'COMP' -------------- 
 ISPE    = FAUX ; 
 ISTA    = FAUX ; 
 IBET    = FAUX ; 
 TABMOD  = 'EXTR' MO 'ZONE' ; 
 ISTRUB1 = 1 ; 
 'REPE' STRUB1 ((DIME TABMOD) / 2) ; 
    MMO= TABMOD.ISTRUB1; 
   'SI'   (( 'EXISTE' MMO 'MATE' 'ENDOMMAGEABLE'  ) 
       'OU' ('EXISTE' MMO 'MATE' 'VISCODOMMAGE'   ) 
       'OU' ('EXISTE' MMO 'MATE' 'PLASTIQUE_ENDOM')) ; 
     'SI' ISPE; 
        MOD_SPE = MOD_SPE 'ET' MMO           ; 
        MAT_SPE = MAT_SPE 'ET'('REDU' MA MMO); 
     'SINON'; 
        MOD_SPE = MMO          ; 
        MAT_SPE ='REDU' MA  MMO; 
        ISPE=VRAI              ; 
     'FINSI'; 
   
   'SINON'; 
     'SI'  ( ('EXISTE' MMO  'MATE' 'DRUCKER_PARFAIT' ) 
     'OU' ('EXISTE' MMO 'MATE' 'MAZARS')  ); 
       'SI' IBET; 
          MOD_BET=MOD_BET 'ET' MMO; 
          MAT_BET=MAT_BET 'ET'  ('REDU'  MA  MMO); 
       'SINON'; 
          MOD_BET= MMO           ; 
          MAT_BET='REDU'  MA  MMO; 
          IBET   = VRAI          ; 
       'FINSI'; 
   
     'SINON'; 
       'SI' ISTA; 
 *         MOD_STA= MOD_STA 'ET' MMO            ; 
 *         MAT_STA= MAT_STA 'ET' ('REDU' MA MMO); 
       'SINON'; 
 *         MOD_STA= MMO         ; 
 *         MAT_STA='REDU' MA MMO; 
          ISTA   = VRAI        ; 
       'FINSI'; 
     'FINSI'; 
   'FINSI'; 
    ISTRUB1 = ISTRUB1 + 2; 
 'FIN' STRUB1; 
   
 MA = WTAB.'CARACTERISTIQUES'; 
 'SI' IBET; 
   'SI' WTAB.'BETON_HT'; 
 *    traitement particulier pour beton HT 
      LDEV= EXTR MAT_BET 'DEVA'; 
     'SI' ('EXIS' LDEV 'T   '); 
        MAT_BET IMAUVAIS=IDBHT MAT_BET MOD_BET WTAB.'TET1' WTAB.'TET2'; 
       'SI' IMAUVAIS; 
          'QUITTER' PASAPAS; 
       'FINSI'; 
        MA = MA 'ET' MAT_BET ; 
     'FINSI'; 
   'FINSI'; 
   
   'SI' ISTA ; 
 *     MAT_STA= MAT_STA 'ET' MAT_BET; 
 *     MOD_STA= MOD_STA 'ET' MOD_BET; 
   'SINON'; 
 *     MAT_STA= MAT_BET; 
 *     MOD_STA= MOD_BET; 
      ISTA   = VRAI   ; 
   'FINSI'; 
 'FINSI'; 
   
    MMM  = 'VARI' 'NUAG' MO MA ETAT 'RIGIDITE' ; 
   
 'SI' ISTA; 
 *   MMM  =           'VARI' 'NUAG' MOD_STA MAT_STA ETAT 'RIGIDITE' ; 
    WTAB.'MA_COMP'= MMM ; 
   'SI' ISPE; 
 *     MMM= MMM 'ET' ('VARI' 'NUAG' MOD_SPE MAT_SPE ETAT 'RIGIDITE'); 
      WTAB.'MA_COMP'= MMM 'ET' MAT_SPE ; 
   'FINSI'; 
   
 'SINON'; 
 *   MMM  =           'VARI' 'NUAG' MOD_SPE MAT_SPE ETAT 'RIGIDITE'; 
    WTAB.'MA_COMP'= MAT_SPE ; 
 'FINSI'; 
   
 'SINO'; 
    MMM  = WTAB.'CARACTERISTIQUES'; 
 'FINS'; 
   
 'FINPROC' MMM ; 
 * UNPAS     PROCEDUR  FD218221  21/01/15    21:15:01     10848 
 'DEBPROC' UNPAS PRECED*'TABLE'; 
 * 
 *----------------------------------------------------------------------* 
 *         PROCEDURE UNPAS                                              * 
 *                                                                      * 
 *    calcul d'un increment de solution en grand deplacement plastique  * 
 *    par la methode des residus                                        * 
 *----------------------------------------------------------------------* 
 *    En entree 
 *     PRECED  la table passee √† PASAPAS 
 * 
 *  kich nota champ de materiau : etablit au debut de procedure UNPAS 
 *  estimation des caracteristiques fin de pas (TI     ): ZMAT22  -->> ZMATXX 
 *  caracteristiques debut de pas              (TEMPS0) : ZMAT11 
 *  puis dans la boucle de non-convergence 
 *      ZMAT1 initialise avec ZMAT11 
 *  materiau fin de pas de temps : ZMAT2 sorti de COMP, 
 *    range dans WTAB.'MAT1' en sortie unpas 
 ************************************************************************ 
 *    sortie STAB12  indice :                                           * 
 *                                                                      * 
 *      DEPT   increment de deplacement  sur le pas                     * 
 *      SIGF   contraintes a la fin du pas                              * 
 *      VARF   variables internes a la fin du pas                       * 
 *      DFPF   deformation inelastique a la fin du pas                  * 
 *      CONV   logique valant vrai si pas de probleme de convergence    * 
 *      DEFF   deformations a la fin du pas si grandes deformations     * 
 *----------------------------------------------------------------------* 
 * 
 * Appel a PAS_MODL : 
 * Mise a jour des indices de PRECED.WTABLE relatifs aux modeles 
 * si PRECED.WTABLE.MODELE a ete modifie 
 PAS_MODL PRECED ; 
   
 *CB215821 : Recuperation de XPETIT (07/12/2016) 
 XPETIT   = 'VALE' 'PETI'    ; 
 XGRAND   = 'VALE' 'GRAND'   ; 
   
 *  declanchement du recalcul de la matrice 
   ITRCLC =  1  * WTAB.'DELTAITER'; 
   'SI' (ITRCLC <  20) ; ITRCLC =  20; 'FINSI'; 
   
 WTAB = PRECED.'WTABLE'      ; 
 LAG_TOT=VRAI; 
 'SI' ('EXIS' WTAB 'LAG_TOT'); LAG_TOT=WTAB.'LAG_TOT'; 'FINS'; 
 conti= PRECED.'CONTINUATION'; 
 estim= PRECED.'ESTIMATION'  ; 
 * 
 *  initialisation et reprise des valeurs des tables **************** 
 * 
 MXMYMZ = 'MOTS' 'MX'  'MY'  'MZ'  'MT'  'FP'  'FPQ'  'FTP' 
                 'IMX' 'IMY' 'IMZ' 'IMT' 'IFP' 'IFPQ' 'IFTP' ; 
 MXMFLX = 'MOTS' 'MX'  'MY'  'MZ'  'MT'  'FLX' 'FP'  'FPQ'  'FTP' 
                 'IMX' 'IMY' 'IMZ' 'IMT' 'FLX' 'IFP' 'IFPQ' 'IFTP' ; 
 MNPRIM = 'MOTS' 'UX'  'UY'  'UZ'  'UR'  'UT'   'RX'   'RY'  'RZ'  'RT' 
                       'P'   'PQ'  'TP'   'ALFA' 'BETA' 
                 'IUX' 'IUY' 'IUZ' 'IUR'  'IUT'  'IRX'  'IRY' 'IRZ' 'IRT' 
                 'IP' 'IPQ'  'ITP' 'IALF' 'IBET' ; 
 MLPRIM = MNPRIM 'ET' ('MOTS' 'LX'); 
 MNDUAL = 'MOTS' 'FX'  'FY'  'FZ'  'FR'   'FT'   'MX'   'MY'  'MZ'  'MT' 
                       'FP'  'FPQ' 'FTP'  'FALF' 'FBET' 
                 'IFX' 'IFY' 'IFZ' 'IFR'  'IFT'  'IMX'  'IMY' 'IMZ' 'IMT' 
                 'IFP' 'IFPQ' 'IFTP' 'IFAL' 'IFBE' ; 
 MLDUAL = MNDUAL 'ET' ('MOTS' 'FLX'); 
 MLDEPL = 'MOTS' 'UX' 'UY' 'UZ' 'UR' 'UT'  'IUX' 'IUY' 'IUZ' 'IUR' 'IUT' 
                 'ALFA' 'BETA' 'IALF' 'IBET' ; 
 MLROTA = 'MOTS' 'RX' 'RY' 'RZ' 'RT' 'P' 'PQ' 'TP' 
                 'IRX' 'IRY' 'IRZ' 'IRT' 'IP' 'IPQ' 'ITP'; 
 MLDEFOR = 'MOTS'  'EPXX' 'EPYY' 'EPZZ' 'EPSS' 'EPTT' 'EPRR' 
                   'GAXY' 'GAXZ' 'GAYZ' 'GAST' 'GASN' 'GATN' 
                   'GARZ' 'GART' 'GAZT' 'GXY ' 
 *                 'CX  ' 'CY  ' 'CZ  ' 
                   'EPSE' ; 
 MVPRIM = 'MOTS' 'VTX' 'VTY' 'VTZ' 'VTR' 'VTT' 'VWX' 'VWY' 'VWZ' 'VWT' 
                 'VVP' 'VVPQ' 'VVTP' 'VALF' 'VBET' 
           'IVTX' 'IVTY' 'IVTZ' 'IVTR' 'IVTT' 'IVWX' 'IVWY' 'IVWZ' 'IVWT' 
                 'IVVP' 'IVPQ' 'IVTP' 'IVAL' 'IVBE' 'VLX'; 
 MOCA = 'MOTS' 'VECT' 'VX  ' 'VY  ' 'VZ  ' 'VXF ' 'VYF ' 'VZF ' 
               'V1X ' 'V1Y ' 'V1Z ' 'V2X ' 'V2Y ' 'V2Z ' ; 
   
 *  definition de variables locales 
 PASUNIL = FAUX; 
 *'SI' ( 'EXIS' PRECED 'ECRIT' ) ; list wtab; 'FINS'; 
 ICERAM = WTAB.'CERAMIQUE' ; 
 IDYN   = WTAB.'DYNAMIQUE'; 
 IELANL = WTAB.'NON_LINEAIRE'; 
 IENDOM = WTAB.'ENDOMMAGEMENT'; 
 IFEFP  = WTAB.'FEFP_FORMULATION' ; 
 IFEFPUL= WTAB.'UPDATE_LAGRANGIAN'; 
 IFTOL  = 'NEG' WTAB.'FTOL' 'INCONNU' ; 
 HYPDEF = 'MOT' WTAB.'HYPOTHESE_DEFORMATIONS'; 
 IGRD   = WTAB.'GRANDS_DEPLACEMENTS'; 
 IKSIA  = WTAB.'K_SIGMA'; 
 IKTAN  = WTAB.'K_TANGENT' ; 
 IMPLP  = WTAB.'LIAISON_PERSISTANTE'; 
 IMTOL  = 'NEG' WTAB.'MTOL' 'INCONNU'; 
 IPILOT = WTAB.'AUTOMATIQUE'; 
 IPLAST = WTAB.'PLASTIQUE'; 
 IPLAVI = WTAB.'IPLAVI'; 
 IPREDIC = WTAB.'PREDICTEUR'; 
 IRCON  = WTAB.'RAIDCONST'; 
 IRAUGLU  = WTAB.'RAIDAUGM'; 
 IRAUG = IRAUGLU ; 
 AUTAUG = WTAB.'AUTOAUGM'; 
 ISOL   = WTAB.'CONSOLIDATION'; 
 ISSTE  = WTAB.'SUBSTEPPING'; 
 ITHER  = WTAB.'CHAR_THE' 'OU' WTAB.'FOR_THER'; 
 IVIEXT = WTAB.'VISCO_EXTERNE'; 
 IVIDOM = WTAB.'VISCODOMMAGE'; 
 IVISCO = WTAB.'VISCOPLASTIQUE'; 
 LNLOC  = WTAB.'NLOC'; 
 LOGDEF = WTAB.'CHAR_DEFI'; 
 LOGPRE = WTAB.'CHAR_PRES' ; 
 LOGPIL = WTAB.'CHAR_PILO' ; 
 NITMA  = WTAB.'NITERINTER_MAX'; 
 NSSTE  = WTAB.'NMAXSUBSTEPS'; 
 POR1   = WTAB.'POR1' ; 
 TI     = WTAB.'T_FINAL'; 
 EKREAC = WTAB.'REAC_GRANDS'; 
 ekreac = 1e50; 
 ZMAXIT = WTAB.'MAXITERATION' ; 
 ZNACCE = VRAI; 
 XCONV = 0.; 
 DEPSTDM = 0.; 
 ZNCONS = WTAB.'NITER_KTANGENT'     ; 
 ZPREC  = WTAB.'PRECISION'          ; 
 ZPREK  = WTAB.'PRECISINTER'        ; 
 ZPRECD = WTAB.'PRECDECHARGE'       ; 
 ZPRECM = WTAB.'PRECFLEX'           ; 
 ZCLIM0 = WTAB.'BLOCAGES_MECANIQUES'; 
 *-- Autres initialisations en non-local helmhoktz -- 
 'SI' (LNLOC 'ET' ('EGA' WTAB.'NON_LOCAL' 'HELM')); 
   TAHELM = WTAB.'HELMHOLTZ' ; 
   NHELM =  TAHELM . 'N_VARI_NL' ; 
 'FINSI' ; 
 *-- On initialise ZCLIM qui va contenir l'ensemble des C.L. 
 ZCLIM  = ZCLIM0    ; 
 DT     = WTAB.'DT' ; 
 TEMPS0=WTAB.'TEMPS0'; 
 *---  doit on reactualiser la geometrie temp0 ne 0 et grand depl ? --- 
 'SI'  WTAB.'RECALCUL'  ; 
     WTAB . 'RECARI'   = VRAI ; 
     WTAB . 'RECADET'  = VRAI ; 
     WTAB . 'REA_GEOM' = VRAI ; 
 *   on suppose que l'on est sur la bonne configuration 
     GEOM1 = 'FORM'; 
 *  'FORM'  GEOM1; 
 'SINON'; 
     GEOM1 = WTAB.'FOR0' ; 
     WTAB . 'RECARI'  = FAUX ; 
     WTAB . 'RECADET' = FAUX ; 
 'FINS'; 
   
 'SI' ('OU' ('OU' IENDOM  IVIDOM) ICERAM); 
      WTAB.'RECARI'= VRAI; 
      LAG_TOT=0; 
 'FINS'; 
   
 'SI' IRAUG; 
    RIG_AUG  = WTAB.'RIGIDITE_AUGMENTEE'; 
 'FINS'; 
   
 'SI' IRCON; 
    RIG_CONS = WTAB.'RIGIDITE_CONSTANTE'; 
    MAI_CONS ='EXTR' RIG_CONS 'MAIL'    ; 
 'FINS'; 
   
 *---------- chamelem etat estime pour la fin du pas de temps ------ 
  ZETAT2 = PAS_ETAT PRECED TI    ; 
  ZMAT22 = PAS_MATE PRECED ZETAT2; 
  ZMATFI = ZMAT22                ; 
   
 *----------------------- nouveau chargement ---------------------- 
 'SI' ('EXIS' (WTAB.'CHARGEMENT') 'MECA'); 
       ZFEXT2 = 'TIRE' WTAB.'CHARGEMENT' 'MECA' TI; 
       TYP_2  = 'TYPE' ZFEXT2; 
       'SI' ('NEG' TYP_2 'CHPOINT '); 
  'MESS' '*** Erreur dans la definition du chargement ( MECA ) ***'; 
  'ERRE' '*** Le type du champ n est pas CHPOINT ***'; 
       'FINS'; 
 'SINON'; 
     ZFEXT2= 'VIDE' 'CHPOINT' / 'DISCRET'; 
 'FINS'; 
   
 'SI' ('EXIS' (WTAB.'CHARGEMENT') 'FORC'); 
       F2_FOR = 'TIRE' WTAB.'CHARGEMENT' 'FORC' TI; 
        TYP_2 = 'TYPE' F2_FOR; 
        'SI' ('NEG' TYP_2 'CHPOINT '); 
  'MESS' '*** Erreur dans la definition du chargement ( FORC ) ***'; 
  'ERRE' '*** Le type du champ n est pas CHPOINT ***'; 
       'FINS'; 
        ZFEXT2 = ZFEXT2 '+' F2_FOR ; 
 'FINS'; 
   
 'SI' (LOGPRE 'ET' ('NON' IGRD)) ; 
    MOP   = WTAB.'MOD_PRE' ; 
    ZPEXT ='TIRE' WTAB.'CHARGEMENT' 'PRES' TI ; 
   'SI' ('EXIS' WTAB 'MAT_PRE') ; 
      ZFPEXT = 'BSIG' MOP ZPEXT ('REDU' ZMATFI MOP) ; 
   'SINON' ; 
      ZFPEXT = 'BSIG' MOP ZPEXT ; 
   'FINS' ; 
    ZFEXT2 = ZFEXT2 '+' ZFPEXT ; 
 'FINS' ; 
   
   
 *--------------- Si il existe des deplacements imposes -------------- 
          'SI' ('EXIS' (WTAB.'CHARGEMENT') 'DIMP'); 
              F2_DEP = 'TIRE' WTAB.'CHARGEMENT' 'DIMP' TI; 
              ZFEXT2 = ZFEXT2 + F2_DEP; 
          'FINS'; 
 *--------------- Si il un increment de deplacements imposes ----------------- 
          'SI' ('EXIS' (WTAB.'CHARGEMENT') 'DINC'); 
              F2_INC = 'TIRE' WTAB.'CHARGEMENT' 'DINC' TI; 
 *              list f2_inc; 
              F2_mail = extr f2_inc maillage; 
              zclim_mail = zclim extrai 'MAILLAGE'; 
              F2_Mcmp = zclim_mail elem appu larg f2_mail; 
              zclim_inc = zclim redu f2_mcmp; 
   
              f2_base = (zclim_inc * conti.'DEPLACEMENTS') exco 'FLX' 'FLX'; 
 *              list  f2_base; 
              ZFEXT2 = ZFEXT2 + F2_INC + F2_base; ; 
          'FINS'; 
 *---------------- si chargement deformation actualisation DEFOR ------ 
          'SI' WTAB.'CHAR_DEFI' ; 
              WTAB.'DEFOR2' = 'TIRE' WTAB.'CHARGEMENT' 'DEFI' TI; 
          'FINS'; 
   
 *---------- dynamique : preparation du second membre -------------- 
          'SI' ( WTAB.'DYNAMIQUE' ) ; 
             'SI'  ('EGA' WTAB.'FREA1' 'INCONNU'); 
                'SI' ('EXIS' WTAB.'CHARGEMENT' 'MECA'); 
                    F1 = 'TIRE' WTAB.'CHARGEMENT' 'MECA' TEMP0; 
                'FINS'; 
                'SI' ('EXIS' WTAB.'CHARGEMENT' 'FORC'); 
                   F1F = 'TIRE' WTAB.'CHARGEMENT' 'FORC' TEMP0; 
                 'SI' ('EGA' ('TYPE' F1) 'CHPOINT ') ; 
                   F1 = F1 + F1F ; 
                 'SINON'; 
                   F1 = F1F ; 
                 'FINS' ; 
                'FINS'; 
   
                'SI' WTAB.'PROCEDURE_CHARMECA'; 
                   TFF1 = CHARMECA PRECED TEMPS0 ; 
                  'SI' ('EXIS' TFF1 'ADDI_SECOND'); 
                     FF1=TFF1 .'ADDI_SECOND'; 
                  'FINS'; 
                  'SI' ('EGA' ('TYPE' F1) 'CHPOINT '); 
                     F1=F1 + FF1; 
                  'SINON'; 
                     F1 = FF1; 
                  'FINS'; 
                'FINS'; 
   
                'SI' LOGPRE ; 
                  MOP = WTAB.'MOD_PRE' ; 
                  ZPEXT0 = 'TIRE' WTAB.'CHARGEMENT' 'PRES' TEMPS0 ; 
                  'SI' ('EXIS' WTAB 'MAT_PRE') ; 
                    FF1 = 'BSIG' MOP ZPEXT0 ('REDU' WTAB.'MAT1' MOP) ; 
                  'SINON' ; 
                    FF1 = 'BSIG' MOP ZPEXT0 ; 
                  'FINS' ; 
                  'SI' ('EGA' ('TYPE' F1) 'CHPOINT '); 
                    F1=F1 + FF1; 
                  'SINON'; 
                    F1 = FF1; 
                  'FINS'; 
                'FINS'; 
 * 
                  LAF0 = 'BSIG' WTAB.'MO_TOT' conti.'CONTRAINTES' ZMAT22; 
                'SI'  IRCON  ; 
                   LAF0 = LAF0 'ET' 
                   ('REDU' MAI_CONS (RIG_CONS '*' conti.'DEPLACEMENTS')); 
                'FINS'; 
                'SI' (('EXIS' WTAB.'CHARGEMENT' 'MECA') 'OU' 
                     ('EXIS' WTAB.'CHARGEMENT' 'FORC') 'OU' 
                    wtab.'PROCEDURE_CHARMECA'); 
                   LAF1  = F1  - LAF0 ; 
                'SINON'; 
                   LAF1 = -1 * LAF0; 
                'FINS'; 
                LAF2 = 'ENLEVER' (ZCLIM0 '*' conti.'DEPLACEMENTS') 'FLX'; 
 * forces exterieures + reactions - forces interieures au debut du calcul 
 * c.a.d. (masse*acceleration initiale)+(amortissement*vitesse initiale) 
                 WTAB.'FREA1' = LAF1 - LAF2 ; 
             'FINS'; 
             'SI' wtab.'LIAISON_PERSISTANTE' ; 
 *  forces d'acceleration au debut du pas 
               'SI' ('NEG' WTAB.'AMORTISSEMENT' 'INCONNU'); 
                  FF4 = WTAB.'AMORTISSEMENT'* conti.'VITESSES'; 
                  WTAB.'FMAN'= WTAB.'FREA1' - FF4 ; 
               'SINON' ; 
                  WTAB.'FMAN'= WTAB.'FREA1' ; 
               'FINS'; 
             'FINS'; 
 *------------  il faut calculer la matrice de masse tout de suite ------------- 
             'SI' ( ('NON' ('EXIS' WTAB MASSE )) 'OU' 
                                WTAB.'GRANDS_DEPLACEMENTS'); 
                 WTAB.'MASSE' = 'MASS' WTAB.'MO_TOT' ('CHAN' 'MASSE' 
                          ZMAT22 WTAB.'MO_TOT' ) ; 
                'SI' WTAB.'MASSCONST'; 
                   WTAB.'MASSE'=WTAB.'MASSE' 'ET' WTAB.'MASSE_CONSTANTE'; 
                'FINS'; 
             'FINS'; 
             FF = WTAB.'MASSE' *conti.'VITESSES'; 
             FF4 = 4. / DT * FF; 'DETR' FF; 
 * partie du second membre qui ne depend que des informations du pas prec 
             WTAB.'FREA1' = FF4 + WTAB.'FREA1'; 
          'FINS'; 
 *--------- consolidation  : preparation du second membre --------- 
           'SI' WTAB.'CONSOLIDATION' ; 
             FF  = 'BSIG'  WTAB.'MOD_POR' conti.'CONTRAINTES' ; 
             FF4 = 'EXCO'  WTAB.'MOT_POR' FF 
                     WTAB.'MOT_POR' 'NOID' 'NATURE' 'DISCRET' ; 
             'SI' WTAB.'DYNAMIQUE'; 
                 WTAB.'FREA1' = WTAB.'FREA1' +   FF4   ; 
             'SINON'; 
                  WTAB.'FREA1' =  FF4   ; 
             'FINS'; 
              ZFEXT2 = ZFEXT2 '+' FF4  ;  'DETR' FF ; 
 *           ---- traitement des flux si besoin ---- 
             'SI' ( 'EXIS' WTAB.'CHARGEMENT' 'FLUX' ) ; 
                FLUXT0= 'TIRE' WTAB.'CHARGEMENT' 'FLUX' TEMPS0; 
                FLUXTI= 'TIRE' WTAB.'CHARGEMENT' 'FLUX' TI  ; 
                FACFLU =  -1. * WTAB.'DT'; 
                FLUXT =   ( FACFLU * (1 - WTAB.'TETA') * FLUXT0 ) 
                        + ( FACFLU * WTAB.'TETA' *FLUXTI ) ; 
                ZFEXT2 = ZFEXT2 '+' FLUXT ; 
               'DETR' FLUXT ; 'DETR' FLUXT0; 'DETR' FLUXTI; 
            'FINS' ; 
         'FINS'; 
 *----------------- non-local type HELM : preparation -------------- 
         'SI' (LNLOC 'ET' ('EGA' WTAB.'NON_LOCAL' 'HELM')); 
              PAS_HELM PRECED ; 
         'FINS' ; 
 *----------------- calcul de la masse si frequentiel ------------- 
         'SI' ( WTAB.'FREQUENTIEL' 'ET' ('NON' ('EXIS' WTAB 'MASSE' ))); 
              WTAB.'MASSE' = 'MASS' WTAB.'MO_TOT'('CHAN' 'MASSE' 
                          ZMAT22 WTAB.'MO_TOT' ) ; 
         'FINS'; 
   
 *----------------- pilotage indirect : preparation -------------- 
         'SI' (LOGPIL); 
              ZFPILIN = WTAB.'FORCES_PILOTEES' 'ET' WTAB.'DEPLACEMENTS_PILOTES' ; 
                          DTAU = ('IPOL' WTAB.'PARAMETRE_DE_PILOTAGE' TI) - 
                                 ('IPOL' WTAB.'PARAMETRE_DE_PILOTAGE' TEMPS0) ; 
              ETA0 = 'EXTR' PRECED.'COEFFICIENT_DE_PILOTAGE' 
                              ('DIME' PRECED.'COEFFICIENT_DE_PILOTAGE') ; 
              D_ETA=0.; 
         'FINS' ; 
   
 *-      Second membre 
         ZFCONSTA = ZFEXT2 ; 
   
   
 ************************************************************************ 
 *             Parall√©lisation du GIBIANE via les ASSISTANTS            * 
 ************************************************************************ 
 ZMODLI = WTAB.'MO_TOT'     ; 
 ZMODLP = WTAB.'MO_TOT_PREC'; 
 NBPART = WTAB.'NBPART'     ; 
   
 PARALLEL = FAUX ; 
 PARTLOCA = FAUX ; 
 ZMODL  = ZMODLI ; 
 'SI' ('EGA' WTAB.'PROCESSEURS' 'COMPORTEMENT') ; 
   PARALLEL = VRAI ; 
   PARTLOCA = VRAI ; 
   MODRELOC = 'PART' 'ARLE' ZMODLI NBPART ; 
 'FINS' ; 
 'SI' ('EGA' WTAB.'PROCESSEURS' 'AUTOMATIQUE') ; 
   PARALLEL = VRAI ; 
   PARTLOCA = FAUX ; 
   ZMODL = 'PART' 'ARLE' ZMODLI NBPART ; 
   'OPTI' 'PARA' VRAI ; 
 'FINS' ; 
   
 * Test sur un MODELE qui aurait chang√© 
 'SI' ('NEG' ZMODLI ZMODLP)                                   ; 
    CONTI.'CONTRAINTES' =('REDU' CONTI. 'CONTRAINTES' ZMODLI) '+' ('ZERO' ZMODLI 'CONTRAINTES') ; 
    ESTIM.'CONTRAINTES' =('REDU' ESTIM. 'CONTRAINTES' ZMODLI) '+' ('ZERO' ZMODLI 'CONTRAINTES') ; 
    CONTI.'DEFORMATIONS'=('REDU' CONTI.'DEFORMATIONS' ZMODLI) '+' ('ZERO' ZMODLI 'DEFORMAT'   ) ; 
    ESTIM.'DEFORMATIONS'=('REDU' ESTIM.'DEFORMATIONS' ZMODLI) '+' ('ZERO' ZMODLI 'DEFORMAT'   ) ; 
   'SI' IPLAVI ; 
      CONTI.'DEFORMATIONS_INELASTIQUES'=('REDU' CONTI.'DEFORMATIONS_INELASTIQUES' ZMODLI) '+' ('ZERO' ZMODLI 'DEFINELA') ; 
      ESTIM.'DEFORMATIONS_INELASTIQUES'=('REDU' ESTIM.'DEFORMATIONS_INELASTIQUES' ZMODLI) '+' ('ZERO' ZMODLI 'DEFINELA') ; 
      CONTI.'VARIABLES_INTERNES'       =('REDU' CONTI.'VARIABLES_INTERNES'        ZMODLI) '+' ('ZERO' ZMODLI 'VARINTER') ; 
      ESTIM.'VARIABLES_INTERNES'       =('REDU' ESTIM.'VARIABLES_INTERNES'        ZMODLI) '+' ('ZERO' ZMODLI 'VARINTER') ; 
   'FINS'; 
   
    WTAB.'ETAT1' = PAS_ETAT PRECED TEMPS0      ; 
    WTAB.'MAT1'  = PAS_MATE PRECED WTAB.'ETAT1'; 
   
   'SI' ITHER ; 
      WTAB.'ETHER1'    =('REDU' WTAB.'ETHER1'   ZMODLI) '+' ('ZERO' ZMODLI 'DEFORMAT') ; 
     'SI' POR1; 
        WTAB.'MSRTHER1'=('REDU' WTAB.'MSRTHER1' ZMODLI) '+' ('ZERO' ZMODLI 'DEFORMAT') ; 
     'FINS'; 
   'FINS'; 
   
   'SI' ('EXIS' WTAB 'DEFOR1' ); 
      WTAB.'DEFOR1' = 
                    ('REDU'  WTAB.'DEFOR1' ZMODLI) '+' 
                    ('ZERO' ZMODLI 'DEFORMAT'    ) ; 
   'FINS'; 
   
   'SI' ('EXIS' WTAB 'DEFOR2' ); 
      WTAB.'DEFOR2' = 
                    ('REDU'  WTAB.'DEFOR2' ZMODLI) '+' 
                    ('ZERO' ZMODLI 'DEFORMAT'    ) ; 
   'FINS'; 
 'FINS'; 
   
 *-----------materiau au debut du pas ------------------------------ 
 ZMAT11 = WTAB.'MAT1'        ; 
 'SI' ('EGA' WTAB.'PROCESSEURS' 'AUTOMATIQUE') ; 
    ZMAT1 ='REDU' ZMAT11 ZMODL ; COMM 'REDU au cas ou le modele est parallele'; 
 'SINO'; 
    ZMAT1 = ZMAT11; 
 'FINS'; 
  ZMAT1I  = ZMAT1; COMM 'Version Initiale de ZMAT1 pour BONOCONV'; 
   
   
 ************************************************************************ 
 *                       Quelques initialisations                       * 
 ************************************************************************ 
 STAB12             = 'TABL'                    ; 
 STAB12.'ZU1'       =  CONTI.'DEPLACEMENTS'     ; 
 STAB12.'SIGF'      =  CONTI.'CONTRAINTES'      ; 
 STAB12.'DEFF'      =  CONTI.'DEFORMATIONS'     ; 
 STAB12.'FNONL'     =  WTAB.'FNONL'             ; 
 STAB12.'RESIDU'    =  WTAB.'RESIDU'            ; 
 STAB12.'XDENO'     =  WTAB.'XDENO'             ; 
 STAB12.'XDENOM'    =  WTAB.'XDENOM'            ; 
 'SI' ( 'EXIS' WTAB 'ETAT1' ); 
   STAB12.'ETAT1'   = WTAB.'ETAT1'; 
 'FINS'; 
 STAB12.'ETAT2'= ZETAT2; 
 'SI' ('EXIS' WTAB 'DEFOR1' ); 
   STAB12.'DEFOR1'  = WTAB.'DEFOR1'  ; 
   STAB12.'DEFOR2'  = WTAB.'DEFOR2'  ; 
 'FINS'; 
 'SI' ( 'EXIS' WTAB 'FNONL'); 
   STAB12.'FNONL'   = WTAB.'FNONL'   ; 
 'FINS'; 
 'SI' ('EXIS' WTAB  'TET1') ; 
   STAB12.'TET1'    = WTAB.'TET1'    ; 
   STAB12.'TET2'    = WTAB.'TET2'    ; 
 'FINS'; 
 * STAB12.'SUCCES' = VRAI ; 
 'SI' ('NEG' WTAB.'AUTOCOEF' 'INCONNU') ; 
   STAB12.'AUTOCOEF' = WTAB.'AUTOCOEF' ; 
 'FINS' ; 
 'SI' ('NEG' WTAB.'AUTOREDU' 'INCONNU') ; 
   STAB12.'AUTOREDU' = WTAB.'AUTOREDU' ; 
 'FINS' ; 
 'SI' ('NEG' WTAB.'SECOND_MEMBRE' 'INCONNU') ; 
   STAB12.'SECOND_MEMBRE' = WTAB.'SECOND_MEMBRE' ; 
 'FINS' ; 
 'SI' ('NEG' WTAB.'LASTKTAN' 'INCONNU') ; 
   STAB12.'LASTKTAN' = WTAB.'LASTKTAN' ; 
 'FINS' ; 
 'SI' ('NEG' WTAB.'AUTORED1' 'INCONNU') ; 
   STAB12.'AUTORED1' = WTAB.'AUTORED1' ; 
 'FINS' ; 
 'SI' ('NEG' WTAB.'LISEA_M' 'INCONNU') ; 
   STAB12.'LISEA_M' = WTAB.'LISEA_M' ; 
   STAB12.'RIBLO_M' = WTAB.'RIBLO_M' ; 
 'FINS' ; 
 'SI' ('NEG' WTAB.'INCREMENT' 'INCONNU' ); 
   STAB12.'INCREMENT' = WTAB.'INCREMENT'; 
   INCRPREC = STAB12.'INCREMENT'        ; 
 'FINS'; 
 STAB12.'FFROT'    = WTAB.'FFROT'    ; 
 STAB12.'INITEMPS' = WTAB.'INITEMPS' ; 
 STAB12.'DT'       = WTAB.'DT'       ; 
 STAB12.'DTPREC'   = WTAB.'DTPREC'   ; 
   
 'SI'  ITHER  ; 
    STAB12.'TETA1'  = WTAB.'TET1'; 
    STAB12.'TETA2'  = WTAB.'TET2'; 
    ETT0 ='REDU' WTAB.'ETHER1' ZMODL;     'COMM' 'REDU au cas ou le modele soit parallele'; 
   'SI' POR1; 
     MSRTT0='REDU' WTAB.'MSRTHER1' ZMODL; 'COMM' 'REDU au cas ou le modele soit parallele'; 
   'FINS'; 
   
 'SINON' ; 
    che3 ='MANU' 'CHML' ZMODL 'T' 20. 'STRESSES' ; 
    che4 ='MANU' 'CHML' ZMODL 'T' 20. 'STRESSES' ; 
 'FINS' ; 
   
 ZMATI   ='REDU' ZMAT22 ZMODLI ; 
 ZMAT    ='REDU' ZMATI  ZMODL  ; 
   
 * SP : initialisation DFGRAD en presence d'un modele MECANIQUE 
 *      (DFGRAD mis a INCONNU par defaut dans PAS_INIT) 
 'SI' ('NEG' WTAB.'MOD_MEC' 'INCONNU') ; 
   'SI' (('NEG' WTAB.'DFGRAD' 'INCONNU') 'ET' IGRD) ; 
     geot = 'FORM' ; 'FORM' WTAB.'FOR0' ; 
     STAB12.'DFGRAD' ='GRAD' ZMODL ZMAT STAB12.'ZU1' ; 
     'FORM' geot ; 
 **'SINO'; 
 **  STAB12.'DFGRAD' ='REDU' WTAB.'DFGRAD' ZMODL; 
   'FINS' ; 
 'SINON' ; 
   STAB12.'DFGRAD' = WTAB.'DFGRAD' ; 
 'FINS' ; 
   
 com_sig  = 'EXTR' ZMODLI  'CONT'; 
 HPP_EPS  =  FAUX                ; 
 EPS_EPS  = 'TEXT' '        '    ; 
 * Option a n'utiliser que par les utilisateurs avertis 
 'SI' ('EXIS' PRECED 'ACCELERATION') ; 
   III = PRECED.'ACCELERATION' ; 
   'SI' ('EGA' ('TYPE' III) 'ENTIER') ; ZNACCE = III ; 'FINS' ; 
 'FINS' ; 
 * Matrice tangente : non utilisee si IPLAVI a FAUX 
 IKTAN  = IKTAN 'ET' IPLAVI ; 
 'SI' (WTAB.'K_TANGENT' 'ET' ('NON' IPLAVI)) ; 
   'MESS' 'IPLAVI faux : pas de matrice tangente ->' 
          ' on utilise la rigidite elastique' ; 
 'FINS' ; 
 * Matrice tangente par perturbation : 
 * Option non disponible si non local ou si IPLAVI a FAUX 
 IPERT = WTAB.'K_TANGENT_PERT' 'ET' ('NON' LNLOC) 'ET' IPLAVI ; 
 ZPERC1 = WTAB.'K_TANG_PERT_C1' ;  ZPERC2 = WTAB.'K_TANG_PERT_C2' ; 
 * Matrice tangente : partie symetrique utilisee 
 'SI' WTAB.'K_TANGENT_SYME' ; 
   ZKTASYM = 'MOT' 'SYME' ; 
 'SINON' ; 
   ZKTASYM = 'TEXTE' '    ' ; 
 'FINS'; 
 * Matrice tangente : pas d'acceleration en cas de modele FEFP ou SSTE 
 'SI' IKTAN ; 
   'SI' (IFEFP 'OU' ISSTE) ; ZNACCE = FAUX; 'FINS'; 
 'FINS' ; 
 * 
 'SI' IFTOL ; 
     ZFTOL = 'ABS' WTAB.'FTOL' ; 
 'FINS'; 
 'SI'  IMTOL  ; 
     ZMTOL = 'ABS' WTAB.'MTOL' ; 
 'FINS'; 
 ITCAR = ( 'EXIS' ZMATI  'EPAI') 'OU' ('EXIS' ZMATI 'INRY') 'OU' 
         ( 'EXIS' ZMATI  'MODS') 'OU' 
        (( 'EXIS' ZMODLI 'ELEM' 'JOI1') 'ET' ('EXIS' ZMATI 'V1X ') 
                                        'ET' ('EXIS' ZMATI 'V1Y '))  ; 
 * 
 * CB215821 : Devrait t-on mutualiser ITCAR et WTAB.ITCAR? ==> 
 *            Ce ne sont pas tout a fait les memes tests aujourd'hui 
 'SI' (ITCAR 'EGA' FAUX); 
    ZMAT2 = ZMATI ; 
    ZMAT2R= ZMAT  ; 
 'FINS'; 
   
 'SI' WTAB.'ITCAR'; 
   'SI' ('EGA' WTAB.'CARA' ('MOT' 'INCONNU')); 
      WTAB.'CARA' = ZMAT11 ; 
   'FINS'; 
    CARA1 = ZMAT1; 
 'FINS'; 
   
 'SI' ('OU' ('OU' IVISCO IVIDOM) IVIEXT);  ZPREK = 5.E-7 ;  'FINS'; 
 'SI' IENDOM;                              ZPREK = ZPREC ;  'FINS'; 
   
 * on fait ici la s√©paration poreux .. pour l'avoir sur 
 *les mod√®les partitionnes 
 'SI' POR1; 
     MO_PORI = 'EXTR' ZMODLI 'FORM' 'POREUX'; 
     MO_POR  = 'EXTR' ZMODL  'FORM' 'POREUX'; 
   
     MA_POR  = 'REDU' ZMAT22 MO_POR      ; 
 ** kich ma_por0 intervient si ISOL 
 ** initialement     MA_POR0= 'REDU' MO_POR (STAB12.'MAT1'); 
     MA_POR0 = 'REDU' ZMAT11 MO_POR      ; 
   
     MAI_POR = 'EXTR' MO_POR  'MAILLAGE' ; 
     MAI_PORI= 'EXTR' MO_PORI 'MAILLAGE' ; 
 'FINS'; 
   
 * recuperation de certains champs, si nbpart>1 zmodl est partitionn√© 
 * sinon c'est le modele initial 
 *                                                                      * 
 DEFT0        = 'REDU' conti.'DEFORMATIONS' ZMODL              ; 
 ZSIGF        = 'REDU' STAB12.'SIGF' ZMODL                     ; 
 'SI' IPLAVI ; 
      ZDEIF   = 'REDU' CONTI.'DEFORMATIONS_INELASTIQUES' ZMODL ; 
      ZVARF   = 'REDU' CONTI.'VARIABLES_INTERNES'        ZMODL ; 
      com_var = 'EXTR' ZMODLI 'VARI' ; 
      com_dei = 'EXTR' ZMODLI 'DEIN' ; 
      lnom    =  com_var             ; 
     'SI' ISOL  ; 
        com_maa = 'EXTR' ZMODLI 'MATE' ; 
     'FINS' ; 
 'FINS' ; 
 * 
 *   teste t'on les moments  ? 
 TSTMOM = ITCAR 'OU' ('EGA' ('VALE' 'MODE') 'PLANGENE') ; 
 *   teste t'on les POREUX   ? 
 'SI' POR1  ; TSTMOM=VRAI ; 'FINS'; 
 * 
 IKLFFF=VRAI; 
 'SI'TSTMOM;    'SI' IFTOL;     'SI' IMTOL; 
        IKLFFF=FAUX; 
 'FINS';        'FINS';        'FINS'; 
 * 
 'SI'('NON' TSTMOM); 
     'SI' IFTOL; 
        IKLFFF=FAUX; 
     'FINS'; 
 'FINS'; 
 * 
 GEOREF0  = WTAB.'FOR0' ; 
 WTAB.'CONV'=VRAI; 
 ISOUSPPP=0; 
 'SI' ('EXIS' wtab 'ISOUSPAS'); ISOUSPPP = wtab.'ISOUSPAS'; 'SINON'; isousppp=0; 'FINSI'; 
 WTAB . 'ISOUSPAS' = 0; 
 NSOUSPAS = WTAB . 'MAXSOUSPAS'; 
 ZCCONV = VRAI ; 
 KNOCONV = 0 ; 
   
 * Initialisation CHArgement SANS T : 
 CHASANST= WTAB.'CHARGEMENT' 'ENLE' 'T' ; 
   
 RED_URG = 0; 
    residc = 'VIDE' 'CHPOINT' / 'DISCRET'; 
 'SI' autaug; iraug = faux; 'FINSI'; 
 ************************************************************************ 
 ****** boucle de non convergence 
 ************************************************************************ 
 resmul = 1; 
     augmult = 0.60000000; 
 'REPETER'  BONOCONV NSOUSPAS ; 
 'SI' ('EGA' RED_URG 0); 
  'SI' ((XCONV < ZPREC) 'ET' (DEPSTDM < ZPREC) 'ET' (resmul > 0.99) 'ET' (AUGMULT < 100.)); 
     augmult = 0.60000000; 
 *pv resmul = 1; 
     augauto = augmult; 
     augk    = augmult; 
     'SI' autaug ; iraug = faux; 'FINSI'; 
     znacce=VRAI; 
   'SI' (IFEFP 'OU' ISSTE) ; ZNACCE = FAUX; 'FINS'; 
  'SINON'; 
     augmult = augmult / 1.5; 
 **  si (augmult < 0.6); augmult = 0.6; finsi; 
  'FINSI'; 
 'SINON'; 
    augmult = augmult * 1.5; 
  'SI' autaug;   IRAUG = VRAI; 'FINSI'; 
 'FINSI'; 
 ***   wtab.'RECARI' = vrai; 
   
   KNOCONV       = KNOCONV+1                 ; 
   STAB12.'CONV' = FAUX                      ; 
   DT_INIT       = STAB12.'DT'               ; 
   DTINI         = STAB12.'DT'               ; 
   
   ZSIG0         = ZSIGF                     ; 
   zsig0_1       = zsig0; 
  'SI' IPLAVI ; 
     ZEPS0 =  ZDEIF                          ; 
     ZVAR0 =  ZVARF                          ; 
  'FINS'; 
   
   ZU1           = STAB12.'ZU1'   ; 
   ZDETOT = 'ENLE' ZU1 'LX'; 
  GR_U_DEB = 'MOT' 'INCONNU'; 
  'SI' ('EXIS' STAB12 'DFGRAD' ); 
   GR_U_DEB      = STAB12.'DFGRAD'; 
  'FINSI'; 
   'SI'  ITHER  ; 
      TETA1 = STAB12.'TETA1' ; 
      TETA2 = STAB12.'TETA2' ; 
      DTETD = TETA2 '-' TETA1; 
   'FINS' ; 
   
 * materiau au debut du pas en cas de non convergence etat1=etat2 
   'SI' (knoconv > 1) ; 
      ZMAT1 = 'REDU' (PAS_MATE PRECED STAB12.'ETAT1') ZMODL ; 
   'SINON'; 
      ZMAT1 = ZMAT1I ; 
   'FINS' ; 
 *------ caracteristiques initiales en cas de grands deplacements ------ 
   'SI' WTAB.'ITCAR'; 
      MECAR1 = 'EXCO'  MOCA  ZMAT1  'NOID'            ; 
      MECAR2 = 'EXCO'  MOCA  CARA1  'NOID'            ; 
      MECAR1 = 'CHAN' 'TYPE' MECAR1 'CARACTERISTIQUES'; 
      MECAR2 = 'CHAN' 'TYPE' MECAR2 'CARACTERISTIQUES'; 
      ZMAT1  =  ZMAT1 '-' MECAR1 '+' MECAR2           ; 
   'FINS'; 
   
 *----------- Calcul du champ de materiau a la fin du pas ------------ 
   'SI' (knoconv '>' 1) ; 
      MCHC = PAS_ETAT PRECED TI  ; 
      MMMM = PAS_MATE PRECED MCHC; 
   'SINON' ; 
      MMMM = ZMAT22              ; 
   'FINS' ; 
    MMMM = 'REDU' MMMM ZMODL; 
   
 *----- Caracteristiques initiales en cas de grands deplacements ----- 
   'SI' WTAB.'ITCAR'; 
      MECAR1 = 'EXCO'  MOCA  MMMM   'NOID'            ; 
      MECAR2 = 'EXCO'  MOCA  CARA1  'NOID'            ; 
      MECAR1 = 'CHAN' 'TYPE' MECAR1 'CARACTERISTIQUES'; 
      MECAR2 = 'CHAN' 'TYPE' MECAR2 'CARACTERISTIQUES'; 
      MMMM = MMMM '-' MECAR1 '+' MECAR2               ; 
 *   (fdp) on reporte les variations du materiau sur le pas 
 *    dans les autres instances du champ materiau 
 *   (ZMAT et ZMATI semblent suffirent) 
      MECAR1 = 'EXCO'  MOCA  ZMAT  'NOID'             ; 
      MECAR2 = 'EXCO'  MOCA  MMMM  'NOID'             ; 
      MECAR1 = 'CHAN' 'TYPE' MECAR1 'CARACTERISTIQUES'; 
      MECAR2 = 'CHAN' 'TYPE' MECAR2 'CARACTERISTIQUES'; 
      ZMAT   =  ZMAT  '-' MECAR1 '+' MECAR2           ; 
      ZMATI  = 'REDU' ZMAT ZMODLI                     ; 
   'FINS'; 
   
 *------------ Calcul de la rigidite a la fin du pas ---------------- 
 *  Test ci-dessous est inutile, WTAB.'BLOCAGES_MECANIQUES' et ZCLIM0 
 *  correspondent aux memes rigidites ... (cf. ligne 117) 
    AA1 ='EXTR' WTAB.'BLOCAGES_MECANIQUES' 'MAIL'     ; 
    AA2 ='EXTR' ZCLIM0 'MAIL' ; 
    AA3 ='DIFF' AA1 AA2       ; 
    AA4 = NBNO  AA3           ; 
   'SI' ( (WTAB.'RECARI' 'OU' IRAUG      ) 'OU' 
          ('NON' ('EXIS' WTAB 'RRRR')    ) 'OU' ('NEG' AA4 0)); 
     'SI' ('OU' ('OU' IENDOM  IVIDOM) ICERAM); 
        HOOKENDO ='HOOK' ZMODL MMMM     ZVAR0; 
        RH       ='RIGI' ZMODL HOOKENDO MMMM ; 
       'DETR' HOOKENDO; 
     'SINON'; 
        'SI' ((LAG_TOT 'EGA' 1) 'ET' vrai); 
           'FORM' GEOREF0; 
           HOOKRH = 'HOOK' ZMODL MMMM; 
           HOOKRH2 = 'PICA' HYPDEF HOOKRH ZMODL ZU1; 
           'FORM' GEOM1; 
           RH = 'RIGI' HOOKRH2 ZMODL MMMM; 
           'DETRUI' HOOKRH; 
           'DETRUI' HOOKRH2; 
        'SINON'; 
           RH  = 'RIGI' ZMODL MMMM ; 
        'FINSI'; 
     'FINS'; 
 *   RH peut contenir des CL 
     ZCL = 'EXTR' RH 'RIGI' 'MULT' ; 
     'SI' ('NEG' ('DIME' ZCL) 0) ; 
       ZCLIM = ZCLIM0 'ET' ZCL ; 
     'FINSI' ; 
     RRRR = RH 'ET' ZCLIM0 ; 
 *   Prise en compte d'eventuelles RIGIDITE_CONSTANTE 
     'SI' IRCON; 
       RRRR = RRRR 'ET' RIG_CONS; 
     'FINS'; 
 * 
     ZRAIDNA = RRRR; 
     'SI' (IRAUG 'ET' ('NON' AUTAUG)); 
       RRRR = RRRR 'ET' RIG_AUG  ; 
     'FINSI'; 
 * 
     'SI' (AUTAUG 'ET' ('NON' IRAUGLU)); 
        RIG_AUG  = 'MASSE' ZMODL MMMM ; 
 ***    mess 'actualisation rig_aug'; 
     'FINSI'; 
     'SI' (AUTAUG 'ET' IRAUG); 
 *  recalcul masse pour l'augmentation 
       RRRR = RRRR 'ET' (RIG_AUG * augauto) 'ET' (RH   * augk) ; 
     'FINS'; 
     'SI' ('NON' IRAUG); 
 *  recalcul masse pour l'augmentation 
       'SI' IRAUGLU; 
 ***     'MESS' ' augmentation residuelle '; 
         RRRR = RRRR 'ET' RIG_AUG ; 
     'FINS'; 
     'FINSI'; 
   
     'SI' ('EGA' ('DIME' ZCL) 0) ; 
 *   Stockage de la rigidite pour eviter de la recalculer 
     WTAB.'RRRR'=RRRR; 
     'FINSI'; 
 * 
   'SINON'; 
      RRRR=WTAB.'RRRR'; 
   'FINS'; 
   ZRAID=RRRR; 
   
 *------------ consolidation ou dynamique faut-il recalculer l'operateur? 
 * -----: preparation du pas de temps ------------ 
     'SI' ( WTAB.'CONSOLIDATION' 'OU' WTAB.'DYNAMIQUE'); 
        DT = TI '-' TEMP0; 
       'SI' ( '>' (DELTAN '*' 0.9999) DT) ; 
          WTAB . 'RECAOP' = VRAI; 
       'FINS'; 
       'SI' ( '<' (DELTAN '*' 1.0001) DT) ; 
          WTAB . 'RECAOP' = VRAI; 
       'FINS'; 
       'SI' WTAB.'MATVAR'; 
          WTAB . 'RECAOP' = VRAI; 
       'FINS'; 
        DELTAN=WTAB.'DT'; 
     'FINS'; 
 *---------------------- Formation de l operateur ----------------------- 
      'SI' ( WTAB.'DYNAMIQUE' 'OU' WTAB.'CONSOLIDATION'); 
        'SI' ('NEG' WTAB.'OPERATEUR' 'INCONNU'); 
           ZRAID = WTAB.'OPERATEUR'; 
          'SI' (WTAB . 'RECAOP') ; 
             ZRAID = RRRR ; 
          'FINS'; 
        'FINS'; 
      'FINS'; 
   
 *------------ operateur frequentiel ----------------------- 
 *------------ operateur amortissement en frequentiel 
      'SI' WTAB.'FREQUENTIEL' ; 
         RRR2 = 'AMOR'  ZMODL ZMAT ; 
         RR2  = 'CHAN' 'INCO' RRR2 
               ('MOTS' 'ALFA' 'BETA') ('MOTS' 'IALF' 'IBET') 
               ('MOTS' 'FALF' 'FBET') ('MOTS' 'FALF' 'FBET') 'QUEL' ; 
         RR3  = 'CHAN' 'INCO' RRR2 
               ('MOTS' 'ALFA' 'BETA') ('MOTS' 'ALFA' 'BETA') 
               ('MOTS' 'FALF' 'FBET') ('MOTS' 'IFAL' 'IFBE') 'QUEL' ; 
         RRR2 = RR2 'ET' RR3 ; 
   
         RR1  = ZRAID ; 
         OMEGI= 2.* PI * TI ; 
         RRR1 = OMEGI * OMEGI * (-1.) * WTAB.'MASSE' ; 
         RR1  = ZRAID 'ET' RRR1 ; 
         RR4  = 'CHAN' 'INCO' (RR1 '*' (-1.D0)) 
               ('MOTS' 'ALFA' 'BETA') ('MOTS' 'IALF' 'IBET') 
               ('MOTS' 'FALF' 'FBET') ('MOTS' 'IFAL' 'IFBE') 'QUEL'; 
         ZRAID= RR1   'ET' RR4  ; 
         RR5  = OMEGI '*'  RRR2 ; 
         ZRAID= ZRAID 'ET' RR5  ; 
      'FINS' ; 
   
 *--------------- et la perm√©abilit√©  ---------------------------------- 
      'SI' (WTAB.'CONSOLIDATION') ; 
        'SI' (WTAB.'GRANDS_DEPLACEMENTS' 'OU' WTAB.'MATVAR') ; 
           WTAB .'PERMEABILITE'= 'PERM' WTAB.'MOD_POR' MMMM ; 
           WTAB .'RECAOP'      =  VRAI                      ; 
        'FINS'; 
      'FINS'; 
   
 *------------- Cas de la consolidation ou de la dynamique ------------- 
 *------------- il faut recalculer l'operateur d'iteration ------------- 
      'SI' (WTAB . 'RECAOP') ; 
        'SI' ( WTAB.'DYNAMIQUE'); 
           ZRAID =  4.D0 '/'( DT ** 2) '*' WTAB.'MASSE'     'ET' ZRAID; 
          'SI' ('NEG' WTAB.'AMORTISSEMENT' 'INCONNU'); 
             ZRAID = WTAB.'AMORTISSEMENT' '*' (2.D0 '/' DT) 'ET' ZRAID; 
          'FINS'; 
        'FINS' ; 
   
        'SI' ( WTAB.'CONSOLIDATION'); 
           ZRAID =-1.* DT* WTAB.'TETA'* WTAB.'PERMEABILITE' 'ET' ZRAID ; 
        'FINS' ; 
         WTAB . 'OPERATEUR'= ZRAID ; 
         WTAB . 'RECAOP'   = FAUX  ; 
      'FINS'; 
      ZRAIDNA = ZRAID; 
   
   
 *-------------- traitement des contacts frottements automatiques ------- 
       CDEP    = STAB12.'ZU1'               ; 
       CDEPSLX ='ENLE' CDEP 'LX'            ; 
   
       BFCONT  = FAUX                       ; 
       BCLIM2  = FAUX                       ; 
      'SI' WTAB.'CONTACT'; 
         MODCON= WTAB.'MODCONTA'; 
        'SI' ('EXIS' WTAB 'MATCONTA') ; 
           WTAB.'MATCONTA'= 'REDU' MODCON WTAB.'MATCONTA'; 
 **       list resu wtab.'MATCONTA'; 
           MODFRO matfro  CJEU CRR RFROT='RFCO' MODCON  WTAB.'CONV' WTAB.'MATCONTA' ; 
        'SINON' ; 
           CJEU CRR RFROT='RFCO' MODCON  WTAB.'CONV'                ; 
        'FINS'; 
 **      list  modfro; 
 **      list  matfro; 
 * 
        'SI' ('NEG' 0 CJEU) ; 
          FADHE = 'EXCO' CJEU 'FADH' 'NOID' 'FADH' ; 
          CDAP  = 'EXCO' CJEU 'FLX'  'NOID' 'FLX' ; 
        'FINSI' ; 
   
        'SI' (WTAB . 'MODAL') ; 
           CRR  = 'PJBA' CRR   ZMODL  MMMM  ; 
           MCRR = 'EXTR' CRR  'MAIL' 'MULT' ; 
           MCDAP= 'EXTR' CDAP 'MAIL'        ; 
          'REPETER' BCDA ('NBNO' MCDAP) ; 
             PBCDA ='POIN' MCDAP &BCDA ; 
             PCRR  ='POIN' MCRR  &BCDA ; 
             CHCR  ='MANU' 'CHPO' PCRR 1 'FLX' ('EXTR' CDAP 'FLX' PBCDA) 
                    'NATURE' 'DISCRETE' ; 
            'SI' ('EGA' 1 &BCDA) ; 
               CCDA = CHCR ; 
            'SINON' ; 
               CCDA = CHCR 'ET' CCDA ; 
            'FINS' ; 
          'FIN' BCDA ; 
           CDAP = CCDA ; 
        'FINS' ; 
   
 *       ATTENTION : mettre les conditions de frottement en premier pour 
 *                   les numeroter en dernier 
         ZCLIM2 = 'VIDE' 'RIGIDITE'; 
         ZFCONT  ='VIDE' 'CHPOINT' / 'DISCRET'; 
        'SI'  ('NEG' CRR 0); 
           BCLIM2 = VRAI                ; 
           BFCONT = VRAI                ; 
           ZCLIM2 = CRR    'ET' ZCLIM2  ; 
           CCOR   = CRR    '*'  CDEPSLX ; 
           ZFCONT = ZFCONT '+'  CCOR    ; 
        'FINS'; 
   
        'SI' ( 'NEG' 0 CJEU); 
           BFCONT = VRAI                ; 
           ZFCONT = ZFCONT '+'  CDAP    ; 
        'FINS'; 
   
        'SI' ('NEG' 0 RFROT); 
           BCLIM2 = VRAI                ; 
           BFCONT = VRAI                ; 
           ZCLIM2 = RFROT  'ET' ZCLIM2  ; 
           CCOR   = RFROT  '*'  CDEPSLX ; 
           ZFCONT = ZFCONT '+'  CCOR    ; 
        'FINS'; 
 * 
 *      Mise a jour de ZCLIM et ZFCONSTA si necessaire 
        'SI' BCLIM2; 
          ZCLIM  = ZCLIM2 'ET' ZCLIM ; 
          ZRAID  = ZCLIM2 'ET' ZRAID; 
        'FINS'; 
 * 
        'SI' BFCONT; 
          ZFCONSTA = ZFEXT2 '+' ZFCONT ; 
        'FINS'; 
      'FINS'; 
 * 
       ZFCONST1 = ZFCONSTA; 
       zclimp = zclim; 
   
 * ---------------  pilotage automatique ******************************** 
      ISNPB = FAUX ; 
      AL1 = 1. ;COEPI = 1.d0; COEINC=0.d0;COEPI0=1.d0;DAL1=100.D0; 
      CORPREC = 1. ; 
 *    CORPREC = 10.; 
      'SI' (('EGA' ipredic  'HPP') 'ET' WTAB.'CONV'); 
           EPS_EPS = 'TEXTE' 'LINEAIRE'; 
           HPP_EPS = VRAI; 
      'FINS'; 
 * 
      'SI' IPILOT ; 
           'SI' ( WTAB.'AUTODEUX' ) ; 
                 COEPI = 'ABS' ( STAB12.'AUTOCOEF'); 
                 COEPI = COEPI / (1.-COEPI); 
                 'SI' (COEPI > 1.D0) ; COEPI=1.D0;'FINS'; 
                 COEPI0=COEPI;STAB12.'AUTOCOEF'=COEPI; 
            'SINON'; 
                 STAB12.'AUTOCOEF' = 1.D0; 
            'FINS' ; 
            RED1 = 1. ; 
            RED2 = 0 ; 
            'SI' ('NEG' WTAB.'AUTORED1' 'INCONNU') ; 
                 'SI' (STAB12.'AUTORED1' > 0); 
                      STAB12.'AUTORED1' = STAB12.'AUTORED1' - 1; 
                      'SI' (STAB12.'AUTORED1' 'EGA' 0) ; 
                            COEPI = 3 *  COEPI ; 
                            STAB12.'AUTOREDU' = STAB12.'AUTOREDU' / 3.; 
                            'SI' (STAB12.'AUTOREDU' > 1.1 ); 
 *                      on travaille encore avec un critere reduit 
                                 STAB12.'AUTORED1' = 4 ; 
                                 RED1 = 3. ; 
                            'FINS'; 
                      'MESS' 'On multiplie le critere de pilotage par 3'; 
                      'FINS'; 
                 'FINS'; 
            'FINS'; 
            'SI' (COEPI > 1d0); 
                  RED1 = RED1 / COEPI ;COEPI =1d0; 
            'FINS'; 
            'SI' ( 'NEG' WTAB.'NBPLAS' 'INCONNU') ; 
                  'SI' ( WTAB.'NBPLAS' 'EGA' 0) ; 
                     'SI' (COEPI < 0.) ;COEPI = COEPI * -2.;'FINS'; 
                  'FINS'; 
            'FINS'; 
            COEPI = 'ABS' COEPI ; 
            COEPI0 = COEPI; 
 *    sans pilotage 
      'SINON'; 
            STAB12.'AUTOCOEF'= 1.D0; 
      'FINS'; 
   
 ************************************************************************ 
 *-------------    quelques initialisations  pour la boucle ETIQ ******** 
 ************************************************************************ 
      URG    = FAUX; RED_URG = 0 ; IT = 0 ; c_zdepr = faux;ITACC = 0; 
      ZICONV = VRAI; MMC     = 0 ; MMCMAX = 0 ; EPSM = 0.; DPSMAX = xpetit; dpsmaxp = dpsmax; 
      DEPSTDM  = 0. ;  DEKREAC1 = 0. ;XCONVNOR = 0. ; ITNORM1  = 0 ; 
      DEPSTREF = 100. * (WTAB . 'MAXDEFOR') ; 
      ZDEPL='EXCO' conti.'DEPLACEMENTS' 'LX' 'NOID' 'LX'; 
      GR_U_K   = GR_U_DEB ; 
      DITNORM1 = 0  ;NBCYCLE1 = 0  ; 
      zdept = zu1 - (zu1 'ENLE' 'LX'); 
      zdeptq = zdept; zdeptp = zdept; 
      zprecnc=1e-5;  FDEF = 0. ; ITNV = -5 ; 
      TABCONV = 'TABL'; 
      'SI' IFEFPUL; 
         XUPDA = 1; 
      'FINS'; 
   
 *********** Corrections en cas de materiaux variables **************************** 
       DEPST0=0 ; 
      'SI' WTAB.'MATVAR' ; 
        'SI' ('OU' ('OU' IENDOM IVIDOM) ICERAM); 
           XXX3 ='ELAS' ZMODL ZSIG0 ZMAT  ZVAR0; 
           XXX4 ='ELAS' ZMODL ZSIG0 ZMAT1 ZVAR0; 
        'SINON'; 
           XXX3 ='ELAS' ZMODL ZSIG0 ZMAT       ; 
           XXX4 ='ELAS' ZMODL ZSIG0 ZMAT1      ; 
        'FINS'; 
         DDEF0 = XXX4 - XXX3; 
        'DETR' XXX3; 
        'DETR' XXX4; 
         DEPST0=-1.* DDEF0; 
      'FINS'; 
   
 ***** En cas de chargement thermiques ********************************* 
       DMSRT0=0; 
      'SI' ITHER ; 
        'SI' (WTAB.'MATVAR' 'ET' IPILOT); 
          'MESS' 'Le pilotage n est pas possible avec un materiau qui depend de la temperature' ; 
          'ERREUR' 19 ; 
        'FINS'; 
   
        'SI' ('EGA' ('TYPE' TETA2) 'CHPOINT'); 
           MCHTETA2 ='CHAN' 'CHAM' TETA2 ZMODL 'STRESSES' 'TEMPERATURES' ; 
        'SINON'; 
           MCHTETA2 = TETA2; 
        'FINS'; 
         ETREF= 'REDU' WTAB.'ETREF' ZMODL ; 'COMM' 'REDU au cas ou le modele soit parallele'; 
         ETT  =('EPTH' ZMODL ZMAT MCHTETA2 ) - WTAB.'ETREF' ; 
         DTT  =  ETT '-' ETT0 ; 
   
        'SI' WTAB.'POR1'; 
 *------   Cas du milieu poreux avec chargement thermique ---------- 
 *         cas isotrope seulement pour le moment 
 *         et on  ne s'occupe pas du alpha-reference !! 
           MSRTT = PAS_EPTH PRECED ZMODL ZMAT MCHTETA2 ; 
           DMSRT0= MSRTT '-' MSRTT0 ; 
        'FINS' ; 
   
         DEPST0 = DTT '+' DEPST0 ; 
      'FINS'; 
   
 *     calcul de DSIGT0 et FTHE en cas de chargement si necessaire *********** 
       FTHE = 0 ; 
      'SI' (DEPST0 'NEG' 0); 
        'SI' ('OU' ('OU' IENDOM IVIDOM) ICERAM); 
           DSIGT0 = 'ELAS' ZMODL DEPST0 ZMAT ZVAR0; 
        'SINON'; 
           DSIGT0 = 'ELAS' ZMODL DEPST0 ZMAT      ; 
        'FINS' ; 
   
        'SI' (DMSRT0 'NEG' 0); 
           DSIGT0 = DSIGT0 '+' DMSRT0 ; 
        'FINS'; 
         FTHE ='BSIG' ZMODL DSIGT0 ZMAT ; 
      'FINS'; 
   
 *-------------- deformations imposes ==> contraintes imposees ********************************** 
      'SI' LOGDEF; 
            DDEFOR0 ='REDU' (STAB12.'DEFOR2' - STAB12.'DEFOR1') ZMODL; 
           'SI' ('OU' ('OU' IENDOM IVIDOM) ICERAM); 
              DSI1 = 'ELAS' ZMODL DDEFOR0 ZMAT ZVAR0; 
           'SINON'; 
              DSI1 = 'ELAS' ZMODL DDEFOR0 ZMAT      ; 
           'FINS'; 
            FDEF = 'BSIG' ZMODL DSI1 ZMAT ; 
      'FINS'; 
   
 *-------------- pression imposee et grands deplacements ?*************** 
      'SI' (LOGPRE 'ET' IGRD) ; 
        MOP = WTAB.'MOD_PRE' ; 
        ZPEXT0 = 'TIRE' WTAB.'CHARGEMENT' 'PRES' TEMPS0 ; 
        ZPEXTF = 'TIRE' WTAB.'CHARGEMENT' 'PRES' TI     ; 
 * 
        'SI' ('EXIS' WTAB 'MAT_PRE') ; 
           ZFPEXT0 = 'BSIG' MOP ZPEXT0 ('REDU' ZMAT11 MOP) ; 
           ZFPEXTF = 'BSIG' MOP ZPEXTF ('REDU' ZMAT22 MOP) ; 
        'SINON' ; 
           ZFPEXT0 = 'BSIG' MOP ZPEXT0 ; 
           ZFPEXTF = 'BSIG' MOP ZPEXTF ; 
        'FINS' ; 
        ZFP0F = 'COPIER' ZFPEXTF ; COEFP=1.D0; 
      'FINS'; 
   
 * ---------  ktangent et fefp****************************************** 
      'SI' IKTAN ; 
            'SI' IFEFP ; 
                 IKT_SAUV = VRAI ; 
                 'SI' ('NEG' WTAB.'LASTKTAN' 'INCONNU') ; 
                        'MESS' 'FEFP: Start with LASTKTAN' ; 
                      ZRIKTA = STAB12.'LASTKTAN' ; 
                      ZRAID = ZCLIM 'ET' ZRIKTA ; 
                 'SINON' ; 
                      'MESS' 'FEFP: Previous KTAN not available' ; 
                      ZRAID = ZRAID 'ET' ('KSIGMA' ZMODL ZSIG0 ZMAT) ; 
                 'FINS' ; 
            'SINON' ; 
                 'SI' ('NEG' WTAB.'LASTKTAN' 'INCONNU') ; 
                      IKT_SAUV = VRAI ; 
                      'SI' IPERT ; 
                          'MESS' 'Matrice tangente par perturbation - ' 
                          'Demarrage avec KTAN = LASTKTAN' ; 
                      'SINON' ; 
                          'MESS' 'Matrice tangente "coherente" - ' 
                          'Demarrage avec KTAN = LASTKTAN' ; 
                      'FINS' ; 
                       ZRIKTA = STAB12.'LASTKTAN' ; 
                       ZRAID = ZCLIM 'ET' ZRIKTA ; 
                 'SINON' ; 
                      'SI' IPERT ; 
                           IKT_SAUV='NEG' WTAB.'K_TANGENT_ITER0' 
                                    'MAT_ELASTIQUE'; 
                          'MESS' 'Matrice tangente par perturbation - ' 
                          'Demarrage avec KTAN = rigidite elastique' ; 
                      'SINON' ; 
                IKT_SAUV = ('NEG' WTAB.'K_TANGENT_ITER0' 'MAT_ELASTIQUE') 
                'ET' ('NEG' WTAB.'K_TANGENT_ITER0' 'MAT_TANGENTE') ; 
                          'SI' ('EGA' WTAB.'K_TANGENT_ITER0' 
                               'MAT_ELASTIQUE') ; 
                                'MESS' 'Matrice tangente "coherente" - ' 
                             'Demarrage avec KTAN = rigidite elastique' ; 
                          'SINON' ; 
                                'MESS' 'Matrice tangente "coherente" - ' 
                                'Demarrage avec KTAN (DTTAN = 0.)' ; 
                                DTTAN = 0. ; 
                                ZRIKTA = 'KTAN' ZMODL ZSIG0 ZVAR0 ZMAT 
                                     'PREC' ZPREK 'DT  ' DTTAN ZKTASYM ; 
                                ZRAID = ZCLIM 'ET' ZRIKTA ; 
                          'FINS' ; 
                      'FINS' ; 
                 'FINS' ; 
            'FINS' ; 
      'FINS' ; 
   
 *--------  en grands deplacements option K_SIGMA *********************** 
 * 
      'SI' (IGRD 'ET' ('NON' HPP_EPS)); 
        'SI' (IKSIA 'ET' ('NON' IFEFP)) ; 
           KSI1    ='KSIGMA' ZMODL ZSIG0 ZMAT; 
           ZRAIDINI= ZRAID           ; 
           ZRAID   = ZRAID 'ET' KSI1 ; 
        'FINS' ; 
      'FINS' ; 
   
 * Y a-t-il des forces non conservatives ( forces suiveuses)? *********** 
       ADDISEC0 = FAUX; 
       ADDISEC2 = FAUX; 
      'SI' WTAB.'PROCEDURE_CHARMECA'; 
 *       on ajoute l indice ADDI_MATRICE pour signaler a charmeca qu on 
 *       souhaite aussi l operateur linearis√© des Forces NL de charmeca 
         PRECED . 'ADDI_MATRICE' = vrai; 
         TFP22  = CHARMECA  PRECED   WTAB.'T_FINAL'; 
         PRECED . 'ADDI_MATRICE' = faux; 
 *   FP22 = F^suiv_n+1 
          DMZPRES = 0.D0 ; 
        'SI' ('EXIS' TFP22 'ADDI_SECOND') ; 
           FP22    = TFP22.'ADDI_SECOND'  ; 
           FP022   = 'COPIER' FP22        ; 
           MZPRES  = 'MAXI' 'ABS' FP22    ; 
           DMZPRES = MZPRES               ; 
           ADDISEC2= VRAI                 ; 
        'FINS'; 
        'SI' ('EXIS' TFP22 'ADDI_MATRICE'); 
           ZRAID = ZRAID 'ET' TFP22.'ADDI_MATRICE'; 
        'FINS'; 
   
 *  FP0 = F^suiv_n 
         TFP0 = CHARMECA  PRECED   TEMPS0 ; 
        'SI'('EXIS' TFP0 'ADDI_SECOND')   ; 
           FP0     = TFP0.'ADDI_SECOND'   ; 
           MZPRES0 = 'MAXI' 'ABS' FP0     ; 
           DMZPRES = DMZPRES '-' MZPRES0  ; 
           ADDISEC0= VRAI                 ; 
        'FINS'; 
 *      'SI' ('EXIS' TFP0 'ADDI_MATRICE'); 
 *         ZRAID = ZRAID 'ET' TFP0.'ADDI_MATRICE'; 
 *      'FINS'; 
         COEFP   = 1.D0              ; 
      'FINS'; 
   
   
 * -----------calcul de la partie constante du second membre  ********** 
 *                          en consolidation 
 *     ZFP1 est cense contenir : - B0*SIG0 et 
 *                                 DT*(1-TETA)*FI0 + DT*H*P 
 * 
 *     dans ZFCONSTA on met le second membre de u *********************** 
   
 *  en dynamique ******************************************************** 
 * ZFP1 est cense contenir : F0 + 4/DT*M*V0 - B0*SIG0 
      'SI' IDYN  ; 
         UNSURH  = 1.D0 '/' STAB12.'DT'    ; 
         ZFP1    = WTAB.'FREA1'            ; 
         ZDYFEXT = ZFCONSTA 'ENLEVER' 'FLX'; 
         ZFCONSTA= ZFCONSTA '+' ZFP1       ; 
      'FINS'; 
       ZFEXT     = ZFCONSTA 'ENLEVER' 'FLX'; 
   
 *---------deplacement (ou jeu) e imposer e la fin du pas ************* 
 * on separe les efforts ZFEXT (=F^ext_n+1)   *************************** 
 * et deplacement (ou jeu) ZFLX1 (u^imp_n+1) a imposer a la fin du pas 
      ZFLX1 = 'EXCO' ZFCONSTA 'FLX' 'NOID' 'FLX' 'NATURE' 'DISCRET'; 
      'SI' ('NEG' STAB12.'FFROT' 'INCONNU'); FFROT = STAB12.'FFROT'; 
      'SINON' ; FFROT=ZFEXT * 0; 'FINS'; 
      FFROTP = FFROT ; 
   
 *   calcul des forces externes deja equilibrees au debut du pas ******** 
 *   par B*SIGMA : ZF1 = F^int_n = B*sigma_n + K^cst*u_n 
      ZF1 = 'BSIG' ZMODL ZSIG0 ZMAT1; 
      'SI' IRCON; 
            ZF1 = ZF1 '+' ('REDU' MAI_CONS (RIG_CONS '*' ZU1)); 
      'FINS'; 
      'SI'  IDYN  ;  FFDYN = 'COPIER' ZF1; 'FINS'; 
      'SI' ISOL ; 
            GRAP0= 'GRAD' MO_POR ZU1 MA_POR0 'CONS' ; 
            XXX1 = 'GRAD' MO_POR ZU1 MA_POR  'CONS' ; 
            XXXS =((1.- WTAB. 'TETA' )*GRAP0)+ (WTAB. 'TETA' * XXX1); 
            XXX2 = STAB12.'DT' * ('GNFL' MO_POR XXXS) ; 
            XXX3 = ZF1  ; 
            ZF1  = XXX3 - XXX2;'DETR' XXX3; 
            'DETR' XXX2 ; 
      'FINS'; 
   
 * initialisation des variables forces et deplacement******************* 
 * zzd est le deplacement au pas precedent   (=u_n)  et ZLX=lambda_n 
      ZZD ='ENLE' ZU1 'LX'; 
      ZLX = ZU1 'EXCO' 'LX' 'NOID' 'LX' 'NATURE' 'DIFFUS'; 
 * ---------  flxini est la partie des FLX deja realisee au debut du pas 
 **pv     FLXINI= ZZD '*' ZCLIM; 
 * FREAP  : -1*reactions du pas precedent    (=F^reac_n) transportees sur les nou 
 **pv     FREAP = ZLX '*' ZCLIM; 
     FZU1 = ZU1 '*' ZCLIM; 
     FLXINI = FZU1 'EXCO' 'FLX' 'NOID' 'FLX' 'NATURE' 'DISCRET'; 
     FREAP  = FZU1 'ENLE' 'FLX'; 
   
   
      FEXT0 = ZF1 '+' FREAP; 
 * FEXT0 est le chargement externe (sans reactions vu par la 
 * structure le pas d'avant)   = F^ext_n = F^int_n - F^reac_n 
 * 
 *  on va calculer le premier residu c'est a dire le desequilibre ******* 
 *  entre les forces externes et le calcul B*SIGMA. 
 *  le sigma qui sert est celui qui existerait si le champ de 
 *  deplacement ne changeait pas (ZU1). faire attention aux FLX 
 *  En pilotage on reprend ce residu que l'on multiplie par COEPI 
 *  XXX1 = [F^ext_n+1 ; Du^imp] 
 *  DFEXT0 = increment des forces et des FLX a imposer (le residu 
 *  du pas precedent) = [DF^ext ; Du^imp] 
      XXX1   = ZFCONSTA '-' FLXINI ; 
      DFEXT0 = XXX1     '-' FEXT0  ; 
   
 * si pression suiveuse dfext0 contient en plus l'increment des forces 
 * de pression du uniquement a la reactualisation de la geometrie (sans 
 * augmentation du module) 
 * mais comme F^int_n equilibre deja F^ext_n + F^suiv_n +... et qu'on est 
 * toujours sur config_n, on doit avoir : DFEXT0= [DF^ext ; Du^imp] 
 * avec DF^ext qui ne contient pas de forces suiveuses (...a v√©rifier) 
     'SI' ADDISEC0; 
        DFEXT0 = DFEXT0 '+' FP0     ; 
     'FINS'; 
     'SI' (LOGPRE 'ET' IGRD) ; 
        DFEXT0 = DFEXT0 '+' ZFPEXT0 ; 
     'FINS' ; 
      DFEXT0F = DFEXT0 'ENLEVER' 'FLX'; 
      DFEXT0L = DFEXT0 'EXCO' 'FLX' 'NOID' 'FLX'; 
   
 *    DFEXT0 = [DFEXT0F ; DFEXT0L] 
 *           = [F^ext_n+1 - (F^int_n - F^reac_n - F^suiv_n) ; Du^imp] 
 *    RESIDU = forces exterieures sans reactions 
 *            (avec des termes supplementaires le cas echeant p.ex. en 
 *             dynamique ou en poreux) - forces interieures 
 *    et increment des relations imposees 
 *             ---> la resolution fournira dU et dR 
   
 *     RESIDU = [F^ext_n+1 + F^ther_n+1 + F^defi_n+1 - F^int_n ; Du^imp] 
       RESIDU =  XXX1     '+'FTHE      '+'FDEF      '-'ZF1; 
       ZDFINI ='COPIER' DFEXT0          ; 
       ZFPLO  = ZF1 '-' FTHE '-' FDEF   ; 
      'SI' (ITHER 'OU' WTAB.'MATVAR'); 
         ZDFINI=ZDFINI '+' FTHE; 
      'FINS'; 
      'SI' LOGDEF; 
         ZDFINI= ZDFINI '+' FDEF; 
      'FINS'; 
      'SI' (LOGPRE 'ET' IGRD) ; 
         RESIDU = RESIDU '+' ZFPEXTF ; 
         ZDFINI = ZDFINI '+' ZFPEXTF '-' ZFPEXT0 ; 
      'FINS'; 
   
      'SI' ADDISEC0 ; 
         ZDFINI = ZDFINI '-' FP0 ; 
      'FINS'; 
   
      'SI' ADDISEC2 ; 
 *       mess ' fp22 ' ; list resu fp22; 
         RESIDU = RESIDU '+' FP22 ; 
 *       on tient compte de l'increment des forces suiveuses en direction 
 *       et en module 
         ZDFINI = ZDFINI '+' FP22 ; 
      'FINS'; 
   
 * ici, on a : 
 * RESIDU = [F^ext_n+1 + F^ther_n+1 + F^defi_n+1 + F^suiv_n+1 
 *           - F^int_n  ;  Du^imp] 
 *        = [ DF^tot ; Du^imp] 
 * ZDFINI = [F^ext_n+1 + F^ther_n+1 + F^defi_n+1 + F^suiv_n+1 
 *           - (F^int_n - F^reac_n)  ;  Du^imp] 
 * 
       IMPO12= FAUX; 
       IMPO12U = FAUX; 
       XXX1  ='EXTR' ZCLIM 'MAIL' 'UNIL'; 
      'SI' (('NBEL' XXX1) '>' 0); 
         IMPO12 = VRAI; 
         IMPO12U = VRAI; 
         DIMPO12='REDU' DFEXT0L XXX1 ; 
         DIMPOV = DFEXT0L '-' DIMPO12; 
      'FINS'; 
       stab12.'SECOND_MEMBRE' = RESIDU '*' 1.D0; 
   
   
 ************************************************************************ 
 ***               1ERE RESOLUTION                                    *** 
 ************************************************************************ 
      FEXCI = 'VIDE' 'CHPOINT' / 'DISCRET' ; 
      'SI' (WTAB.'ADHERENCE') ; 
        'SI' ('EXIS' WTAB 'MAIL_BLOM') ; 
          FADRE = 'REDU' FADHE WTAB.'MAIL_BLOM' ; 
        'SINON' ; 
          FADRE = FADHE ; 
        'FINSI' ; 
        FEXCI = FEXCI 'ET' FADRE ; 
      'FINSI' ; 
 * 
      'SI' (WTAB.'CAFROTTE') ; 
        FEXCI = FEXCI 'ET' FFROT ; 
      'FINSI' ; 
 * 
   
      'SI' LOGPIL ; 
 *    Modification du residu 
         RESIDU = RESIDU 'ET' (ETA0 '*' ZFPILIN); 
     'FINSI' ; 
   
      'SI' ('EXIS' STAB12 'RIBLO_M' ) ; 
          'SI' ((WTAB.'CAFROTTE' 'OU' WTAB.'ADHERENCE') 'ET' IMPO12); 
             ZDEP1 BID BID BID BID = 'RESO' ZRAID 'SOUC' RESIDU 'INIB' 
                                             STAB12.'RIBLO_M' 
                                             STAB12.'LISEA_M' FEXCI ; 
          'SINON'; 
             ZDEP1 BID BID BID     = 'RESO' ZRAID 'SOUC' RESIDU 'INIB' 
                                             STAB12.'RIBLO_M' 
                                             STAB12.'LISEA_M'      ; 
          'FINS'; 
          'OUBLIER' STAB12 'RIBLO_M'; 
      'SINON'; 
          'SI' ((WTAB.'CAFROTTE' 'OU' WTAB.'ADHERENCE') 'ET' IMPO12U); 
                ZDEP1 = 'RESO' ZRAID 'SOUC' RESIDU FEXCI ; 
          'SINON'; 
                ZDEP1 = 'RESO' ZRAID 'SOUC' RESIDU; 
          'FINS'; 
      'FINS'; 
   
      'SI' LOGPIL ; 
        ZDEPII= 'RESO' ZRAID ZFPILIN ; 
        ZDEPILO = 0. * ZDEPII ; 
 *    Calcul de D_eta par appel a la procedure PILOINDI 
            D_ETA = PILOINDI PRECED ZU1  ZDEPILO ZDEP1 ZDEPII DTAU; 
 *    Mise √† jour 
            ZDEP1 = ZDEP1 '+' (D_ETA '*' ZDEPII) ; 
        ETA = ETA0 ; 
     'FINSI' ; 
   
   
       ZRAID_T = 'EXTR' ZRAID 'CONT'; 
   
      'SI'  IDYN; 
         STAB12.'ZRAIDV'= ZRAID; 
      'FINS'; 
   
      'SI' ('EXIS' ZRAID_T 'NITER'); 
           STAB12.'RIBLO_M' = ZRAID_T. 7 ; 
           STAB12.'LISEA_M' = ZRAID_T. 6 ; 
      'FINS'; 
 *  pour eventuel calcul de augauto 
  zdep1d = zdep1 'ENLE' 'LX'; 
 *  et initialisation zdepl (sert pour xnum) 
  ZDEPL = 'EXCO' ZDEP1 'LX' 'NOID' 'LX' ; 
 * On sauve le deplacement initial pour la convergence forcee *********** 
      'SI' ('EXIS' WTAB 'DEPI'); 
         zdeptini = WTAB.'DEPI'; 
      'SINON'; 
         zdeptini = zdep1; 
      'FINS'; 
 * 
 *        calcul d'une norme pour la convergence************************** 
 * 
       XXX1= ZFEXT; 
      'SI' ADDISEC2; 
        XXX1=ZFEXT + FP22; 
      'FINS'; 
      'SI' (LOGPRE 'ET' IGRD) ; 
        XXX1 = ZFEXT + ZFPEXTF ; 
      'FINS'; 
   
   
      'SI' LOGPIL ; 
 *    Modification du chargement 
         XXX1 = XXX1 '+' ((ETA '+' D_ETA) '*' ZFPILIN); 
     'FINSI' ; 
   
   
      ZDEP1P50 = ZDEP1       ; 
      XDENO='XTY' ZDEP1P50  ( XXX1 -( RESIDU  'EXCO' 
         'FLX' 'NOID' 'FLX' 'NATURE' 'DISCRET')) MLPRIM MLDUAL; 
      'SI' ('VERI' xdeno) ; 'SINON'; xdeno = 1; 'FINSI'; 
      MZDEP1M = 'MAXI' ZDEP1P50 'ABS' 'AVEC' MLDEPL; 
      MZFM = 'MAXI' (FTHE + FDEF + ZF1) 'ABS' 'AVEC' MLDUAL; 
      XDENO1 = 'ABS' XDENO  + (MZFM * MZDEP1M); 
      MZDEP1M = MZDEP1M + XPETIT; 
      XDENO=XDENO1/MZDEP1M; 
      XDENO = XDENO + MZFM; 
      XDENO = XDENO + XPETIT       ; 
      XDENOM=XDENO; 
      'SI' TSTMOM ; 
         ZDEP1P50 = ZDEP1 + XPETIT;          ; 
         XDENOM = XDENO1/('MAXI' ZDEP1P50 'ABS' 'AVEC' MLROTA); 
      XDENOM = XDENOM + XPETIT       ; 
      'FINS' ; 
      'SI' IPILOT ; 
            'SI' ( WTAB.'AUTODEUX' ) ; 
               XDENO = STAB12.'XDENO'; 
               XDENOM = STAB12.'XDENOM'; 
            'FINS'; 
      'FINS'; 
      'SI' ('NON' WTAB.'CONV'); 
 *        'MESS' 'non convergence on garde xdeno xdenom ' xdeno xdenom; 
             'SI' (XDENO < STAB12.'XDENO'); XDENO = STAB12.'XDENO'; 'FINSI'; 
             'SI' (XDENOM < STAB12.'XDENOM'); XDENOM = STAB12.'XDENOM'; 'FINSI'; 
      'FINS'; 
   
      IAFAIR=FAUX; 
      'SI'  WTAB.'CONV'; 
      STAB12.'INCREMENT' = 'COPIER' ZDFINI ; 'FINS'; 
      RESIDNOR = 'COPIER' RESIDU ; 
      'SI' IPILOT; 
             XXX3=DFEXT0F * ( 1-COEPI) ; 
             XXX2 = ZFEXT - XXX3;'DETR' XXX3; 
            'DETR' ZFEXT; ;ZFEXT = XXX2; 
             XXX1 = RESIDU * COEPI; 'DETR' RESIDU; 
             XXX2 = 1.D0 -COEPI * FREAP;RESIDU = XXX1 + XXX2; 
            'SI' IMPO12; 
                 RESIDU = 1.D0 - COEPI * DIMPO12 + RESIDU; 
            'FINS'; 
            IAFAIR=VRAI; 
      'FINS'; 
 * 
 *  petite correction du residu pour esperer gagner du temps ************ 
 * 
      INIT = FAUX ; 
      'SI'(('NEG' STAB12.'FNONL' 'INCONNU') 'ET' 
            (WTAB.'INITIALISATION')); 
         'SI' IPILOT; 
               'SI' ( WTAB.'AUTODEUX' 'ET' (COEPI 'NEG' 1.D0)) ; 
               'MESS' 'Initialisation a partir du pas precedent '  COEPI; 
                     IAFAIR=VRAI; INIT = VRAI; 
                      XXX1= RED1 * STAB12.'FNONL'; 
                      XXX2= XXX1 + RESIDU ; 
                     'DETR' RESIDU ;'DETR' XXX1 ;RESIDU =XXX2; 
                'FINS' ; 
         'SINON'; 
 * on fait la correction si le pas precedent a converge sans non convergence 
             'SI' (WTAB.'CONV' 'ET' (ISOUSPPP 'EGA' 0)); 
 * on fait la correction si le pas precedent etait non lineaire. 
               'SI' (('MAXI' 'ABS' STAB12.'FNONL') > (ZPREC * XDENO)) ; 
 * on enleve le residu du pas precedent pour recuperer l'increment 
 * nominal du second membre e imposer f1. 
 * f2 et l'increment du second membre du pas precedent 
                 STAB12.'INCREMENT'=STAB12.'INCREMENT' - STAB12.'RESIDU'; 
                     zdeps = WTAB.'ZDEP1' + zdep1; 
                     FFNO= 'XTY' STAB12.'FNONL' zdeps  MNDUAL MNPRIM; 
                     F1 = STAB12.'INCREMENT' ; 
                     F2 = INCRPREC ; 
                     f12 = 'XTY' f1 zdeps MNDUAL MNPRIM; 
                     f22 = 'XTY' f2 zdeps MNDUAL MNPRIM; 
                     AMPL = f12/(f22 + XPETIT); 
                     DTPREC=1E30; AMPLT = 0; 
                     'SI' ('NEG' STAB12.'DTPREC' 'INCONNU'); 
                          DTPREC = STAB12.'DTPREC'; 
                          'SI' (DTPREC > XPETIT); 
                              AMPLT=WTAB.'DT_INIT' /DTPREC; 
                          'FINS'; 
                      'FINS'; 
 *  Le chargement n'est il pas de fluage ou de thermique ?'; 
                     XDCOMP = ('XTY' ZDEP1 F1 MNPRIM MNDUAL) ; 
                    'SI' (('ABS' XDCOMP) < (ZPREC * XDENO * mzdep1m) 
                         'OU' (('ABS' FFNO) > (('ABS' F22) * 2.e2   ))); 
                         DTPREC = STAB12.'DTPREC'; 
                         AMPL=AMPLT; 
 * la decharge est-elle significative 
                       'SI'((F12/(f22 + XPETIT)) < -0.05);ampl=0.;'FINS'; 
                         STAB12.'INITEMPS'=VRAI;LOGTEMP=FAUX;; 
                         'MESS' 
 'Pas d increment de charge, initialisation calculee avec le temps'; 
                    'SINON'; 
                         AMPL = F12 / (F22 + XPETIT); 
                         LOGTEMP=STAB12.'INITEMPS'; 
                         STAB12.'INITEMPS'=FAUX; 
                    'FINS'; 
 * changement de modele on n'initialise pas 
                    'SI' ('NEG' ZMODLI ZMODLP);  AMPL = 0; 'FINSI'; 
   
                     AMPL = MINI (prog AMPL AMPLT); 
                    'SI' ((AMPL > 0) 'ET' (AMPL < 2e1)) ; 
       'MESS' 'Initialisation a partir de la solution precedente Coeff' 
                          AMPL; 
                          XXX1 = AMPL * STAB12.'FNONL'; 
                          XXX2 =RESIDU+ XXX1; 
                          'DETR' XXX1;'DETR' RESIDU; 
                          RESIDU = XXX2; 
                          IAFAIR=VRAI; INIT = VRAI; 
                    'FINS'; 
               'FINS'; 
             'FINS'; 
         'FINS'; 
      'FINS'; 
      WTAB.'ZDEP1'=zdep1; 
 * 
 *  initialisation en plastique ***************************************** 
 * 
      'SI' IPLAVI ; 
           'SI' ('NEG' WTAB.'MOVA' 'RIEN') ; 
                   ACC0 = 'EXCO' (WTAB.'MOVA') ZVAR0 ; 
           'FINS' ; 
      'FINS' ; 
 * 
 *    debut des iterations internes boucle etiquette ******************** 
 * 
      IKT =  FAUX ; 
      IPREM =  VRAI ; RECA_K = FAUX; RECA_N = 0; 
      DEPST  = 'ZERO' ZMODL 'DEFORMATIONS' ; 
      DEPSTP = depst ; 
      DEPSTK = DEPSTP ; 
 * 
 *       initialisation acceleration de convergence ******************** 
 * 
      iafair = vrai; 
      PASTEST = FAUX; 
      ZITAC= 0 ; 
 *     on peut mettre n'importe quoi c'est pour 
 *     ne pas faire de tests dans la boucle 
      ACFP1  = 'COPIER' ZFEXT2 *0. ; 
      ACFP2  = ACFP1 ; 
      ZDEPLD = ACFP1 ; 
      ACFP3  = ACFP1 ; 
      ACFEP1 = ACFP1 ; 
      ACFEP2 = ACFP1 ; 
      FCORF  = 'COPIER' FREAP; 
 * initialisation du meilleur critere 
      XCONVMIN = 1e20; 
      DPSMREF  = 0  ; 
      XCONV    = 0. ; 
      XCONVP   = 1. ; 
      NSOINCR  = 1  ; 
      'SI' ('NEG' WTAB.'SOUS_INCREMENT'  'INCONNU') ; 
          NSOINCR = WTAB.'SOUS_INCREMENT' ; 
      'FINS'; 
      NONCONV = FAUX; 
      CORREC=0; 
      PASREINI=VRAI; 
      coefmt=1.; 
 * 
 * initialisation des messages pour l'iteration en cours **************** 
 * 
      'SI' IKLFFF ; 
           'MESSAGE' 
 'Iter'*13   'Nplas'*26    'Critere'*39        'Deps.max'*52       'Eps.max'*65      'Crit.flex'*78 
 ; 
      'SINON'; 
          'MESSAGE' 
 'Iter'*13   'Nplas'*26     'Fresidu'*39        'Deps.max'*52       'Eps.max'*65      'Mresidu'*78 
 ; 
      'FINS'; 
  INSTAB = FAUX; 
 RESIDIN = RESIDU * 1.; 
 hpp_exit = faux; 'SI' hpp_eps; hpp_exit=vrai; 'FINSI'; 
   
 *======================================================================= 
 *======= DEBUT DE LA BOUCLE DE CONVERGENCE                       ======= 
 *======================================================================= 
 *  trac cach v1 nclk; 
 *  trac (surf1 et surf2 et surf3 et _rext et _rint) nclk; 
 *  trac cach (engr1 et engr2) nclk; 
 dpsmaxp = 0; 
   
 IT_RECA = 0; 
 depst = depst * 0; 
 depstp = depst; 
 'REPETER'  ETIQ ; 
 resmul = 2. * resmul; 
 'SI' (resmul > 1.0); resmul = 1.0; 'SINON'; itacc = 4; 'FINSI'; 
 **resmul = 1.; 
 *  sauvegarde des etats sur la configuration debut de sous-increment: geom1 
 *  mise a jour apres la sortie de etiq 
 zdeptp = zdept; 
 depstp = depst; 
 zsig0 = zsig0_1; 
   
 INSTAB = FAUX; 
   
 nconvr = faux; 
 *IT est le compteur de ETIQ, ITACC doit etre =< 0 pour qu'on accelere 
 IT= IT + 1 ; 
 ITACC = ITACC - 1; 
 ZITAC = ZITAC + 1 ; 
 * 
 *--------------------------------------------------------------------- 
 *           La force motrice de l'iteration est fixee: RESIDU 
 *           on va calculer un nouveau champ de deplacement 
 * 
 *   calcul de l'increment de l'increment de deplacement zdep1 
 *   par resolution lineaire 
 *----------------------------------------------------------------------- 
 * 
 *  petits travaux pour acceleration de convergence 
 * 
 CORRECP = CORREC; 
 CORREC = 0; 
 PASTEST=FAUX; 
 ACFP0 = (RESIDU  - FCORF) 'ENLE' FLX ; 
 ACFEP0 = ACFP0; 
 ACFEP0 = ACFEP0 - CORRECP ; 
 'SI' IGRD ; 
   'FORM' GEOM1; 
 *  rem : 0.1 est la valeur par defaut de EKREAC (= . 'REAC_GRANDS') 
   'SI' ((IT > 1) 'ET' (URG 'OU' (ITACC > 3) 'OU' INSTAB 'OU' 
   (('MULT' (IT - IT_RECA)  ITRCLC) 'ET' ('NON' HPP_EPS)))); 
   URG = FAUX; 
       IT_RECA = IT; 
       dekreac1 = 0; 
       INSTAB = FAUX; 
       URG=FAUX; 
         PASREINI=FAUX; 
       GEOR ZMATTEMP = 'FORM' ZDEPT   ZMODLI  ZMATI ; 
 *     A cause de FORM, ZMATTEMP n'est plus parallele... 
       ZMATTEMP = 'REDU' ZMATTEMP ZMODL; 
       zdepr = zdept; 
       c_zdepr = faux; 
       RECA_K = VRAI; 
       RECA_N = RECA_N + 1; 
   
      'SI' (RECA_N > 20) ; 
         nonconv = vrai; 
      'FINS'; 
   
       txt_k ='CHAI' ' Recalcul de K (= K^el'; 
        'SOUC' 0; 
        'SI' ((LAG_TOT 'EGA' 1) 'ET' vrai); 
           'FORM' GEOREF0; 
           HOOKRH = 'HOOK' ZMODL ZMATI; 
           HOOKRH2 = 'PICA' HYPDEF HOOKRH ZMODL (ZU1 + ZDEPT); 
           'FORM' GEOR; 
           RITC = 'RIGI' HOOKRH2 ZMODL zmattemp 'NOER'; 
           'DETRUI' HOOKRH; 
           'DETRUI' HOOKRH2; 
           'FORM' GEOM1; 
        'SINON'; 
          ritc  ='RIGI'   zmodl zmattemp 'NOER' ; 
        'FINSI'; 
       PASOK = 'SOUCI'; 
       'SI' PASOK; 
          'MESS' 'rigi rate. on reessaye avec la configuration geom1'; 
          'FORM' GEOM1; 
          ritc  ='RIGI'   zmodl zmatI ; 
       'FINSI'; 
   
   
   
       ZMATTEMP = 0 ; 
   
 *     RH peut contenir des CL 
       ZRI = 'EXTR' RITC 'RIGI' 'NOMU' ; 
       ZCL = 'EXTR' RITC 'RIGI' 'MULT' ; 
       'SI' ('NEG' ('DIME' ZCL) 0) ; 
         ZCLIM = ZCLIM0 'ET' ZCL ; 
       'SINON' ; 
         ZCLIM = ZCLIM0 ; 
       'FINSI' ; 
   
       BFCONT  = FAUX                       ; 
       BCLIM2  = FAUX                       ; 
      'SI' WTAB.'CONTACT'; 
 *       recalcul raideur de contact et jeu 
 *   Maintenant, on veut la configuration finale pour les directions et les jeux 
   'FORM' GEOM1; 
   'FORM' ZDEPT ; 
         MODCON  = wtab.'MODCONTA'; 
        'SI' ('EXIS' WTAB 'MATCONTA'); 
           MODFRO matfro CJEU CRR RFROT='RFCO' MODCON  WTAB.'CONV'  WTAB.'MATCONTA'; 
        'SINON' ; 
           CJEU CRR RFROT='RFCO' MODCON  WTAB.'CONV'                ; 
        'FINS' ; 
   
        'SI' ('NEG' 0 CJEU) ; 
          FADHE = 'EXCO' CJEU 'FADH' 'NOID' 'FADH' ; 
          CDAP  = 'EXCO' CJEU 'FLX'  'NOID' 'FLX' ; 
        'FINSI' ; 
   
        'SI' (WTAB . 'MODAL') ; 
           CRR  = 'PJBA' CRR  ZMODL MMMM ; 
           MCRR = 'EXTR' CRR 'MAIL' 'MULT' ; 
           MCDAP = 'EXTR' CDAP 'MAIL' ; 
   
          'REPETER' BCDA ('NBNO' MCDAP) ; 
             PBCDA = MCDAP 'POINT' &BCDA ; 
             PCRR  ='POINT' MCRR &BCDA   ; 
             CHCR  ='MANU' 'CHPO' PCRR 1 'FLX' ('EXTR' CDAP 'FLX' PBCDA) 
                    'NATURE' 'DISCRETE' ; 
            'SI' ('EGA' 1 &BCDA) ; 
               CCDA = CHCR ; 
            'SINON' ; 
               CCDA = CCDA 'ET' CHCR ; 
            'FINS' ; 
          'FIN' BCDA ; 
   
           CDAP = CCDA ; 
        'FINS' ; 
   
 *       ATTENTION : mettre les conditions de frottement en premier pour 
 *                   les numeroter en dernier 
         ZCLIM2 ='VIDE' 'RIGIDITE'           ; 
         ZFCONT ='VIDE' 'CHPOINT' / 'DISCRET'; 
         CDEP = (ZU1 'ENLE' 'LX')  + ZDEPT; 
         CDEPSLX ='ENLE' CDEP 'LX'              ; 
         CDEPLX  = CDEP 'EXCO' 'LX' 'NOID' 'LX' ; 
        'SI'  ('NEG' CRR 0); 
           BCLIM2 = VRAI                ; 
           BFCONT = VRAI                ; 
           ZCLIM2 = CRR    'ET' ZCLIM2  ; 
           CCOR   = CRR '*' CDEPSLX     ; 
           ZFCONT = ZFCONT '+'  CCOR    ; 
        'FINS'; 
   
        'SI' ( 'NEG' 0 CJEU); 
           BFCONT = VRAI                ; 
           ZFCONT = ZFCONT '+'  CDAP    ; 
        'FINS'; 
   
        'SI' ('NEG' 0 RFROT); 
           BCLIM2 = VRAI                ; 
           BFCONT = VRAI                ; 
           ZCLIM2 = RFROT  'ET' ZCLIM2  ; 
           CCOR   = RFROT  '*'  CDEPSLX ; 
           ZFCONT = ZFCONT '+'  CCOR    ; 
        'FINS'; 
   
 *      Mise a jour de ZCLIM, ZFCONSTA et RESIDU si necessaire 
        'SI' BCLIM2; 
          ZCLIM  = ZCLIM2 'ET' ZCLIM             ; 
   
 *  pas de correction a faire sur residu car il est hors reactions pour qu'elles 
 *  sortent en total a la resolution incrementale 
        'FINS'; 
   
      'FINS'; 
   
      'SI' BFCONT; 
         ZFCONSTA = ZFEXT2 '+' ZFCONT; 
      'SINO'; 
         ZFCONSTA = ZFEXT2           ; 
      'FINS'; 
       ZFCONST1 = ZFCONSTA; 
   
          zclimp = zclim; 
   
      'SI' IDYN; 
         ZFCONSTA = ZFCONSTA '+' ZFP1  ; 
      'FINS'; 
   
       ZFLX1 = 'EXCO' ZFCONSTA 'FLX' 'NOID' 'FLX' 'NATURE' 'DISCRET'; 
       ZRAID =  ZCLIM 'ET' ZRI; 
 *  repasser sur la configuration de calcul des raideurs 
      'FORM' geor; 
      'SI' iksia ; 
         sigttcca ='PICA' HYPDEF ZMODL ZSIGF ZDEPT ; 
         ksigtc= 'KSIGM' sigttcca zmodl zmat; 
         ZRAID= ZRAID 'ET' ksigtc; 
      'FINS'; 
      'SI' IRCON; 
         ZRAID = ZRAID 'ET' RIG_CONS; 
         txt_k = 'CHAI' txt_k ' + K^cst'; 
      'FINS'; 
 *  remise a jour impo12 
       IMPO12= FAUX; 
       IMPO12U = FAUX; 
       XXX1  ='EXTR' ZCLIM 'MAIL' 'UNIL'; 
      'SI' (('NBEL' XXX1) '>' 0); 
         IMPO12U = VRAI; 
      'FINS'; 
       XXX1  ='EXTR' ZCLIM 'MAIL' 'UNIL'; 
      'SI' (('NBEL' XXX1) '>' 0); 
         IMPO12 = VRAI; 
         DIMPO12='REDU' DFEXT0L XXX1 ; 
         DIMPOV = DFEXT0L '-' DIMPO12; 
      'FINS'; 
 * pv 
      'SI' IRAUG; 
 * xksx = xtmx zdep1d  ksigtc ; 
 *'SI' ((abs xksx) < xpetit ); 
 *      zdep1d = (zu1 + zdept) 'ENLE' 'LX'; 
 *      xksx = xtmx zdep1d  ksigtc ; 
 *'FINSI'; 
   
  'SI'  iprem; zdep1d = zu1 'ENLE' 'LX'; 'FINSI'; 
   xkx = (xtmx zdep1d rh)  + xpetit; 
   xmx = (xtmx zdep1d rig_aug) + xpetit; 
   'SI' (('VERI' xkx) 'ET' ('VERI' xmx) 'NON'); 
     zu1l = zu1 'ENLE' 'LX'; 
     xkx = (xtmx zu1l rh)  + xpetit; 
     xmx = (xtmx zu1l rig_aug) + xpetit; 
   'FINSI'; 
 'SI' faux; 
   xktx = xty zdep1d acfp0  mnprim mndual; 
   xksx1 = xkx - xktx; 
 *  'SI' (xksx1 > xksx); xksx = xksx1 ; 'FINSI'; 
    xksx = xksx1; 
   'SI' (('VERI' xksx) 'ET' ('VERI' xkx) 'ET' ('VERI' xmx) 'NON'); 
     zu1l = zu1 'ENLE' 'LX'; 
     xkx = xty zu1l (rh * zu1l) mnprim mndual + xpetit; 
     xmx = xty zu1l (rig_aug  * zu1l) mnprim mndual + xpetit; 
     xksx = xkx; 
 **   xksx = xty zu1l (ksigtc * zu1l) mnprim mndual; 
   'FINSI'; 
 * si les coef sont negatif, c'est qu'on n'est pas instable sur ce mode 
  'SI' ((abs xksx) > xpetit ); 
     augauto = xksx / xmx  ; 
     augk= xksx /xkx  ; 
  'SINON'; 
   mess ' abs xksx ' (abs xksx) ' max zdep1d ' (maxi abs zdep1d); 
   
  'FINSI'; 
 'FINSI'; 
 *'SI' iprem; 
       augauto = xkx / xmx; augk = 1.; 
 *'FINSI'; 
   
   
       augauto = abs augauto; 
       augk = abs augk; 
   
       augmult = augmult * 1.02; 
       'SI' (augmult > 1D4 ); augmult=1D4 ; 'FINSI'; 
   
       augauto = augauto * augmult ; 
       augk = augk * augmult; 
   
   
 'SI' (iraug 'ET' autaug) ; 'MESS' 'multiplicateur d augmentation masse' augauto ' raideur' augk ; 'FINSI'; 
         ZRAIDNA=  ZRAID ; 
        'SI' AUTAUG; 
         ZRAID = ZRAID 'ET' (RIG_AUG * augauto) 'ET' (RH * augk) ; 
        'SINON'; 
         ZRAID = ZRAID 'ET' RIG_AUG ; 
 ***      'MESS' ' augmentation residuelle '; 
        'FINSI'; 
   
         txt_k = 'CHAI' txt_k ' + K^aug'; 
 ***     ZNACCE = FAUX; 
   
     'SINON'; 
       augmult = augmult * 0.55 ; 
 'SI' iraug; 'MESS' 'nouveau augauto augmult' ' ' augauto augmult;  'FINSI'; 
      'SI' IRAUGLU; 
         zraid = zraid 'ET' rig_aug; 
      'FINSI'; 
     'FINSI'; 
 ***     'FINS'; 
   
      'SI' WTAB.'PROCEDURE_CHARMECA'; 
         PRECED . 'ADDI_MATRICE' = vrai; 
         TFP22= CHARMECA  PRECED   WTAB.'T_FINAL'; 
         PRECED . 'ADDI_MATRICE' = faux; 
        'SI' (EXIS TFP22 'ADDI_MATRICE'); 
           zraid = zraid 'ET' TFP22.'ADDI_MATRICE'; 
           txt_k = 'CHAI' txt_k ' + K^cent'; 
        'FINS'; 
      'FINS'; 
   
      'SI' IDYN; 
 *      bp : en toute rigueur, il faudrait aussi recalculer la MASSE ... 
 *           et ajouter l'amortissement le cas √©ch√©ant ... 
         MMA  = WTAB.'MASSE' '*' ( 4.D0 '/' WTAB.'DT' '/' WTAB.'DT'); 
         ZRAID= ZRAID 'ET' MMA; 
       'FINS'; 
       'MESS' ( 'CHAI' txt_k ' ) dans config deformee ' DEKREAC1 ); 
       'FORM' GEOM1; 
 *      on impose le recalcul de K a la prochaine iteration si it=2 
       'SI' (IT 'EGA' 2) ; 
          ITACC = 5 ; 
       'SINON'; 
 *  pas de raison d'interferer avec les accelerations de convergence 
 *****    ITACC = 1 ; 
       'FINS' ; 
        GR_U_K  = GR_U_FIN ; 
        zdeptm = zdept ; 
   'FINS'; 
 'FINS'; 
   
 * 
 *  acceleration de convergence effective ------------------------------ 
 * 
 ACCEL = FAUX; 
 'SI' (('NON' instab) 'ET' (ITACC '<EG' 0) 'ET' (IT '>' 3) 'ET' ZNACCE ); 
  ITACC = 2; 
  ACCEL = VRAI; 
    CORREC = 'ACT3' ACFEP2  ACFEP1 ACFEP0 
                    ACFP3   ACFP2  ACFP1  ACFP0 ; 
   'SI' (wtab.'STABILITE' 'ET' ('NON' HPP_EPS)); 
 *    verif que l'acceleration ne renvoie pas en arriere 
   
   
   
      acc_ref = xty (acfp0         ) zdep1d MNDUAL MNPRIM; 
      acc_ref = acc_ref + xpetit; 
      acc_dir = xty (acfp0 - correc) zdep1d MNDUAL MNPRIM; 
      acc_rap = acc_dir/acc_ref; 
     'SI' (acc_rap '>' 256.) ; 
 * en cas d'acceleration trop grande, on la limite 
        'MESS' 'Limitation acceleration ' ' 'acc_rap;  CORREC = correc * (256./acc_rap); 
      'FINSI'; 
 *    'SI' ((acc_rap '<EG' 0.) 'OU' (acc_dir '<EG' 0.)) ; 
      'SI' (acc_rap '<EG' 0.) ; 
 * en cas d'acceleration retrograde, on n'accelere pas 
        'MESS' 'Annulation acceleration: instable ' ' ' acc_dir; 
        correc =  0.; 
        itacc=2; 
      'FINSI'; 
   'FINSI'; 
   RESIDU = RESIDU '-' CORREC; 
   RESIDC = RESIDC '-' CORREC; 
 'FINS'; 
   
  ACFP3  = ACFP2  ; 
  ACFP2  = ACFP1  ; 
  ACFP1  = ACFP0  ; 
  ACFEP2 = ACFEP1 ; 
  ACFEP1 = ACFEP0 ; 
 * 
 * Resolution --------------------------------------------------------- 
 * on obtient ZDEP1 = [ du ; Dlx ] 
 'SI' (resmul < 0.99); 
 'MESS' 'Reduction du chargement. Coefficient: ' resmul; 
 **ZDETOT = ZZD   '+' ZDEPT ; 
 **XXX1   = ZCLIM '*' ZDETOT; 
 * -1*reactions a l'iteration it 
 **FCORF = 'ENLEVER'  XXX1 'FLX'; 
   residu = ((residu -fcorf) * resmul) +  fcorf; 
 **  residu = (residu 'ENLE' 'FLX') 'ET' ((RESIDU 'EXCO' 'FLX' 'NOID' 'FLX')  * resmul); 
     ACFP0 = (RESIDU  - FCORF) 'ENLE' FLX ; 
 'FINSI'; 
   'SOUCI' 0; 
 'SI' IAFAIR; 
 * 
   
   FEXCI = 'VIDE' 'CHPOINT' / 'DISCRET' ; 
   'SI' (WTAB.'ADHERENCE') ; 
     'SI' ('EXIS' WTAB 'MAIL_BLOM') ; 
       FADRE = 'REDU' FADHE WTAB.'MAIL_BLOM' ; 
     'SINON' ; 
       FADRE = FADHE ; 
     'FINSI' ; 
     FEXCI = FEXCI 'ET' FADRE ; 
   'FINSI' ; 
 * 
   'SI' (WTAB.'CAFROTTE') ; 
     FEXCI = FEXCI 'ET' FFROT ; 
   'FINSI' ; 
 * 
   'SI' ( ('EXIS' STAB12 'RIBLO_M') 'ET' (IPREM 'OU' RECA_K) ) ; 
     'SI' ((WTAB.'CAFROTTE' 'OU' WTAB.'ADHERENCE') 'ET' IMPO12U); 
        ZDEP1 BID BID BID BID = 'RESO' ZRAID 'SOUC' RESIDU 'INIB' 
                               STAB12.'RIBLO_M'   STAB12.'LISEA_M' 
                               FEXCI ; 
     'SINON'; 
        ZDEP1 BID BID BID     = 'RESO' ZRAID 'SOUC' RESIDU 'INIB' 
                               STAB12.'RIBLO_M'   STAB12.'LISEA_M' ; 
     'FINS'; 
   
   'SINON'; 
     'SI' ((WTAB.'CAFROTTE' 'OU' WTAB.'ADHERENCE') 'ET' IMPO12U); 
       ZDEP1 = 'RESO' ZRAID 'SOUC' RESIDU FEXCI ; 
     'SINON'; 
       ZDEP1 = 'RESO' ZRAID 'SOUC' RESIDU 'NOID'; 
       'SI' (WTAB.'MAN' 'ET' IPREM); 
           ORDRE      = WTAB.'ORDRE' ; 
           ZDEP2 IOUT = CORMAN ZRAIDINI ZMODL ZMAT  ORDRE 
                        ZU1 ZSIG0      RESIDNOR  WTAB ; 
           'SI' (IOUT 'EGA' 1) ; 
              ZDEP1=ZDEP2; 
           'FINS'; 
       'FINS'; 
     'FINS'; 
   'FINS'; 
   monsouc ='SOUCI'; 
   'SI' monsouc; 'SI' ('NON' autaug); 
            'ERREUR' ('VALE' 'SOUCI'); 
    'FINSI'; 'FINSI'; 
   
   
      'SI' LOGPIL ; 
 *      Calcul de D_eta par appel a la procedure PILOINDI 
        D_ETA = PILOINDI PRECED ZU1 ZDEPT ZDEP1 ZDEPII DTAU ; 
 *      Mise √† jour 
            ZDEP1 = ZDEP1 '+' (D_ETA '*' ZDEPII) ; 
            ETA = ETA '+' D_ETA ; 
          'FINSI' ; 
   
   
 tabconv . it = 1; 
 * 
 *  verif sens ---------------------------------------------------------- 
 * 
 zdep1s = zdep1 'ENLE' 'LX'; 
 monsouc = souci; 
 pasunil = monsouc; 
 'SI' (WTAB.'STABILITE' 'ET' (('NON' HPP_EPS) 'OU' monsouc) 'ET' autaug ); 
     sens = xtmx zraid zdep1s; 
     'SI' ((sens < 0) 'OU' monsouc); 
      'MESS' 'Annulation sous-increment: instable ' ' ' sens; 
      itacc = 3  ; 
      'SI' monsouc ; 
      'MESS' 'souci: ' (vale 'SOUC'); 'FINSI'; 
                             resmul = resmul * 0.25; 
   'SI' autaug;   iraug = vrai; 'FINSI'; 
      HPP_EPS = FAUX; 
      pastest = vrai; 
      instab = vrai; 
      urg = vrai; 
      augmult = augmult * 1.4; 
     'SI' iraug; 
       ZDEPT = zdeptp ; 
       zdep1 = (zdept - zdeptp) + (zdept 'EXCO' 'LX' 'NOID' 'LX'); 
       'ITERER' etiq; 
      'FINSI'; 
     'FINS'; 
 'FINS'; 
 * 
   ZRAID_T = 'EXTR' ZRAID 'CONT'; 
   'SI' ('EXIS' ZRAID_T 'NITER'); 
        'SI' IDYN ; STAB12.'ZRAIDV'= ZRAID; 'FINS'; 
         STAB12.'RIBLO_M' = ZRAID_T.7; 
         STAB12.'LISEA_M' = ZRAID_T.6; 
         WTAB.'MAIL_BLOM' = 'EXTR' ZRAID_T.7 'MAIL' 'MULT' ; 
   'FINS'; 
 'FINS'; 
 RECA_K = FAUX; 
 * 
 * 1ere iteration ------------------------------------------------------ 
 'SI'   IPREM  ; 
           ZDEPT  = 'COPIER' ZDEP1 ; 
           ZDEPTM = ZDEPT ; 
 *         ZDEPf  = ZDEPT ; 
           ZDELA  =   'COPIER' ZDEPT ; 
           'SI' (WTAB . 'MODAL') ; 
              'SI' ('EXIS' WTAB 'MODCONTA') ; 
                 mamoco1 = 'EXTR' (ZDEPT 'ENLEVER' 'LX') 'MAIL' ; 
              'FINS'; 
           'FINS' ; 
 *   iprem est faux: on est apres la premiere operation--------------- 
 * 
 'SINON'; 
 *     zdept est l'increment de deplacement total avec les lagrangiens 
 *     de la solution complete 
         XXX1   = ZDEPT 'ENLEVER' 'LX' ; 
 *       ZDEPf  = (ZDEPT + ZDEPTP) * 0.5; 
 *       on cumule les deplacements mais pas les lx 
 *       Du^(i)  = Du^(i-1) + du   ;   Dlx^(i) = 0 + Dlx 
   
         ZDEPT  = XXX1 '+' ZDEP1 ; 
        'DETR' XXX1 ; 
 'FINS' ; 
 * 
 'SI' (WTAB . 'MODAL') ; 
      'SI' ('EXIS' WTAB 'MODCONTA') ; 
 * mettre les point materiels dans zdept 
          zdeptu1 =  'REDU' zdept   mamoco1      ; 
          ch_dco  =  'RECO' zdeptu1 ZMODL ZMATFI ; 
          ZDEPT   = ('EXCO' zdept 'LX' 'LX') 'ET' zdeptu1 'ET' ch_dco ; 
      'FINS'; 
 'FINS' ; 
 * 
 * ATTENTION ON EST SUR LA CONFIGURATION GEOM1? 
   
   
 * 
   
 * 
 *--- CAS 2 ------------------------------------------------------------* 
 *  si on part dans les decors on redemarre a 0 
 'SI' ((XCONV > 1E8) 'ET' PASREINI 'ET' ('NON' IPILOT)) ; 
         'MESS' 'Reinitialisation du schema'; 
       ZDEPT = zdeptp ; 
       zdep1 = (zdept - zdeptp) + (zdept 'EXCO' 'LX' 'NOID' 'LX'); 
         PASREINI=FAUX; 
         ITACC=3; 
         'ITERER' ETIQ; 
 'FINS'; 
   
 * 
 *--- CAS 3 ------------------------------------------------------------* 
 'SI'  ACCEL ; 
   
 *   pilotage automatique 
     'SI' IPILOT; 
               RED1 = STAB12.'AUTOREDU' ; 
   
 *       reduction du critere de pilotage red2 sert d'incateur si 
 *       pas accelere tous les 2 pas 
   
 * MODIFICATION CB215821 : 18/06/2015 
            'SI' (RED2 < (IT '/' 20)); 
                 STAB12.'AUTOREDU' = STAB12.'AUTOREDU' '*' 3.D0 ; 
                 RED2 = RED2 '+' 1 ; 
                 ITACC= 3; 
            'FINS'; 
   
             RED1 = RED1 '/' (STAB12.'AUTOREDU') ; 
             'SI' (RED1 '<' 0.9) ;  STAB12.AUTORED1 = 10 ; 'FINS' ; 
   
             'SI' ( STAB12.'AUTOREDU' '>' 1.D0 ) ; 
                'MESS' 'On divise le critere de pilotage par ' 
                 STAB12.'AUTOREDU'; 
             'FINS' ; 
   
 *      test si snap back et si refus de l'acceleration 
             'SI' IPLAVI ; 
                   XXX2 = 'EXCO' ZDEPT  'LX' 'NOID' 'LX' ; 
                   XXX1 = 2.D0  '*' XXX2; 
                   XXX3 = ZDEPT '-' XXX1; 
             'SINON' ; 
                   XXX1 = COEPI '*' ZDELA; 
                   XXX3 = ZDEPT '-' XXX1 ; 
                   XXX2 = 'EXCO' XXX3 'LX' 'NOID' 'LX'; 
                   XXX1 = XXX2  '*' 2.D0 ; 
                   XXX4 = COEPI '*' ZDELA; 
                   XXX3 = ZDEPT '-' XXX4 '-' XXX1; 
            'FINS' ; 
   
            'DETR' XXX2 ;'DETR' XXX1; 'DETR' XXX3; 
             XXX1 ='EXCO' ZDEPT 'LX' 'NOID' 'LX' ; 
             XXX2 = XXX1 '*' 2.D0 ; 
             XXX3 = ZDEPT '-' XXX2; 
             SRT  = 'XTY' ZDFINI XXX3 MLDUAL MLPRIM;            pvpv      ; 
            'DETR' XXX1 ;  'DETR' XXX2; 'DETR' XXX3; 
   
             ISNPB = FAUX; 
            'SI'  (SRT '<' 0) ; 
                 ISNPB = VRAI ; 
            'FINS'; 
   
             OO = WTAB.AUTOCRIT ; 
             OO = OO '/' STAB12.'AUTOREDU' ; 
             U1MA = AUTOPILO ZDEPT (COEPI'*'ZDELA) ZMODLI ZMATFI WTAB; 
             AL1 = OO '/' U1MA ; 
 *        al1 est le coefficient de normalisation 
            'SI' (( al1 '>EG' 1.d0) 'ET' (coepi '>EG' 1.d0)) ; 
 *     pour eviter d'aller au dela de alpha=1 on ignore le critere 
                  AL1 = 1.d0 ; 
            'FINS' ; 
             'SI'((AL1 '>' 1.D0) 'ET' (COEPI '>' 0.D0)); 
               'SI' ( AL1 '>' (1.D0 '/' COEPI)); 
                    AL1 = 1.D0 '/' COEPI; 
               'FINS'; 
             'FINS'; 
 *  normalisation 
   
               PASTEST=VRAI; 
               XXX1   = ZLX   '*' ( 1.d0 '-' AL1); 
               XXX3   = ZDEPT '*' AL1 ; 
               ZDEPT   = XXX3  '+' XXX1; 
              'DETR' XXX3; 
     'FINS'; 
 'SINON'; 
       'SI' IPILOT ; 
 ** 
 *   le calcul d'al1 est fait pour eviter la convergence 
 *   s'il est  externe a l'interval 0.5 --- 2. 
             OO = WTAB.'AUTOCRIT' ; 
             OO = OO '/' STAB12.'AUTOREDU' ; 
             U1MA = AUTOPILO ZDEPT (COEPI'*'ZDELA) ZMODLI ZMATFI WTAB; 
             AL1 = OO '/' U1MA ; 
            'SI' (( AL1 '>EG' 1.d0) 'ET' (COEPI '>EG' 1.d0)) ; 
                  AL1 = 1.d0 ; 
            'FINS' ; 
       'FINS' ; 
 'FINS'; 
 * 
 *  garder les reactions pour le test de convergence 
 * 
 ZDEPLP = ZDEPL                         ; 
 ZDEPL  = ZDEPT 'EXCO' 'LX' 'NOID' 'LX' ; 
   
 *---------------------------------------------------------------------- 
 *     le nouveau champ est fixe on va tester l'equilibre(convergence) 
 *     et calculer la force motrice pour l'iteration suivante 
 *---------------------------------------------------------------------- 
 * 
 *  calcul de  fcorf = lambda * m   force de reaction ----------------- 
 *             fcoru = m * u     depimp (flx) 
   
 'DETRUIRE' FCORF; 
 *       calcul du deplacement total u 
 zdetotp = zdetot; 
 ZDETOT = ZZD   '+' ZDEPT ; 
 XXX1   = ZCLIM '*' ZDETOT; 
 * -1*reactions a l'iteration it 
 FCORF = 'ENLEVER'  XXX1 'FLX'; 
 * valeur des relations imposees a l'iteration it 
 FCORU = 'EXCO'  XXX1 'FLX'  'NOID' 'FLX'; 
 'DETR' XXX1 ; 
 * 
 *  dans le cas des modeles endommageables de Lemaitre, on ecoule 
 *  en tenant compte, dans les iterations internes, de la variation du 
 *  materiau avec la temperature 
 * 
 ZMATT = ZMAT    ; 
 'SI' ('ET' ('ET' ITHER ('OU' IENDOM IVIDOM ) ) WTAB.'MATVAR')  ; 
 * on recupere certain materiau avec les parametres fct de la temperatue 
 * voir PAS_mate  (il ne faut que la dependance thermique) 
       ZMATT = 'REDU' WTAB.'MA_COMP' ZMODL; 
 'FINS'; 
   
 'SI' IFEFP; 
 * Update or total lagrangian ----------------------------------------- 
   'SI' IFEFPUL; 
 *  mess ' update lagrangian ZRIKTA'; 
     GEOM2 = 'FORM' ZDEPT ; 
     ZRIKTA ZSIGF ZVARF ZDEIF = 'ECFEFP' 
          ZMODL ZEPS0 ZVAR0 ZDEPT ZMAT ZPREK NITMA XUPDA; 
   'SINON'; 
 *  mess ' total lagrangian ZRIKTA'; 
     chp_z = ZDEPT + ZU1 ; 
     GEOM2 = 'FORM' chp_z ; 
     ZRIKTA ZSIGF ZVARF ZDEIF = 'ECFEFP' 
          ZMODL ZEPS0 ZVAR0 chp_z ZMAT ZPREK NITMA ; 
     chp_z = 1 ; 
   'FINS'; 
   FEQU2 = 'BSIG' ZMODL ZSIGF ZMAT ; 
   ZRAID = ZRIKTA 'ET' ZCLIM ; 
    'FORM' GEOM1 ; 
 ** 
   XXX1 = 'EXCO' (WTAB.'MOVA') ZVARF ; 
   EPSM = 'MAXI' XXX1 'AVEC' MLDEFOR ; 
   ACC  = 'ABS' ( XXX1 - ACC0 ) ; 
 *'DETR' XXX1 ; 
   MMC = 'MASQUE' ACC 'SUPERIEUR' 1.D-10 'SOMME' ; 
   'SI' (MMC '>' MMCMAX) ; MMCMAX = MMC ; 'FINS' ; 
   DPSMAX  = 'MAXI' ACC 'AVEC'  MLDEFOR ; 
   DEPST   = 'CHAN' 'TYPE' ZDEIF 'DEFORMATIONS' ; 
   
   GR_U_FIN= 'MOT' 'INCONNU'; 
   
 'SINON'; 
 * cas standard -------------------------------------------------------- 
   ZMAT05=ZMAT; 
   GEOM2 = GEOM1; 
   'SI' IGRD; 
     zdepm  = zdept '*' 0.5; 
     'FORM' GEOM1 ; 
      GEOM2m = 'FORM' zdepm  ; 
      GEOM2  = 'FORM' zdepm  ; 
     'FORM' GEOM1 ; 
   'FINS'; 
 * 
 *     calcul de l'increment de deformation elast totale  DEPST-------- 
 * 
 * Pour les hypotheses de deformations non lineaires, 
 * on calcule l'increment de deformation sur le pas avec EPSI 'LINE' 
 * mais en se placant sur une configuration intermediaire (mi pas) 
   'SI' (('NEG' HYPDEF 'LINEAIRE') 'ET' IGRD); 
     'SOUC' 0; 
     'SI' ITCAR; 
       GEOMIL  ZMATTEMP = 'FORM' ZDEPM ZMODLI (ETG ZMAT05) ; 
 *     A cause de FORM, ZMATTEMP n'est plus parallele... 
       ZMATTEMP         = 'REDU' ZMATTEMP ZMODL ; 
       DEPST            = 'EPSI' 'LINE' 'NOER' ZMODL ZDEPT ZMATTEMP ; 
       ZMATTEMP = 0 ; 
     'SINON'; 
       GEOMIL           = 'FORM' ZDEPM    ; 
       DEPST            = 'EPSI' 'LINE' 'NOER' ZMODL ZDEPT ZMAT05   ; 
     'FINS'; 
     PASOK = 'SOUCI'; 
   
     'SI' ('NON' PASOK); 
       'FORM'  geom1; 
       DEPST = 'CAPI' HYPDEF DEPST ZMODL ZDEPM; 
       'SI' ('MAXI' 'ABS' DEPST '>' 10); 
         PASOK = VRAI; 
       'FINS'; 
     'FINS'; 
   
     'SI' PASOK; 
  mess 'annulation sous-increment: deformation non lineaire non calculable'; 
       resmul = resmul * 0.25; 
       'SI' autaug;   iraug = vrai; 'FINSI'; 
       HPP_EPS = FAUX; 
       pastest = vrai; 
       urg = vrai; 
       itacc = 3; 
       augmult = augmult * 1.4; 
       ZDEPT = zdeptp ; 
       zdep1 = (zdept - zdeptp) + (zdept 'EXCO' 'LX' 'NOID' 'LX'); 
       'SI' IGRD; 
         'FORM' GEOM1 ; 
       'FINS'; 
       'ITERER' etiq; 
     'FINSI'; 
   'SINON'; 
     PASOK = vrai; 
   'FINS'; 
   
 ** on n'a pas pu calcule DEPST : on utilise les deformations lineaires 
   'SI' PASOK; 
 *    'MESS' 'deformation lineaire'; 
     'SI' IGRD; 
       'FORM' GEOM1; 
     'FINSI'; 
     DEPST = 'EPSI' 'LINE' ZMODL ZDEPT ZMAT05; 
   'FINS'; 
   
 * calcul des increments de deformation et contrainte sur la configuration initiale 
 * en lagrangien total 
   'SI' IGRD ; 
     'SI' (LAG_TOT 'EGA' 1); 
 *  passage de depst et sig0 sur for0 
       'FORM' GEOREF0; 
       DEPST = 'CAPI' HYPDEF DEPST ZMODL ZU1 ; 
       ZSIG0 = 'CAPI' HYPDEF ZSIG0 ZMODL ZU1 ; 
     'FINSI'; 
 *  passage de depst et sig0 sur geom2 
     'SI' (LAG_TOT 'EGA' 2); 
       DEPST = 'PICA' HYPDEF DEPST ZMODL ZDEPT ; 
       ZSIG0 = 'PICA' HYPDEF ZSIG0 ZMODL ZDEPT ; 
       'FORM'  geom2; 
     'FINS'; 
     'SI' (LAG_TOT 'EGA' 3); 
       DEPST = 'PICA' HYPDEF DEPST ZMODL ZDEPM ; 
       ZSIG0 = 'PICA' HYPDEF ZSIG0 ZMODL ZDEPM ; 
       'FORM'  geom2m; 
     'FINS'; 
   'FINS'; 
   
 *  ICI depst et zsig0 sont sur la configuration initiale en lagrangien total et 
 *      il faut soustraire les parties thermique et deformations imposees 
   'SI' IPLAVI; 
     'SI' ('OU' ('OU' IENDOM IVIDOM)  ICERAM); 
       HOOKENDO = 'HOOK'          ZMODL ZMAT05 ZVAR0          ; 
       'SI' IGRD; 
          DEPST   = 'EPSI' 'QUAD' ZMODL ZDEPT  HOOKENDO ZMAT05; 
       'SINON'; 
         DEPST    = 'EPSI' 'LINE' ZMODL ZDEPT  HOOKENDO ZMAT05; 
       'FINS'; 
     'FINS'; 
   
 *    si thermoplastique on enleve e alpha *dt et d'autres termes 
 *    si le materiau depend de la temperature 
     'SI' (ITHER 'OU' WTAB.'MATVAR') ; 
        XXX1  = DEPST0 '*' COEPI; 
        XXX2  = DEPST  '-' XXX1 ; 
 *       'DETR' DEPST ; 'DETR' XXX1; 
        DEPST = XXX2 ; 
     'FINS' ; 
   
     'SI' LOGDEF  ; 
        XXX1 = DDEFOR0 '*' COEPI; 
        XXX2 = DEPST   '-' XXX1 ; 
 *       'DETR' DEPST ; 'DETR' XXX1; 
        DEPST = XXX2 ; 
     'FINS' ; 
   
   'SINON'; 
 *   en elasticite, on a directement l'increment de contrainte 
     DSIGT= 'ELAS'  ZMODL DEPST ZMAT05 ; 
     'SI' (('NON' ITHER) 'ET' WTAB.'MATVAR') ; 
       XXXXX3 = 'ELAS' ZMODL ZSIG0 ZMAT05 ; 
       XXXXX4 = 'ELAS' ZMODL ZSIG0 ZMAT1  ; 
       XXDEFO = XXXXX4 '-' XXXXX3 ; 
       DSIGTV = 'ELAS' ZMODL XXDEFO ZMAT05 ; 
       DSIGT  =  DSIGT '+' DSIGTV ; 
 *      'DETR' XXXXX3 ; 'DETR' XXXXX4 ; 
 *      'DETR' XXDEFO ; 'DETR' DSIGTV ; 
     'FINS' ; 
 *   si thermoplastique on enleve alpha *dT et d'autres termes 
 *   si le materiau depend de la temperature 
     'SI' ITHER  ; 
       XXX1 = DSIGT0 '*' COEPI; 
       XXX2 = DSIGT  '-' XXX1; 
       'DETR' DSIGT ; 'DETR' XXX1; 
       DSIGT =  XXX2  ; 
     'FINS'; 
   
     'SI' LOGDEF  ; 
       XXX1 = DSI1  '*' COEPI; 
       XXX2 = DSIGT '-' XXX1; 
 *      'DETR' DSIGT ; 'DETR' XXX1; 
       DSIGT =  XXX2 ; 
     'FINS'; 
   'FINS'; 
 * 
 *  Calcul du gradient des deplacements (total) a la fin du pas de ------ 
 *  temps par rapport a la configuration de reference GEOREF0 (initiale) 
 *  rappel : On a : ZDETOT = ZZD + ZDEPT ; 
 'SI' igrd; 
 'SI' ('NEG' GR_U_DEB 'INCONNU'); 
   'SI' (LAG_TOT 'NEG' 1); geot = 'FORM'; 
      'FORM' WTAB.FOR0; 'FINS' ; 
    GR_U_FIN = 'GRAD' ZMODL ZMAT ZDETOT ; 
    D_GR_U   =  GR_U_FIN '-' GR_U_DEB   ; 
   'SI' (LAG_TOT 'NEG' 1); 'FORM' GEOT; 'FINS'; 
 'SINON'; 
    GR_U_FIN = 'MOT' 'INCONNU'; 
 'FINS'; 
 'FINS'; 
 * 
   'SI' ZCCONV ; 
     STAB12.'DT' = DTINI '*' COEPI ; 
   'SINON' ; 
     STAB12.'DT' = 0. ; 
   'FINS' ; 
 * 
 *  si on est plastique ou viscoplastique on ecoule pour avoir----------- 
 *  le nouveau champ de contraintes 
 * 
 MMC = 0 ; 
 'SI'  IPLAVI ; 
   
 *...cas SSTE... 
    'SI' ISSTE; 
       ZRIKTA ZSIGF ZVARF ZDEIF = 
                         'SSTE' ZMODL ZSIG0 ZVAR0 DEPST ZMATT 
                                ZPREK NSSTE NITMA; 
       zvar0 = ('EXCO' zvar0 ('ENLE' lnom ('DIME' lnom))) 'ET' 
               ('EXCO' zvarf ssii); 
       zvar0 = 'CHANGER' 'TYPE' zvar0 'VARIABLES INTERNES'; 
   
 *...cas non SSTE... 
    'SINON'; 
       ZSIG01=ZSIG0; 
       ZVAR01=ZVAR0; 
       ZEPS01=ZEPS0; 
 **     defineto = DEPIN0 ; TABCONT='TABLE'; 
   
      'SI' (nsoincr 'NEG' 1); 
         ZSIGM=ZSIG0 '/' 2; 
      'FINS'; 
   
      'REPETER'  sousinc nsoincr; 
   
        tsodeb='FLOT' stab12 .'DT'/nsoincr*( &sousinc - 1)+conti.'TEMPS'; 
        tsofin='FLOT' stab12 .'DT'/nsoincr*  &sousinc     +conti.'TEMPS'; 
       'SI' ('NON' ZCCONV) ; 
          tsodeb = tsofin ; 
       'FINS' ; 
   
        che1= 'ADET' 'NOUV' ZMODL CHASANST tsodeb 'TEMP' tsodeb; 
        che2= 'ADET' 'NOUV' ZMODL CHASANST tsofin 'TEMP' tsofin; 
   
        'SI' ('EXIS' WTAB 'MOD_LIA') ; 
           vite1 =  'CHAN' 'COMP' conti.'VITESSES' MLPRIM MVPRIM ; 
           che1  = che1 
             'ET' ('CHAN' 'CHAM' ZMODL vite1                'STRESSES') 
             'ET' ('CHAN' 'CHAM' ZMODL conti.'DEPLACEMENTS' 'STRESSES'); 
           che2  = che2 
             'ET' ('CHAN' 'CHAM' ZMODL  ZDETOT              'STRESSES') 
             'ET' ('CHAN' 'CHAM' ZMODL  ZFCONST1            'STRESSES'); 
        'FINS'; 
   
        'SI' ither ; 
          TETDE=STAB12.'TET1' + (DTETD *('FLOT' (&sousinc - 1)/nsoincr)); 
          TETDF=STAB12.'TET1' + (DTETD *('FLOT'  &sousinc     /nsoincr)); 
          che3 = 'CHAN' 'CHAM' ZMODL TETDE 'STRESSES' ; 
          che4 = 'CHAN' 'CHAM' ZMODL TETDF 'STRESSES' ; 
        'FINS' ; 
   
        che1 = che1 'ET' che3 ; 
        che2 = che2 'ET' che4 ; 
        aa5  = DEPST '*' ( (&sousinc '-' 1.) '/' nsoincr); 
        che5 = DEFT0 '+'   aa5; 
        cc5  = DEPST '*' ('FLOT' &sousinc '/' nsoincr); 
        che6 = DEFT0 '+'  CC5; 
 *On met les deformations en tete des champs pour COMP ('KTAN' 'PERT') 
        che1 = che5 'ET' che1 ; 
        che2 = che6 'ET' che2 ; 
 * pour les materiaux on garde toujours la valeur a la fin du pas 
 * et au debut du pas 
 *       'SI' ('NEG'  ZMAT1 'INCONNU') ; 
           che1 = che1 'ET' ZMAT1 ; 
 *       'FINS' ; 
 * 
 *  Modele NON LINEAIRE UTILISATEUR + GRANDES DEFORMATIONS 
 *  On ajoute les gradients de deplacements qui seront transformes en 
 *  gradients de transformation avant appel a UMAT (dans WKUMA1.ESO) 
        'SI' (( 'NEG' GR_U_DEB 'INCONNU') 'ET' igrd) ; 
          gru1 = GR_U_DEB + ( D_GR_U * ('FLOT' (&sousinc-1) / nsoincr)); 
          che1 = che1 'ET' gru1 ; 
          gru2 = GR_U_DEB + ( D_GR_U * ('FLOT'  &sousinc    / nsoincr)); 
          che2 = che2 'ET' gru2 ; 
        'FINS'; 
   
        'SI' LNLOC ; 
           CHE1A = che1 ; 
           CHE2A = che2 ; 
   
           ISTEP = 1 ; 
           chm_z = 'ADET' 'NOUV' ZMODL CHASANST tsodeb 'STEP' ISTEP ; 
           che11 = CHE1A 'ET' chm_z ; 
           che11 = che11 'ET' ZSIG01 'ET' ZVAR01 'ET' ZEPS01 ; 
   
           chm_z = 'ADET' 'NOUV' ZMODL CHASANST tsofin 'STEP' ISTEP ; 
           che22 = CHE2A 'ET' chm_z ; 
           che22 = che22 'ET' ZMATT ; 
   
           'SI' PARTLOCA ; 
             cha11 = 'ASSIS' 'TOUS' 'REDU' MODRELOC che11 ; 
             cha22 = 'ASSIS' 'TOUS' 'REDU' MODRELOC che22 ; 
             cho22 = 'ASSIS' 'TOUS' 'COMP' MODRELOC cha11 cha22 ; 
             cho2  = 'REDU' ZMODL ('ETG' cho22) ; 
             cha11 = 0 ; cha22 = 0 ; cho22 = 0 ; 
           'SINON'; 
              cho2  = 'COMP' ZMODL che11 che22 ; 
           'FINS' ; 
   
           ZVARF = 'CHANGER' ('EXCO' cho2 com_var 'NOID') 
                             'TYPE' 'VARIABLES INTERNES' ; 
 * NLOC ne traitant pas des champs //, on reduit tout au modele initial. 
           'SI' (PARALLEL 'ET' ('NON' PARTLOCA)) ; 
             ZVARF = 'REDU'  ZVARF ZMODLI ; 
           'FINS' ; 
 *   cas non-local MOYE ou SB 
           'SI' ('NEG'  WTAB.'NON_LOCAL' 'HELM'); 
             'SI' ('EGA' WTAB.'NON_LOCAL' 'SB') ; 
                MOD_SB =  WTAB.'NLOC_MODL' ; 
                CONTP = 'PRIN' ('REDU' ZSIG01 MOD_SB) MOD_SB ; 
                ZVARF = ZVARF '+' CONTP '+' WTAB.'NLOC_SB_REGU' ; 
             'FINS' ; 
             ZVARN = 'NLOC'  ZVARF  WTAB.'CONN'  ; 
             ZVARN = 'CHANGER' ('EXCO' ZVARN com_var) 
                           'TYPE' 'VARIABLES INTERNES' ; 
           'SINON' ; 
 *   cas non-local HELM 
             MOD_HELM =  WTAB.'NLOC_MODL' ; 
             ZVARN = 'COPI' ZVARF ; 
             ZVARF1 = 'REDU' ZVARN MOD_HELM ; 
             LICOHELM = 'EXTR' ZVARF1 'COMP' ; 
             'REPE' BH NHELM ; 
               LEMO = TAHELM . &BH. 'NOM' ; 
               MOPRE = 'EXTR' LEMO 1 3 ; 
               ZVAUX = 'EXCO' ZVARF1 LEMO 'SCAL'; 
               ZVAUX2 = 'CHAN' 'NOEUD' MOD_HELM ZVAUX; 
               ZVAUX2 = 'PROI' TAHELM . &BH . 'H_MODELE'  ZVAUX2 'MINI'; 
               FSOUR = 'SOUR' TAHELM . &BH . 'H_MODELE' ZVAUX2 ; 
               ZVNEW = 'RESO' TAHELM . &BH . 'H_OPER' FSOUR ; 
               ZVNEW = 'NOMC' ZVNEW 'SCAL' ; 
               ZVNEW = 'CHAN' 'CHAM' ZVNEW MOD_HELM 'STRESSES' 
                                              'VARIABLES INTERNES'; 
               DZVN = ZVNEW '-' ZVAUX ; 
               DZVN = 'NOMC' DZVN LEMO ; 
               ZVARN = ZVARN '+' DZVN ; 
   
 *             cas particulier SMAX 
               'SI' (('EXIS' LICOHELM 'SMAX') 'ET' ('NEG' MOPRE 'ERF')); 
                 ZSMAX = 'EXCO' ZVARF1 'SMAX' 'SMAX' ; 
                 ZSMAN = 'MANU' 'CHML' MOD_HELM 'SMAX' ('MAXI' ZSMAX) 
                     'TYPE' 'VARIABLES INTERNES' 'STRESSES' ; 
                 ZVARN = ZVARN '+' ZSMAN '-' ZSMAX ; 
               'FINS' ; 
             'FIN' BH ; 
           'FINS' ; 
 * On rend ZVARN // si besoin : 
           'SI' (PARALLEL 'ET' ('NON' PARTLOCA)) ; 
             ZVARN = 'REDU' ZVARN ZMODL ; 
           'FINS' ; 
   
           ISTEP = 2 ; 
           chm_z = 'ADET' 'NOUV' ZMODL CHASANST tsodeb 'STEP' ISTEP ; 
           che11 = CHE1A 'ET' chm_z ; 
           che11 = che11 'ET' ZSIG01 'ET' ZVARN 'ET' ZEPS01 ; 
   
           chm_z = 'ADET' 'NOUV' ZMODL CHASANST tsofin 'STEP' ISTEP ; 
           che22 = CHE2A 'ET' chm_z ; 
           che22 = che22 'ET' ZMATT ; 
   
           'SI' PARTLOCA ; 
             cha11 = 'ASSIS' 'TOUS' 'REDU' MODRELOC che11 ; 
             cha22 = 'ASSIS' 'TOUS' 'REDU' MODRELOC che22 ; 
             cho22 = 'ASSIS' 'TOUS' 'COMP' MODRELOC cha11 cha22 ; 
             cho2  = 'REDU' ZMODL ('ETG' cho22) ; 
             cha11 = 0 ; cha22 = 0 ; cho22 = 0 ; 
           'SINON'; 
             cho2  = 'COMP' ZMODL che11 che22 ; 
           'FINS' ; 
   
 * Un peu de menage 
           CHE1A = 1 ; 
           CHE2A = 1 ; 
           ZVARN = 1 ; 
           ZVARF = 1 ; 
           chm_z = 1 ; 
   
        'SINON' ; 
            che11 = che1 'ET' ZSIG01 'ET' ZVAR01 'ET' ZEPS01 ; 
            che22 = che2 'ET' ZMATT ; 
 *           si ( 'EXIST'  PRECED 'ECRIT' ) ; 
 *           'FINS'; 
            'SI' PARTLOCA; 
                cha11 = 'ASSIS' 'TOUS' 'REDU' MODRELOC che11 ; 
                cha22 = 'ASSIS' 'TOUS' 'REDU' MODRELOC che22 ; 
                cho22 = 'ASSIS' 'TOUS' 'COMP' MODRELOC cha11 cha22 ; 
                cho2  = 'REDU' ZMODL ('ETG' cho22) ; 
                cha11 = 0 ; cha22 = 0 ; cho22 = 0 ; 
            'SINON'; 
 *          'SI' ( 'EXIS' PRECED 'ECRIT' ); 
 *          'FINS'; 
               cho2  = 'COMP' ZMODL che11 che22 ; 
            'FINS'; 
        'FINS' ; 
    ZSIGF = 'CHANGER' ('EXCO' cho2 com_sig 'NOID')'TYPE' 'CONTRAINTES' ; 
    ZVARF = 'CHANGER' ('EXCO' cho2 com_var 'NOID')'TYPE' 'VARIABLES INTERNES' ; 
    ZDEIF = 'CHANGER' ('EXCO' cho2 com_dei 'NOID')'TYPE' 'DEFORMATIONS INELASTIQUES' ; 
   
        'SI' ('EXIS' WTAB 'MOD_LIA') ; 
          ZFLIA = 'EXCO' cho2 'FLIA' 'NOID'; 
        'FINS' ; 
        'SI' (nsoincr 'NEG' 1); 
          'SI' (&sousinc 'EGA' nsoincr); 
            aaa1=zsigf/2; 
            aaa2=aaa1+ zsigm; 
            'DETR' aaa1; 'DETR' zsigm; 
            zsigm=aaa2; 
          'SINON'; 
            aaa2=zsigf+ zsigm; 
            'DETR' zsigm; 
            zsigm=aaa2; 
          'FINS'; 
        'FINS'; 
        zsig01 = zsigf ; 
        ZVAR01 = ZVARF ; 
        ZEPS01 = ZDEIF ; 
 **       defineTO=ZDEIF+defineTO; 
      'FIN' sousinc; 
 * 
 * Matrice tangente par perturbation evaluee pour la derniere iteration calculee 
 * A voir : cas grand deplacement ZSIGF et ZMAT, cas poreux et thermique ZSIGF 
      'SI' (IKTAN 'ET' IPERT) ; 
        Z1COMP = che11 ; 
        Z2COMP = che22 'ET' ZSIGF ; 
      'FINS' ; 
 * 
      'SI' (nsoincr 'NEG' 1); 
 * pour tenir compte de ce que le travail de la correction est 1/2 FU, 
 * on la multiplie par 2 
           CONT  =(ZSIGF + ZSIG0)          ; 
           ZSIGM = ZSIGM*(2. /nsoincr)     ; 
           ZSIGM = ZSIGM - CONT            ; 
           BZSIGM='BSIG' ZMODL ZSIGM ZMAT; 
 **        ZDEPSPL=defineTO - ZEPS0 ; 
      'FINS'; 
 * on enleve toutes traces de champs inutiles 
      zsig01=1;ZVAR01=1;ZEPS01=1; 
 **     defineTO=1; tabcont =1; 
   
 *     le fin d'en dessous est le fin de "si isste ... sinon ... finsi" 
 *     on est encore dans "si iplavi ... finsi" 
    'FINS'; 
 *...fin du si ISSTE sinon ... 
 * 
 *        cas particulier poreux et thermique 
 * 
    'SI' ITHER; 
      'SI' POR1 ; 
         ZSIGF = ZSIGF - ( COEPI * DMSRT0 ) ; 
      'FINS'; 
    'FINS'; 
 * 
 *  max de epse pendant l'iteration 
 *  nbre de points qui ont une evolution non lineaire 
 * 
    'SI' ('EGA' WTAB.'MOVA' 'RIEN') ; 
 **    EPSM = 0.; DPSMAX=0.; 
       MMC=0; 
    'SINON'; 
       XXX1 = 'EXCO' (WTAB.'MOVA') ZVARF ; 
 **    EPSM = 'MAXI' XXX1 ; 
       ACC = 'ABS' ( XXX1 - ACC0 ) ; 
 **    'DETR' XXX1 ; 
       MMC = 'MASQUE' ACC 'SUPERIEUR' 1.D-10 'SOMME' ; 
       'SI' (MMC > MMCMAX) ; MMCMAX = MMC ; 'FINS' ; 
 **    DPSMAX = 'MAXI' ACC ; 
    'FINS'; 
 * 
 *  dans le cas SANS  plasticite,viscoplas,endommagement 
 *  on calcule directement le nouveau champ de contrainte 
 * 
 'SINON' ; 
     ZSIGF = ZSIG0 + DSIGT ; 
 'FINS'; 
 * si il y a lieu transport sur configuration debut de pas 
     'SI' IGRD ; 
 **      ZSIG0 = ZSIG0_1; 
       'SI' (LAG_TOT 'EGA' 1); 
 **        ZSIG0 =  'PICA' HYPDEF ZSIG0 ZMODL ZU1; 
         ZSIGF =  'PICA' HYPDEF ZSIGF ZMODL ZU1; 
         DEPST =  'PICA' HYPDEF DEPST ZMODL ZU1; 
         'FORM' GEOM1; 
       'FINS'; 
       'SI' (LAG_TOT 'EGA' 2); 
         'FORM' GEOM1; 
 **        ZSIG0 =  'CAPI' HYPDEF ZSIG0 ZMODL ZDEPT; 
         ZSIGF =  'CAPI' HYPDEF ZSIGF ZMODL ZDEPT; 
         DEPST =  'CAPI' HYPDEF DEPST ZMODL ZDEPT; 
       'FINS'; 
       'SI' (LAG_TOT 'EGA' 3); 
         'FORM' GEOM1; 
 **        ZSIG0 =  'CAPI' HYPDEF ZSIG0 ZMODL ZDEPM; 
         ZSIGF =  'CAPI' HYPDEF ZSIGF ZMODL ZDEPM; 
         DEPST =  'CAPI' HYPDEF DEPST ZMODL ZDEPM; 
       'FINS'; 
     'FINS'; 
 * 
  DPSMAX = 'MAXI' 'ABS' DEPST 'AVEC' MLDEFOR ; 
     DEPSTI = DEPST; 
 'SI' (IGRD 'ET' ('NON' HPP_EPS) 'ET' ('EGA' LAG_TOT 1)); 
     'FORM' georef0; 
      DEPSTI = 'CAPI'  ZU1 HYPDEF DEPST ZMODL; 
 'FINSI'; 
 EPSMX   = DEFT0 '+' DEPSTI; 
 EPSM   ='MAXI' 'ABS' EPSMX 'AVEC' MLDEFOR ; 
 'DETR' EPSMX; 
 'SI' (IGRD 'ET' ('NON' HPP_EPS) 'ET' ('EGA' LAG_TOT 1)); 
      'FORM' geom1; 
      'DETR' DEPSTI; 
 'FINSI'; 
 * 
 *--- CAS 4 ------------------------------------------------------------- 
 *  on  determine les forces resultantes de l'increment------------------ 
 * 
 *   en grand deplacements on transforme pi en sigma 
 *   on met a jour les coordonnees 
 * 
  ZMAT2=ZMAT; 
   
 'SI' (IGRD 'ET' (('NON' HPP_EPS) 'OU' (IT > 0 ))); 
   
   ref = 50; 
   coefmul = 1.d0 / (DPSMAX + XPETIT); 
   
   'SI' (((coefmul   < ref) 'ET' AUTAUG) 'OU' PASUNIL); 
 *   il faut reduire d'urgence les deplacements ; 
     zdeptlx = zdept 'EXCO' 'LX' 'NOID' 'LX'; 
     coefmul = 0.0; 
     'SI' ((red_urg > 1) 'ET' ('NON' instab)); resmul = resmul * 0.25; 
            'FINSI'; 
   
       augmult = augmult * 1.5; 
       urg = vrai; 
      'SI' autaug;    iraug = vrai; 'FINSI'; 
 * on garde zdep1d pour le calcul des coeff d'acceleration 
        zdep1d = zdep1 'ENLE' 'LX'; 
      'SI' AUTAUG; 
 *  reprise du vieux zdept. Tout le reste est recalcule a chaque pas de etiq 
       ZDEPT = zdeptp ; 
       zdep1 = (zdept - zdeptp) + (zdept 'EXCO' 'LX' 'NOID' 'LX'); 
      itacc = 3; 
      'FINSI'; 
      'SI' ((dpsmaxp < 5e-4) 'OU' (dpsmaxp > 2e-2 )) ; 
          PASTEST=VRAI; 
      'SINON'; 
      'SI' (red_urg > 4);   nconvr = vrai; 'FINSI'; 
          tabconv . it = 1; 
      'FINSI'; 
     'SI' (RED_URG > 2 )  ; 
      'SI' ('NON' nonconv);  'MESS' ' non convergence detectee 1' ; 
       ZMAXIT =     IT+5; 
      'FINS'; 
      nonconv = vrai; 
     'FINS'; 
       'MESS' 'annulation du sous-increment: trop grand ' dpsmax; 
       'SI' (resmul < 0.99); resmul = resmul * 0.25; 'FINSI'; 
   
       RED_URG = RED_URG + 1; 
      'SI' ((dpsmaxp > 1.8d-2) 'ET' (augmult > 100)); 
          zprecnc= 2.1d-2; 
        'SI' (zmaxit > it) ; 
            zmaxit = it - 1; 
        'FINSI'; 
      'FINSI'; 
      'SI' ((zmaxit > it) 'ET' (RED_URG > 4 )); ZMAXIT = IT-1; 'FINS'; 
      'ITERER' etiq; 
     'FINS'; 
   'FINS'; 
   
 'FINS'; 
   
 *  au dessus le finsi du si  fefp sinon(Update or total lagrangian) ---- 
 * 
 dpsmaxp = dpsmax; 
 *  fin de boucle de reduction de zdept 
 *--------------------------------------------------------------------- 
   
 'SI' ('NON' IFEFP); 
   'SI' (IGRD 'ET' ('NON' HPP_EPS)); 
   zdepf = zdept ; 
 *    grands deplacements ----------------------------------------------- 
   
      ZSIGF ='PICA' HYPDEF ZMODL ZSIGF ZDEPT ; 
   
     'SOUC' 0; 
     'SI' ITCAR ; 
        GEOM2 ZMAT2 ='FORM' ZDEPF ZMODLI ZMATI; 
        ZMAT2       ='REDU' ZMAT2 ZMODL       ; 
     'SINON'; 
        GEOM2 = 'FORM' ZDEPF ; 
     'FINS'; 
      FEQU2 = 'BSIG' 'NOER' ZMODL ZSIGF  ZMAT2  ; 
      PASOK = 'SOUCI'; 
      'SI' PASOK; 
            dekreac1 = 1e30; 
        pastest = vrai; 
        instab = vrai; 
        urg = vrai; 
        'SI' autaug;  iraug = vrai; 'FINSI'; 
        tabconv . it = 1; 
        'FORM' geom1; 
        'MESS' 'BSIG imposible'; 
        'SI' AUTAUG; 
 *  reprise du vieux zdept 
         ZDEPT = zdeptp ; 
         zdep1 = (zdept - zdeptp) + (zdept 'EXCO' 'LX' 'NOID' 'LX'); 
 **      dsigt = dsigt * 0.; 
         'ITERER' etiq; 'FINSI'; 
       'FINS'; 
   
     'SI' IRCON; 
        FEQU2 = FEQU2 '+'('REDU' MAI_CONS (RIG_CONS '*' ZDETOT)); 
     'FINS'; 
     'SI' LOGPRE ; 
       ZDFINI = ZDFINI - ZFPEXTF ; 
       'DETR' ZFPEXTF ; 
       ZPEXTF = 'TIRE' WTAB.'CHARGEMENT' 'PRES' TI ; 
       'SI' ('EXIS' WTAB 'MAT_PRE') ; 
         ZFPEXTF = 'BSIG' MOP ZPEXTF ('REDU' ZMATFI MOP) ; 
       'SINON' ; 
         ZFPEXTF = 'BSIG' MOP ZPEXTF ; 
       'FINS' ; 
       ZDFINI = ZDFINI + ZFPEXTF ; 
     'FINS' ; 
   
     'SI' ADDISEC2; 
        ZDFINI   = ZDFINI '-' FP22 ; 
     'FINS'; 
     'SI' WTAB.'PROCEDURE_CHARMECA'; 
        TFP22    = CHARMECA PRECED WTAB.'T_FINAL' ; 
        ADDISEC2 = FAUX; 
       'SI' ('EXIS'  TFP22 'ADDI_SECOND') ; 
          FP22     = TFP22.'ADDI_SECOND'  ; 
          ZDFINI   = ZDFINI + FP22        ; 
          ADDISEC2 = VRAI                 ; 
       'FINS'; 
       'SI' IPILOT ; 
          COEFP =(COEPI*DMZPRES+ MZPRES0)/(MZPRES+XPETIT); 
       'FINS' ; 
     'FINS' ; 
     'FORM' GEOM1 ; 
 * 
 *  dans les autres  que IGRD cas on calcule fequ2(desequilibre)--------- 
 * 
   'SINON'; 
      FEQU2 = 'BSIG' ZMODL ZSIGF ZMAT ; 
     'SI' IRCON; 
         FEQU2 = FEQU2 '+' ('REDU' MAI_CONS (RIG_CONS '*' ZDETOT)); 
     'FINS'; 
     'SI' ADDISEC2; 
        ZDFINI = ZDFINI '-' FP22 ; 
     'FINS'; 
     'SI' WTAB.'PROCEDURE_CHARMECA'; 
        TFP22  = CHARMECA PRECED WTAB.'T_FINAL' ; 
        ADDISEC2 = FAUX; 
       'SI' ('EXIS' TFP22 'ADDI_SECOND'); 
          FP22     = TFP22.'ADDI_SECOND'; 
          ZDFINI   = ZDFINI '+' FP22    ; 
          ADDISEC2 = VRAI               ; 
       'FINS'; 
       'SI' IPILOT ; 
          COEFP =(COEPI*DMZPRES+ MZPRES0)/(MZPRES+XPETIT); 
       'FINS' ; 
     'FINS' ; 
   'FINS'; 
 'FINS'; 
 * le finsi au dessus est le finsi de si iefefp 
        'SI' ('EXIS' WTAB 'MOD_LIA') ; 
           FLIAI = 0.d0 ; 
          'SI' ('EGA' ('TYPE' ZFLIA) 'MCHAML  ') ; 
             NZLIA = 'EXTR' ZFLIA 'NBZO' ; 
           'SI' (NZLIA > 0) ; 
            'REPETER' BZLIA NZLIA ; 
 * un point support par zone - 2010 kich 
         FLIAI= FLIAI + 
   ('EXCO' ('EXTR' ZFLIA 'FLIA' &BZLIA 1 1) MLDUAL 'NOID') ; 
            'FIN' BZLIA ; 
           'FINS' ; 
            FEQU2 = FEQU2 + FLIAI ; 
          'FINS' ; 
        'FINS' ; 
 * 
 *  calcul des forces correctrices de frottement------------------------- 
 * 
 'SI' (WTAB.'CAFROTTE' 'ET' IMPO12); 
 *  apres non convergence, on maintient les forces de frottement 
    MAINT=FAUX; 
   'SI' ('NON' WTAB.'CONV' 'ET' ('NEG' WTAB.'FFROT' 'INCONNU')); 
      MAINT=VRAI; 
   'FINS'; 
    zsigfT = 'REDU' zsigf ZMODLI; 
   'SI' MAINT; 
      FFROT1 = 'EXCF' ZRAID ZDEPT MODFRO MATFRO WTAB.'FFROT' ZSIGFt ; 
   'SINON'; 
      FFROT1 = 'EXCF' ZRAID ZDEPT MODFRO MATFRO              ZSIGFt ; 
   'FINS'; 
    FFROT  = (FFROT1 + FFROTP)/2; 
   
   
   
   
   
    FFROTP = FFROT1; 
 'FINS'; 
   
   
 'SI' ISOL  ; 
         'SI' IPLAVI ; 
            ZMATPF = 'CHANGER' ('EXCO' cho2 com_maa 'NOID') 
            'TYPE' 'CARACTERISTIQUES'; 
            MA_POR = 'REDU' ZMATPF MO_POR ; 
         'FINS'; 
         XXX1 = 'GRAD' MO_POR ZDETOT MA_POR 'CONS'  ; 
         XXXS = (1. - WTAB.'TETA' )*GRAP0 + (WTAB.'TETA'*XXX1) ; 
         XXX2 = STAB12.'DT' * ('GNFL' MO_POR XXXS) ; 
         XXX3 = FEQU2 ; 
         FEQU2 = XXX3 - XXX2;'DETR' XXX3; 'DETR' XXX2 ; 
 *       'DETR' XXX1; 'DETR' XXXS  ; 
 'FINS' ; 
   
 * si on a fait de la sous incrementation ( a cause du dynamique 
 'SI' ( nsoincr > 1); 
   FEQU2 = FEQU2 + BZSIGM ; 
 'FINS'; 
   
 * 
 *   forces qui varient en dynamique------------------------------------ 
 *                       b*sigma + 4/h2*m*dx 
 *                               + 2/h *c*dx 
 * 
 'SI' IDYN; 
    'DETR' FFDYN; 
     FFDYN = 'COPIER' FEQU2 ; 
     XXX1 = WTAB.'MASSE' * ZDEPT; 
     XXX3 = 4. * UNSURH * UNSURH  * XXX1 ; 
    'DETR' XXX1; 
    'SI' ('EXIS' WTAB 'MOD_LIA'); 
      'SI' (NZLIA > 0) ; 
         XVIT2 = 0.d0; 
        'REPETER' BZLIA NZLIA ; 
           XVIT2 = XVIT2 + 
   ('EXCO' ('EXTR' ZFLIA 'FLIA' &BZLIA 1 1) MVPRIM MLPRIM 'NOID') ; 
        'FIN' BZLIA ; 
      'FINS' ; 
    'FINS' ; 
    'SI' ( 'NEG' WTAB.'AMORTISSEMENT' 'INCONNU') ; 
       XXX1 = WTAB.'AMORTISSEMENT' * ZDEPT; 
       XXX2 = 2. * UNSURH * XXX1 ; 
       XXX4 = XXX3 + XXX2 ; 
      'DETR'  XXX3 ; 
      'DETR'  XXX1 ; 
      'DETR'  XXX2 ; 
       XXX3 = XXX4 ; 
    'FINS' ; 
     XXX4 = FEQU2 + XXX3; 
    'DETR' XXX3         ; 
    'DETR' FEQU2        ; 
     FEQU2 = XXX4       ; 
 * 
 *         forces correctrices en cas de liaison persistante : 
 *  on veut avoir (forces inertielles + forces visqueuses) compatibles 
 *  avec accelerations et vitesses relatives nulles aux points de contact 
 *  (pendant le contact). On modifie fequ2 ---> residu et l'iteration sui 
 *  fournira les bonnes reactions 
 * 
   'SI' IMPLP; 
      VADD XXX3 = VITETFOR ZRAID_T  WTAB  FCORU ; 
      XXX4      = FEQU2 - XXX3; 
     'DETR' XXX3      ; 
     'DETR' FEQU2     ; 
      FEQU2     = XXX4; 
   'FINS' ; 
 'FINS'; 
 *     mess ' zdept ';list (resu  zdept); 
 * 
 *   preparation des tests de convergence.------------------------------- 
 *   on calcule la plus grande composante de  f + freac(sans flx) 
 * fequi est de plus le second membre que l'on veut equilibrer 
 *  ne pas oublier d'y ajouter les forces suiveuses 
 *      test de convergence:   equilibre de la structure 
 *      il se fait sur residc, on calcule auusi le nouveau second 
 * membre qui est residc moins les forces d'appuis, il faut aussi 
 * remettre a jour les FLX qui travaillent eux en incremental 
 * pour les depl imposes cela revient a imposer un increment nul et 
 * pour les rela unilaterales cela revient a mettre a jour le jeu 
 * 
  RESIDUP= RESIDU ; 
  XXX1   = ZFEXT  ; 
 'SI' ADDISEC2 ; 
    XXX2= XXX1 '+' (FP22 '*' COEFP) ; 
    XXX1= XXX2                  ; 
 'FINS'; 
   
 'SI' (LOGPRE 'ET' IGRD) ; 
   XXX2 = XXX1 '+' (ZFPEXTF '*' COEFP) ; 
   XXX1 = XXX2 ; 
 'FINS' ; 
   
   
      'SI' LOGPIL ; 
 *    Modification du chargement 
         XXX1 = XXX1 '+' (ETA '*' ZFPILIN); 
     'FINSI' ; 
   
   
 * forces exterieures(+ autres termes p.ex. en dynamique ou en poreux) 
 * sans reactions 
 *  - forces interieures(+ autres termes p.ex. en dynamique ou en poreux) 
   
 RESIDU = XXX1 - FEQU2; 
 * forces exterieures(+ autres termes p.ex. en dynamique ou en poreux) 
 * + reactions 
 FEQUI =  XXX1 - FCORF; 
   
 * forces exterieures(+ autres termes p.ex. en dynamique ou en poreux) 
 * + reactions - forces interieures(+ autres termes p.ex. en dynamique 
 * ou en poreux) 
 RESIDC=  RESIDU - FCORF; 
   
 * relations unilaterales et autres(Reinitialisation) 
 *'SI' IMPO12 ; 
        XXX1 = RESIDU +ZFLX1;'DETR' RESIDU; 
        RESIDU = XXX1 - FCORU;'DETR' XXX1; 
       'SI' (IPILOT 'ET' IMPO12); 
                XXX3 =COEPI-1.D0*DIMPOV; 
                XXX1= RESIDU + XXX3;'DETR' RESIDU;RESIDU=XXX1; 
               'DETR' XXX3; 
       'FINS'; 
 *'FINS'; 
 XXX1 = FEQUI - ZFPLO; 
 ZFAU1 = 'ABS'  XXX1  ;'DETR' XXX1; 
 XAUXF = 'MAXI' ZFAU1 'ABS' 'SANS' MXMFLX; 
 'SI' TSTMOM ; 
    XAUXM = 'MAXI' ZFAU1 'ABS' 'AVEC' MXMYMZ; 
 'FINS'; 
 'DETR' ZFAU1; 
 **'DETR' ZDETOT ; 
 COEINC = 0.D0; 
 * 
 * Calcul du nouveau alpha pour le pilotage ----------------------------- 
 * 
 'SI' (IPILOT 'ET' PASTEST) ; 
 *   seulement si on a accelere 
 * 
        'SI' (WTAB.'VISCOPLASTIQUE' 'OU' WTAB.'VISCODOMMAGE' 
        'OU' ITHER 'OU' LOGDEF ); 
              'MESS' 'ALPHA calcule avec la norme de l increment' ; 
               COEPI0 = COEPI; 
               COEPI = 'MINI' ('PROG' 1. (STAB12.'AUTOCOEF' * al1) ); 
 *           les acceleration auront lieu toutes les 4 pas 
               COEINC =COEPI0 - COEPI ; 
 *              ITACC=3 ; 
       'SINON' ; 
 *          les multiplicateurs sont affectes d'un signe - 
               XXX1 = 'EXCO' ZDEPT 'LX' 'NOID' 'LX'; 
               XXX2=2.D0 * XXX1;'DETR' XXX1; 
               XXX4=ZDEPT - XXX2;'DETR' XXX2; 
               XXX3=DFEXT0L *(  COEPI * ( 1 - AL1 )); 
               XXX2 = XXX3 + RESIDC;'DETR' XXX3;XXX5=RESIDNOR* 1.D0; 
              'SI' IMPO12 ; 
                    XXX1= COEPI * ( 1 - AL1 ) * DIMPO12; 
                    XXX3= XXX2  - XXX1;'DETR' XXX1;'DETR' XXX2; 
                    XXX2 = XXX3;XXX1 = XXX5 - DIMPO12; 
                   'DETR' XXX5; XXX5=XXX1; 
              'FINS'; 
              'SI' ADDISEC2; 
                   XXX7  = XXX5 '+' FP22 ; 
                   CORFR = XXX7 '-' FP022; 
              'FINS'; 
   
               XX3 ='XTY' RESIDNOR XXX4 MLDUAL MLPRIM; 
               XX1 ='XTY' XXX2     XXX4 MLDUAL MLPRIM; 
               XX2 ='XTY' XXX5     XXX4 MLDUAL MLPRIM; 
               COEINC =  XX1 '/' XX2; 
              'DETR' XXX4;'DETR' XXX2;'DETR' XXX5; 
               COEPI0 = COEPI; 
               COEPI = 'MINI' ('PROG' (COEPI0 - COEINC) 1.d0 ) ; 
              'SI' ((COEPI0 'EGA' 1d0) 'ET' (AL1 'EGA' 1D0)); 
                    COEPI = 1d0; 
              'FINS'; 
               COEINC = COEPI0 - COEPI; 
              'SI' ((COEPI 'EGA' 1d0) 'ET' (COEPI0 'NEG' 1d0));ITACC=3; 
              'FINS'; 
      'FINS' ; 
 * mise a jour de ZFEXT en fonction de coepi on ne met a jour 
 * de maniere definitive que les forces, les modifs sur les FLX 
 * pour reimposer les conditions de deplacements ne 
 * sont faites que pour le premier residu attention au cas des jeux 
 * sortis de IMPO qu'il ne faut pas toucher 
        XXX3 = DFEXT0F '*' COEINC ; 
        XXX2 = ZFEXT '-' XXX3;'DETR' XXX3; 
       'DETR' ZFEXT; ;ZFEXT = XXX2; 
       'SI' ADDISEC2; 
          MZPRES2=COEPI   '*' DMZPRES '+' MZPRES0; 
          COEFP  =MZPRES2 '/'(MZPRES  '+' XPETIT); 
          XXX3 = FP22  '*' COEFP; 
          XXX2 = ZFEXT '+' XXX3; 
         'DETR' XXX3; 
       'FINS'; 
        XXX1= XXX2 - FEQU2; 
       'DETR' RESIDU;XXX3=COEPI * DFEXT0L; XXX4= XXX3 + FLXINI; 
       'DETR' XXX3; XXX3 = XXX4 - FCORU;'DETR' XXX4; 
        RESIDU = XXX1 + XXX3;'DETR' XXX3; 
        'SI' IMPO12; 
               XXX3= 1.D0 - COEPI * DIMPO12; 
               XXX2= RESIDU + XXX3; 'DETR' RESIDU; 
               RESIDU = XXX2; 'DETR' XXX3; 
       'FINS'; 
       'SI' (ITHER  'OU' WTAB.'MATVAR') ; 
               XXX3 = FTHE * COEINC; 
               XXX2= RESIDU + XXX3; 'DETR' RESIDU; 
               RESIDU = XXX2; 'DETR' XXX3; 
       'FINS'; 
       'SI' LOGDEF ; 
               XXX3 = FDEF * COEINC; 
               XXX2= RESIDU + XXX3; 'DETR' RESIDU; 
               RESIDU = XXX2; 'DETR' XXX3; 
       'FINS'; 
   
        STAB12.'AUTOCOEF'= COEPI ; 
 * 
 *       mise a jour des termes force de l'acceleration de convergence 
       'SI' WTAB.'PROCEDURE_CHARMECA'; 
             XXX1= COEINC * CORFR;'DETR' CORFR; 
       'SINON'; 
             XXX1=(COEINC * RESIDNOR) 'ENLE' FLX; 
       'FINS'; 
   
        XXX3 = ACFEP2 - XXX1 ; 
        XXX4 = ACFEP1 - XXX1 ; 
       'DETR' ACFEP2; ACFEP2= XXX3; 
       'DETR' ACFEP1; ACFEP1= XXX4; 
       'DETR' XXX1; 
   
 *      test si on est sur une branche descendante 
 *            corprec est la correction de precision 
        CORPREC = 1. ; 
       'SI' (COEPI < 0) ; 
            CORPREC = ZPRECD / ZPREC; 
           'MESS' 'Chargement decroissant. Critere divise par ' CORPREC; 
       'FINS'; 
       'SI' ISNPB ; 
           'SI' ( COEPI > 0) ; 
                 ISNPB = FAUX ; 
           'FINS' ; 
       'FINS' ; 
       'MESS' 'nouvelle valeur de ALPHA' COEPI; 
 'FINS' ; 
 * 
 'DETR' FCORU; 
   
 XNUMF = 'MAXI' RESIDC 'ABS' 'SANS' MXMFLX; 
 XNUMG = 'MAXI' ((ZDEPL '-' ZDEPLP) '*' ZCLIM) 'ABS'; 
 XNUMF = 'MAXI' ('PROG' XNUMF XNUMG); 
 * 
 'SI' TSTMOM ; 
        XNUMM= 'MAXI' RESIDC 'ABS' 'AVEC' MXMYMZ; 
 'FINS'; 
 * 
 'SI' IFTOL; 
        ZPREC =  ZFTOL ; 
        XDENO  = 1.; 
 'FINS'; 
 'SI' IMTOL; 
       ZPRECM = ZMTOL ; 
       XDENOM = 1.; 
 'FINS'; 
 * 
 XCONV = XNUMF/ XDENO ; 
 XCONVM = XCONV ; 
 * 
 'SI' TSTMOM ; 
       'SI' ( '<'   XAUXM  XPETIT ) ; 
              XCONVM=0.; 
       'SINON'; 
             'SI' ( <   (XAUXF / XAUXM)  1.D-12 ) ; 
                   XCONV=0.; 
             'FINS'; 
              XCONVM =XNUMM/ XDENOM ; 
       'FINS'; 
 'FINS' ; 
   
 *  residu etant calcule on met a jour zdep1d qui doit etre coherent avec residu 
 zdep1d = zdep1 'ENLE' 'LX'; 
 ** 
   
   
   
 * 
 *--------------------------------------------------------------------- 
 *                resume de l'iteration 
 *--------------------------------------------------------------------- 
 * 
            'MESS'  IT*13 MMC*26 XCONV*39  DPSMAX*52 EPSM*65 XCONVM*78  ; 
   
 * Faut-il reactualiser K ? ----------------------- 
 * Faut-il detruire RESIDUP ? 
 DETRRES = vrai; 
   
 * en grand deplacement, on teste la decroissance du residu 
 'SI' (DETRRES); 'DETR' RESIDUP; 'FINS'; 
 * on quitte si tout s'est bien pass√© ... 
   
 ******************************************************************** 
 * 
 *  on sauve le deplacement si le critere est bon au cas ou il y ait une 
 *  non conv 
 * 
    'SI'(xconv < xconvp);  zdeptm = zdept ; xconvp = xconv ; 'FINS'; 
   
 *--------------------------------------------------------------------- 
 *                 test de convergence 
 *--------------------------------------------------------------------- 
 * 
 TABCONV.IT=XCONV; 
 'SI' nconvr; 
    'MESS' 'non convergence due a une reduction d urgence '; 
    ZICONV = FAUX; 
     'QUITTER' etiq; 
 'FINSI'; 
 'SI' IPILOT;'SI' ((MMC 'EGA' 0) 'ET' (MMCMAX > 0.) 'ET' (COEPI < 0.)); 
 *  on refuse de converger si on est elastique et en decharge 
     COEPI = 'ABS' COEPI;PASTEST = VRAI; 
 'FINS'; 'FINS'; 
 *  on refuse de converger a la premiere iteration si frottement 
   'SI' (WTAB .'CAFROTTE' 'ET' IMPO12 'ET' (IT < 2 )); 
     PASTEST=VRAI; 
   'FINS'; 
    PASUNIL = FAUX; 
    'SI' ('EXIS' ZRAID_T 'OK'); 
            'SI' ( 'NON' ZRAID_T.'OK'); 
                  PASUNIL= VRAI; 
            'FINS'; 
    'FINS'; 
   
 'SI' (('NON' PASTEST) 'ET' 
      (('NON' IRAUG) 'OU' ((it > 1) 'OU' (DPSMAX > 1e-3)))); 
 * variation de Despi entre 2 it√©r√©s 
 DEPSTD  = DEPST - DEPSTP ; 
 DEPSTDM = 'MAXI' 'ABS' DEPSTD 'AVEC' MLDEFOR; 
 *  on  ne peut pas tester la convergence apres une acceleration 
 * ni apres une initialisation a partir de la solution precedente 
    'SI' ( ( IT > 1) 'OU' ('NON' INIT) ) ; 
 *   si les criteres (deplacements + moments) sont < precision 
 *   et la variation sur Depsi est < precision souhaitee : on a converg√©! 
   
         'SI' ( XCONV   < (ZPREC  * CORPREC )) ; 
         'SI' ( XCONVM  < (ZPRECM * CORPREC )) ; 
         'SI' ( DEPSTDM < (ZPREC  * CORPREC )) ; 
         'SI' PASUNIL; 
       'MESS' ' ****** NON CONVERGENCE DE CONTACT A L''ITERATION' ' ' IT ; 
        ZICONV = FAUX; 
        hpp_eps = faux; 
       'SI' IDYN  ; 
                         VITI = UNSURH * 2. * ZDEPT - 
                                conti. 'VITESSES'; 
                         VITI = 'ENLE' VITI 'LX' ; 
 *DMODI_NB 
                         ZVITET = VITI - conti. 'VITESSES'; 
                         ACCEI = UNSURH * 2. * ZVITET - 
                                conti. 'ACCELERATIONS'; 
                         ACCEI = 'ENLE' ACCEI 'LX' ; 
 *FMODI_NB 
                         ZFPU = ZDYFEXT - FFDYN; 
 * forces exterieures + reactions - forces interieures a la fin du pas 
 * c.a.d. (masse*acceleration ) + (amortissement*vitesse ) + (residu = qu 
                         ZFP  = ZFPU - FCORF; 
                        'DETR' ZFPU;'DETR' FFDYN;'DETR' ZDYFEXT; 
       'FINS'; 
   
   
   
   
   
       'QUITTER' ETIQ; 
         'FINS'; 
       'SI' (IRAUG 'ET' AUTAUG 'ET' ((DPSMAX > ZPREC) 'OU' (augmult > 1e2)) 'OU' (resmul < 0.99)); 
       'MESS' ' ****** NON CONVERGENCE DUE A L AUGMENTATION A L''ITERATION' ' ' IT ; 
        ZICONV = FAUX; 
       'QUITTER' ETIQ; 
       'FINS'; 
         'SI' ('NON' HPP_EPS) ; 
   
 *      la precision est satisfaisante 
                'MESS' ' ****** CONVERGENCE A L ITERATION' ' ' IT 
                           '  SOUS-PAS' ' ' WTAB . 'ISOUSPAS'; 
                'MESS' ' '; 
 *  on sauve le nombre de points plastique 
                STAB12.'NBPLAS'= MMC ; 
               'SI' IDYN  ; 
                         VITI = UNSURH * 2. * ZDEPT - 
                            conti. 'VITESSES' ; 
                         VITI = 'ENLE' VITI 'LX' ; 
                         ZFPU = ZDYFEXT - FFDYN; 
 * forces exterieures + reactions - forces interieures a la fin du pas 
 * c.a.d. (masse*acceleration ) + (amortissement*vitesse ) + (residu = qu 
                         ZFP  = ZFPU - FCORF; 
                        'DETR' ZFPU;'DETR' FFDYN;'DETR' ZDYFEXT; 
   
       'SI' ('EXIS' WTAB 'MOD_LIA'); 
        'SI' ('EXIS' WTAB.'MOD_LIA' 'MATE' 'NEWMARK') ; 
          'SI' ('EGA' 'CHPOINT  ' ('TYPE' FLIAI) ) ; 
           MODNEW = 'EXTR' WTAB.'MOD_LIA' 'MATE' 'NEWMARK' ; 
           MAUNEW = 'EXTR' MODNEW 'MAIL' ; 
           'SI' ('EXIS' ZFLIA MODNEW) ; 
              ZFLIANEW = 'REDU' ZFLIA MODNEW ; 
              NZNEW = 'EXTR' ZFLIANEW 'NBZO' ; 
             ZFPNW = 0. ; XVITW = 0. ; 
            'REPETER' BZLIAW NZNEW ; 
 * un point support par zone - 2010 kich 
          ZFPNW = ZFPNW + 
   ('EXCO' ('EXTR' ZFLIANEW 'FLIA' &BZLIAW 1 1) MLDUAL 'NOID') ; 
               XVITW = XVITW + 
   ('EXCO' ('EXTR' ZFLIANEW 'FLIA' &BZLIAW 1 1) MVPRIM MLPRIM 'NOID') ; 
            'FIN' BZLIAW ; 
   
             ZFP = ZFP +  ZFPNW ; 
           'FINS' ; 
          'FINS' ; 
        'FINS' ; 
   
        'SI' (NZLIA > 0) ; 
             XVIT2 = 0.d0; 
   
            'REPETER' BZLIA NZLIA ; 
              XVIT2 = XVIT2 + 
   ('EXCO' ('EXTR' ZFLIA 'FLIA' &BZLIA 1 1) MVPRIM MLPRIM 'NOID') ; 
            'FIN' BZLIA ; 
         'SI' ('EGA' ('TYPE' XVIT2) 'CHPOINT  ') ; 
           MAAUT2 = 'DIFF' ('EXTR' VITI 'MAIL') ('EXTR' XVIT2 'MAIL') ; 
           VITI = ('REDU' VITI MAAUT2) + XVIT2 ; 'DETR' XVIT2 ; 
           'SI' ('EGA' ('TYPE' XVITW) 'CHPOINT  ') ; 
             MAAUT3 = 'DIFF' ('EXTR' VITI 'MAIL') ('EXTR' XVITW 'MAIL'); 
           VITI = ('REDU' VITI MAAUT3) + XVITW ; 'DETR' XVITW ; 
           'FINS' ; 
         'FINS' ; 
          'DETR' FLIAI ;'DETR' ZFLIA ; 
        'FINS' ; 
       'FINS' ; 
   
 *DMODI_NB 
                         ZVITET = VITI - conti. 'VITESSES'; 
                         ACCEI = UNSURH * 2. * ZVITET - 
                                conti. 'ACCELERATIONS'; 
                         ACCEI = 'ENLE' ACCEI 'LX' ; 
 *FMODI_NB 
               'FINS' ; 
                STAB12.'NOMBRE_ITERATIONS' = IT; 
               'QUITTE' ETIQ ; 
        'SINON'; 
   
          CORPREC=1; ITACC=5; 
          EPS_EPS = TEXTE '        '; HPP_EPS = FAUX; 
          xconvp = 1; 
          XCONVMIN = 1e20; 
          DPSMREF  = 0   ; 
          'REPETER' tabraz it; 
           tabconv.&tabraz = 1; 
          'FIN' tabraz; 
   
        PASTEST=VRAI; 
        'MESS' ' passage en grands deplacements'; 
   'SI' autaug;     iraug = faux; 'FINSI'; 
        hppeexit = vrai; 
        ITACC = 4; 
        URG = VRAI; 
        'FINS'; 
        'FINS'; 
        'FINS'; 
        'FINS'; 
 *PV       'FINS'; 
    'FINS' ; 
 *OF 'SINON'; mess 'refus de convergence  al1 ' al1; 
 *OF 'FINS'; 
 'FINS' ; 
 * 
 * 
 * test de non convergence -------------------------------------------- 
 * 
 XCONVREF=1E50; 
 'SI' (IT > WTAB.'DELTAITER'); 
      XCONVREF=TABCONV.(IT-WTAB.'DELTAITER') * 0.99; 
 'FINS'; 
 'SI' (('NON' PASTEST) 'ET' (XCONV < XCONVMIN)); 
 XCONVMIN = XCONV; DPSMREF=DPSMAX/10; 
 'SI' (XCONVMIN < ZPREC); XCONVMIN=ZPREC; 'FINS'; 
 'FINS'; 
 *   si on a depasse le nombre max d'iterations  ou si le residu augmente 
 *   ou si on aurait du converger et que cela n'est pas le cas : 
 *   => non convergence detectee ! 
 'SI'(IT '>EG' ZMAXIT 'OU' (XCONV > XCONVREF) 'OU' 
 ((XCONV < ZPREC) 'ET' ( XCONVM < ZPREC) 'ET' (DEPSTDM < ZPREC)) 
      'ET' ('NON' PASTEST) 'ET' ('NON' NONCONV) 'ET' ( IT > 1) 
      'ET' ('NON' IPILOT) 'ET' ('NON' PASUNIL)); 
       'MESS' ' non convergence detectee 2' ;ZMAXIT = 3 * IT; 
       HPP_EPS=FAUX; 
       URG = VRAI; 
       COEPI = WTAB.'RELAXATION_NONCONV'; 
       STAB12.'AUTOCOEF'= COEPI ; 
       NONCONV = VRAI; 
       itacc=4; 
       'SI' (COEPI < 0.99999); ZICONV = FAUX;  'FINS'; 
       ITNV=IT; 
 'FINS'; 
 * changement de la precision en non convergence 
 **   mess 'unpas 3325  zprecnc pastest' zprecnc ' 'pastest ' ' itnv ' ' it ' ' xconv ' ' xconvref; 
 **'SI' nonconv ;'SI' (it > (zmaxit *2 /3)); zprecnc=zprecnc*2; 
 'SI' nonconv ;'SI' (it > 15); zprecnc=zprecnc*2; 
 'FINS';'FINS'; 
 'SI' ('NON' PASTEST 'ET' (dpsmax < zprecnc)); 
 **mess ' premier test passe '; 
 'SI' ((IT '>EG' ZMAXIT) 
   'OU' (NONCONV 'ET' ('NON' PASTEST) 
        'ET' (XCONV '>' XCONVREF) 
 **     'ET' (XCONV '>' XCONVREF) 'ET' (DPSMAX '>EG'  DPSMREF) 
        'ET' (ITNV 'NEG' IT)) 
   'ET' ('NON' IPREM) ); 
   
       'MESS' ' ****** NON CONVERGENCE A L''ITERATION' ' ' IT  ' SOUS-PAS' ' ' WTAB . 'ISOUSPAS'; 
        ZICONV = FAUX; 
       'SI' IDYN  ; 
                         VITI = UNSURH * 2. * ZDEPT - 
                                conti. 'VITESSES'; 
                         VITI = 'ENLE' VITI 'LX' ; 
 *DMODI_NB 
                         ZVITET = VITI - conti. 'VITESSES'; 
                         ACCEI = UNSURH * 2. * ZVITET - 
                                conti. 'ACCELERATIONS'; 
                         ACCEI = 'ENLE' ACCEI 'LX' ; 
 *FMODI_NB 
                         ZFPU = ZDYFEXT - FFDYN; 
 * forces exterieures + reactions - forces interieures a la fin du pas 
 * c.a.d. (masse*acceleration ) + (amortissement*vitesse ) + residu=qu 
                         ZFP  = ZFPU - FCORF; 
                        'DETR' ZFPU;'DETR' FFDYN;'DETR' ZDYFEXT; 
       'FINS'; 
       'QUITTER' ETIQ; 
 'FINS' ; 
 'FINS' ; 
 ** 'FINS' ; 
 * 
 'DETR' FEQU2; 
 'SI' IDYN ; 
   'SI' (ADDISEC2 'OU' LOGPRE); 
      XXX1=ZFCONSTA '-' ZFP1; 
     'SI' ADDISEC2 ; 
        XXX1=XXX1 '+' FP22   ; 
     'FINS'; 
     'SI' LOGPRE ; 
        XXX1=XXX1 '+' ZFPEXTF; 
     'FINS'; 
      ZDYFEXT = XXX1 'ENLEVER' 'FLX';'DETR' XXX1; 
   'FINS'; 
 'FINS' ; 
 * 
 *KTAN*DEBUT************************************************************* 
 * EVALUATION DE LA MATRICE TANGENTE SI DEMANDEE 
 'SI' IKTAN ; 
   'SI' ('NON' IFEFP) ; 
     'SI' ('MULT' ZITAC ZNCONS) ; 
 *     'SI' IKT ; 
 *       'DETR' ZRIKTA 'ELEM' ;  'DETR' ZRAID ; 
 *     'FINS' ; 
       'SI' (IGRD 'ET' ('NON' HPP_EPS)); 
         'FORM' GEOM2 ; 
         ZMATloc = ZMAT2 ; 
       'SINON' ; 
         ZMATloc = ZMAT ; 
       'FINS' ; 
   
       'SI' ('NON' ISSTE) ; 
         'SI' IPERT ; 
           'SI' PARTLOCA ; 
             cha1 = 'ASSIS' 'TOUS' 'REDU' MODRELOC Z1COMP ; 
             cha2 = 'ASSIS' 'TOUS' 'REDU' MODRELOC Z2COMP ; 
             zktap = 'ASSIS' 'TOUS' 'KTAN' 'PERT' MODRELOC cha1 cha2 
                                           'C1' ZPERC1 'C2' ZPERC2 
                                           ZKTASYM ; 
             ZRIKTA = 'ET' zktap ; 
           'SINON'; 
             ZRIKTA = 'KTAN' 'PERT' ZMODL Z1COMP Z2COMP 
                             'C1' ZPERC1 'C2' ZPERC2 ZKTASYM ; 
           'FINS'; 
 * Attention au ZMAT et ZSIGF a utiliser en IGRD !! 
         'SINON' ; 
           'SI' ('ET' ('NON' IVISCO) ('NON' IVIDOM)) ; 
             DTTAN = 0. ; 
           'SINON' ; 
             DTTAN = STAB12.'DT' ; 
           'FINS' ; 
           ZRIKTA = 'KTAN' ZMODL ZSIGF ZVARF ZMATloc 
                                 'PREC' ZPREK 'DT  ' DTTAN ZKTASYM ; 
         'FINS' ; 
       'FINS' ; 
   
       'SI' IKSIA ; 
         KSIG = 'KSIGMA' ZMODL ZSIGF ZMATloc ; 
         ZRIKTA = ZRIKTA 'ET' KSIG ; 
       'FINS' ; 
   
       ZRAID = ZRIKTA 'ET' ZCLIM ; 
   
       'SI' IGRD ;  'FORM' GEOM1 ;  'FINS' ; 
   
       IKT = VRAI ; ZMATloc = 1. ; 
   
     'FINS' ; 
   'FINS' ; 
 'FINS' ; 
 *KTAN*FIN*************************************************************** 
 * 
 'SI' (IGRD 'ET' ('NON' HPP_EPS)); 
 'SI' ('EGA' ('TYPE' GEOM2) 'CONFIGUR'); 
      'DETR' GEOM2 ; 
 'FINS'; 
 *     'SI' ITCAR ;  'DETR' ZMAT2R ;  'FINS'; 
 'FINS' ; 
 * 
 *'SI' IPLAVI ; 
 *     'DETR' ZSIGF ;  'DETR' ZVARF ;  'DETR' ZDEIF ; 
 *'FINS' ; 
   
 'SI' IFEFP ; 'DETR' ZRIKTA ; 'DETR' GEOM2;  'FINS' ; 
 * 
 IPREM = FAUX;      IAFAIR=VRAI; RECA_K = FAUX; 
 * 
 'FIN' ETIQ ; 
  'FORM' geom1; 
  augmult = augmult * 0.55 ; 
 **  si (augmult < 0.6); augmult = 0.6; finsi; 
  zdep1d = zdept 'ENLE' 'LX'; 
   
 *======================================================================= 
 *===== FIN DE LA BOUCLE DE CONVERGENCE                             ===== 
 *======================================================================= 
 * 
 * 
 *  on sauve les pseudo forces de frottement pour initialiser 
 *  l'iteration suivante 
 'SI' (WTAB. 'CAFROTTE' 'ET' IMPO12); 
      STAB12.'FFROT'= 'COPIER' FFROT; 
 'FINS'; 
 **  ON cherche a sauver la partie Forces nonlineaires trouvee pendant 
 *  ce pas pour s'en servir pour l'estimation  de l'initialisation du pas 
 *  DFNL = K*DU  - DF  - residu 
 *  Ktot*dutot ne contient pas les forces de reactions mais les forces 
 * internes dues a un champ de deformation initiales ( thermique) 
 * donc  enlever ZDFINI au lieu de DFEXT0 
 * pour les forces suiveuses on fait delta FP 
 * pour etre plus precis on fait  aussi intervenir le residu 
 * 
                STAB12.'RESIDU' = RESIDC; 
 ***            'SI' ('NEG' ('TYPE' ZRAIDNA) 'RIGIDITE'); ZRAIDNA = ZRAID; 'FINSI'; 
             zraidna = zraid; 
                XXX1 = ZRAIDNA * ZDEPT; 
                XXX3 = ZDFINI * COEPI; 
                XXX4 = XXX1 - XXX3; 
                XXX3 = XXX4 + RESIDC; 
                XXX1 = XXX3 - FREAP ; 
                XXX5 = XXX1 'ENLEVER' 'FLX ' ; 
                'DETR' XXX1 ; 'DETR' XXX3 ; 'DETR' XXX4 ; 
 * en cas de non convergence on cumule les forces non lineaires 
            'SI' WTAB.'CONV'; 
                STAB12.'FNONL' = XXX5 ; 
            'SINON'; 
                STAB12.'FNONL' = XXX5 + STAB12.'FNONL'; 
                'DETR' XXX5 ; 
            'FINS'; 
 *fba verifier                WTAB.'ITERPREC' =IT; 
                STAB12.'DTPREC'= WTAB.'DT_INIT'; 
 **             STAB12.'DTPREC'= STAB12.'DT' ; 
 * 
 * On garde la derniere matrice KTAN calculee dans ETIQ si necessaire 
 'SI' IKTAN ; 
   'SI' IFEFP ; 
 *  'MESS' 'FEFP: Last KTAN is kept for next increment' ; 
     STAB12.'LASTKTAN' = ZRIKTA ; 
   'SINON' ; 
     'SI' (IKT_SAUV 'ET' IKT) ; 
 *     'MESS' 'KTAN : La matrice est conservee pour le pas suivant' ; 
       STAB12.'LASTKTAN' = ZRIKTA ; 
     'FINS' ; 
   'FINS' ; 
 'FINS' ; 
 * 
 *  quelques destructions supplementaires 
 * 
 'SI' IPLAVI ; 
       'SI' ('NEG' WTAB.'MOVA' 'RIEN') ; 
 *             'DETR' ACC0;  'DETR' ACC; 
        'FINS' ; 
 **        'DETR' DEPIN0 ; 
 'FINS' ; 
 'DETR' ZFEXT ; 'DETR' FREAP ; 
 'SI' IPILOT; 
           'SI' ITHER ; 
             'DETR' FTHE ; 
              XXX1= (TETA2 - TETA1) * COEPI + TETA1; 
              STAB12.'TET2' = XXX1; 
              ETT MSRTT = PAS_EPTH PRECED ZMODL ZMAT XXX1; 
           'FINS'; 
           'SI' LOGDEF ; 
              XXX1 = 'REDU' (DDEFOR0 '*' COEPI) ZMODLI; 
              STAB12.'DEFOR2' = STAB12.'DEFOR1' '+' XXX1    ; 
             'DETR' XXX1;'DETR' FDEF ; 
           'FINS'; 
 'FINS'; 
   
 'SI'  IDYN  ; 
            STAB12.'FOPL' = ZFP ; 
            STAB12.'VITI' = VITI; 
            STAB12.'ACCEI' = ACCEI; 
            'SI' IMPLP; STAB12.'VAUX' = VADD; 'FINS'; 
 'FINS' ; 
 'SI' IGRD; 
 * SP : en lagrangien total, on exprime l'increment sur la configuration 
 *      de reference (debut de calcul) : 
  'SI' (LAG_TOT 'EGA' 1); 
     'FORM' georef0; 
     DEPST = 'CAPI' HYPDEF ZU1  DEPST ZMODL; 
     'FORM' GEOM1; 
  'FINS'; 
 'FINS'; 
 DEPS0  = DEFT0 '+' DEPST; 
 *  sinon on transporte la deformation totale sur la configuration fin de pas 
 *  mais ca casse le cas test traction??? 
  'SI' ((LAG_TOT 'NEG' 1) 'ET' IGRD); 
 **    DEPS0 = 'PICA' HYPDEF DEPS0 ZMODL ZDEPT ; 
  'FINSI'; 
 STAB12.'DEFF' = 'REDU' DEPS0 ZMODLI ; 
 'SI'  IPLAVI ; 
    STAB12.'VARF' = 'REDU' ZVARF ZMODLI ; 
    STAB12.'DFPF' = 'REDU' ZDEIF ZMODLI ; 
   
   'SI' IFEFPUL; 
      STAB12.'FOR'= GEOM2 ; 
   'FINS'; 
 'FINS'; 
   
 STAB12.'DEPT' = ZDEPT ; 
 STAB12.'ZU1'  = ('ENLE' ZU1 'LX' ) '+'  ZDEPT ; 
 * 
 'SI' WTAB.'CAFROTTE' ; 
   ZZZR = STAB12.'ZU1' * ZCLIM ; 
   ZFLX = ZZZR - FLXINI ; 
   WTAB.'DFLX' = 'EXCO' ZFLX 'FLX' 'NOID' 'FLX' ; 
 'FINSI' ; 
   
 STAB12.'SIGF' ='REDU' ZSIGF ZMODLI; 
 STAB12.'CONV' = ZICONV ; 
 ** mess 'xdeno sauve ' xdeno; 
 'SI' (ZICONV 'OU' VRAI); 
    STAB12.'XDENO'  = XDENO; 
    STAB12.'XDENOM' = XDENOM; 
 'SINON'; 
 *  STAB12.'XDENO'  = 'MAXI'  ('PROG' STAB12.'XDENO'  XDENO  ); 
 *  STAB12.'XDENOM' = 'MAXI'  ('PROG' STAB12.'XDENOM' XDENOM ); 
 'FINS'; 
   
  STAB12.'DFGRAD' = GR_U_FIN ; 
   
 'SI' IGRD; 
    'SI' ('EGA' GEOM2 'GEOM2'); 
      'SI' ITCAR ; 
         GEOM2 ZMAT2 ='FORM' ZDEPT ZMODLI ZMATI; 
         ZMAT2       ='REDU' ZMAT2 ZMODL       ; 
      'SINON'; 
         GEOM2 = 'FORM' ZDEPT ; 
      'FINS'; 
    'FINS'; 
   
    STAB12.'FOR' = GEOM2 ; 
    'SI'  (&BONOCONV 'NEG' 1); 
      'DETR' GEOM1; 
    'FINS'; 
     GEOM1=GEOM2; 
    'FORM' GEOM1; 
    'SI' WTAB.'ITCAR'; 
       CARA1 = ZMAT2 ; 
    'FINS'; 
 'FINS' ; 
   
 'SI' LOGDEF; 
    STAB12.'DEFOR1'=STAB12.'DEFOR2'; 
 'FINS'; 
   
 STAB12.'ETAT1'= REDU STAB12.'ETAT2' ZMODLI ; 
 'SI' ('EXIS' WTAB 'MOD_CHA') ; 
   ETAZ = 'REDU' STAB12.'ETAT2' WTAB.'MOD_CHA' ; 
   STAB12.'ETAT1' = STAB12.'ETAT1' 'ET' ETAZ ; 
   ETAZ = 1. ; 
 'FINS' ; 
 'SI' ('NEG' WTAB.'DT' STAB12.'DT'); 
    STAB12.'DT'= WTAB.'DT' - STAB12.'DT'    ; 
 'FINS'; 
 TEMPS0 = TI; 
   
   ZCCONV = ZICONV ; 
   'SI' ('NON' ZICONV) ; 
     DEFT0 = DEPS0 ; 
     'SI' ('EXIS' STAB12 'LISEA_M') ; 
       WTAB.'LISEA_M' = STAB12.'LISEA_M' ; 
     'FINS' ; 
     'SI' ('EXIS' STAB12 'RIBLO_M') ; 
       WTAB.'RIBLO_M' = STAB12.'RIBLO_M' ; 
     'FINS' ; 
     'SI' ('EXIS' STAB12 'TET2') ; 
       STAB12.'TET1'  = STAB12.'TET2'  ; 
     'FINS' ; 
     'SI' ITHER ; 
       STAB12.'TETA1' = STAB12.'TETA2' ; 
     'FINS' ; 
   'FINS' ; 
   
 'SI' (ZICONV 'OU' ('NON' WTAB.'CONVERGENCE_FORCEE')) ; 
   'QUITTER'  BONOCONV; 
 'FINS'; 
 WTAB.'CONV'=STAB12.'CONV'; 
 WTAB.'KNOCONV' = KNOCONV; 
 * Convergence forcee -> on reinitialise ZCLIM 
 ZCLIM = ZCLIM0 ; 
   
 *Nombre maximum de sous-pas atteint? si oui, arret de pasapas 
 WTAB.'ISOUSPAS' = WTAB.'ISOUSPAS' + 1; 
 'SI' (WTAB.'ISOUSPAS' >EG WTAB.'MAXSOUSPAS'); 
      'ERREUR' 996 ; 
 'FINS'; 
 'FIN' BONOCONV; 
 ************************************************************************ 
 * fin de la boucle de non convergence 
 ************************************************************************ 
   
 STAB12.'MAT1' = 'REDU' ZMAT2 ZMODLI ; 
   
 'SI' WTAB.'ITCAR'; 
    STAB12.'CARA' = STAB12.'MAT1'; 
 'FINS'; 
   
 'SI' ITHER; 
    STAB12.'ETHER2'    ='REDU' ETT   ZMODLI  ; 
    STAB12.'ETHER1'    = STAB12.'ETHER2'       ; 
   'SI'  POR1 ; 
      STAB12.'MSRTHER2'='REDU' MSRTT ZMODLI; 
   'FINS'; 
 'FINS'; 
   
   
 'SI' LOGPIL ; 
   PRECED.'COEFFICIENT_DE_PILOTAGE' = PRECED.'COEFFICIENT_DE_PILOTAGE' 
                                      'ET' ('PROG' ETA) ; 
 'FINSI' ; 
   
   
 'SI' (('NEG' GR_U_FIN 'INCONNU') 'ET' igrd) ; 
   STAB12.'DFGRAD' = 'REDU' GR_U_FIN ZMODLI ; 
 'SINON' ; 
   STAB12.'DFGRAD' = 'MOT' 'INCONNU' ; 
 'FINS'; 
 WTAB.'DFGRAD' = STAB12.'DFGRAD' ; 
   
  conti.'TEMPS' = conti.'TEMPS' + DT_INIT ; 
 WTAB.'MAT1' = STAB12.'MAT1'; 
 'SI' ('EXIS' WTAB 'MOD_CHA') ; 
    MODZ = 'REDU' ZMAT22 WTAB.'MOD_CHA' ; 
    WTAB.'MAT1' = WTAB.'MAT1' 'ET' MODZ ; 
    MODZ = 1.D0 ; 
 'FINS' ; 
 * mise a jour des conditions aux limites avec les contacts/frottements actifs 
 WTAB.'CLIM' = ZCLIM; 
   
 * Enregistrement du MODELE 
 STAB12.'MO_TOT_PREC' = ZMODLI; 
   
 'OPTI' 'PARA' FAUX; 
 * 
 'FINPROC' STAB12; 
 * PAS_RESU  PROCEDUR  CB215821  20/07/29    21:16:00     10668 
 'DEBP' PAS_RESU TEMP0*'FLOTTANT' IAUTO*'ENTIER' PRECED*'TABLE' ; 
   
   WTAB  = PRECED.'WTABLE'; 
   
 * Recuperation de la table 'ESTIMATION' des champs en fin de pas : 
   estim = PRECED.'ESTIMATION' ; 
   
 * remplissage de la table de 'CONTINUATION' a partir de 'ESTIMATION' 
   'SI' ( 'EXIS' PRECED 'CONTINUATION' ); 
      conti= PRECED.'CONTINUATION'; 
   'SINON'; 
      conti='TABL' ; 
      PRECED.'CONTINUATION' = conti; 
   'FINSI'; 
   
   'SI' ('NEG' estim.'TEMPS' TEMP0 ('VALE' 'PREC')); 
     'MESS' 'Temps differents dans PAS_RESU ?' ; 
      estim.'TEMPS' = TEMP0 ; 
   'FINS'; 
   
 * Transfert des indices de la table "estim" dans "conti" 
   DIM1  ='DIME' estim ; 
   INDEX1='INDE' estim ; 
   
   'REPE' SURi DIM1 ; 
      ii     = &SURi; 
      TYP1   ='TYPE' INDEX1.ii; 
     'SI' ('NEG' TYP1 'MOT'); 
        MOT_tmp = INDEX1.ii ; 
     'SINO'; 
        MOT_tmp ='MOT' INDEX1.ii; 
     'FINS'; 
      conti.MOT_tmp = estim.MOT_tmp ; 
   'FIN' SURi; 
   
 ************************************************************************ 
 *************** Sauvegarde eventuelle des resultats ******************** 
 ************************************************************************ 
 *La sauvegarde n'est faite que si on a eu convergence des calculs : 
    ISAUV = FAUX; 
   'SI' WTAB.'CONV' ; 
      ISAUV ='DANS' WTAB.'IPRESU' TEMP0 ; 
   
     'SI' ('MULT' IAUTO WTAB.'NAURES' ) ; 
        ISAUV = VRAI ; 
     'FINSI' ; 
   'FINSI' ; 
   
   'SI' ISAUV ; 
      NSOR        = WTAB.'NSOR' + 1 ; 
      WTAB.'NSOR' = NSOR            ; 
   
 *    Cas particuliers de 'DEFIN' et 'DEFTO' 
      TABSAUV = WTAB.'TABSAUV' ; 
     'SI' ('NON' TABSAUV.'DEFTO'); 
       'SI' ('EXIS' estim 'DEFORMATIONS'); 
          estim ='ENLE' estim 'DEFORMATIONS'; 
       'FINS'; 
     'FINSI' ; 
   
     'SI' ('NON' TABSAUV.'DEFIN') ; 
       'SI' ('EXIS' estim 'DEFORMATIONS_INELASTIQUES'); 
          estim ='ENLE' estim 'DEFORMATIONS_INELASTIQUES'; 
       'FINS'; 
     'FINSI' ; 
     'SI' ('EXIS' estim 'DFGRAD') ; 
        estim ='ENLE' estim 'DFGRAD'; 
     'FINSI' ; 
   
 *    Transfert des indices de la table "estim" dans PRECED 
      DIM1  ='DIME' estim; 
      INDEX1='INDE' estim; 
   
     'REPE' SURi DIM1 ; 
        ii     = &SURi; 
        TYP1   ='TYPE' INDEX1.ii; 
       'SI' ('NEG' TYP1 'MOT'); 
          MOT_tmp = INDEX1.ii     ; 
          OBJi    = estim.MOT_tmp ; 
   
       'SINO'; 
          MOT_tmp ='MOT' INDEX1.ii; 
          OBJi    = estim.MOT_tmp ; 
         'SI' ('EGA' TYP1 'TABL'); 
           'SI' ('EXIS' estim.MOT_tmp 'SOUSTYPE'); 
             'SI' ('EGA' estim.MOT_tmp.'SOUSTYPE' 'ESCLAVE'); 
                ERRE 21; 
                OBJi ='ETG' estim.MOT_tmp ; 
             'FINS'; 
           'FINS'; 
         'FINS'; 
       'FINS'; 
       'SI'('NON' ('EXIS' PRECED MOT_tmp)); 
          PRECED.MOT_tmp ='TABL' ; 
       'FINS'; 
        PRECED.MOT_tmp.NSOR = estim.MOT_tmp ; 
     'FIN' SURi; 
   
 *----------------------------------------------------------------------- 
 *---  1- Sauvegarde incrementale sous certaines conditions 
 *---  2- Fantomisation (option 'ECONOMIQUE'=VRAI de PASAPAS) pour liberer la memoire 
 *----------------------------------------------------------------------- 
     'SI' WTAB.'ISAUVEGL'; 
        ltpssauv = WTAB.'ISAUVEGA' ; 
       'SI' ('DANS' ltpssauv TEMP0) ; 
         'SI' ('NON' ('EXIS' WTAB ('MOT' 'EPOQUE'))) ; 
            WTAB.'EPOQUE' = DATE 'EPOCH' ; 
         'FINS' ; 
          EPOQ1 ='DATE' 'EPOCH' ; 
   
 *        Sauvegarde : Dernier pas OU toutes les 300 secondes OU si DATE ne marche pas 
 *        Fantomisation si on sauvegarde effectivement ! 
         'SI' (     ('EGA' TEMP0 ('EXTR' ltpssauv ('DIME' ltpssauv))) 
               'OU' ((EPOQ1 '-' WTAB.'EPOQUE') '>EG' 300.D0) 
               'OU' ((WTAB.'EPOQUE' 'EGA' 0.D0) 'ET' (EPOQ1 'EGA' 0.D0))) ; 
   
           'SAUV' 'MUET' PRECED ; 
            WTAB.'EPOQUE' ='DATE' 'EPOCH' ; 
   
           'SI' WTAB.'LECONOMI'; 
              NFFSOR = NSOR '-' WTAB.'NFSOR' '-' 1 ; 
             'SI' ( NFFSOR '>' 0) ; 
   
 *              Boucle sur les instants SAUVES depuis la derniere fantomisation 
               'REPE' DETRES  NFFSOR ; 
                  NSORM2 = WTAB.'NFSOR' - 1 + &DETRES ; 
                 'SI' (NSORM2 '<' 0) ; 
                   'ITER' DETRES ; 
                 'FINSI' ; 
   
 *                Boucle sur les indices a fantomiser 
                 'REPE' SURi DIM1 ; 
                    ii     = &SURi; 
                    TYP1   ='TYPE' INDEX1.ii; 
                   'SI' ('NEG' TYP1 'MOT'); 
                      MOT_tmp = INDEX1.ii     ; 
                   'SINO'; 
                      MOT_tmp ='MOT' INDEX1.ii; 
                   'FINS'; 
                   'FANTOM' PRECED.MOT_tmp NSORM2 ; 
                 'FIN' SURi; 
               'FIN' DETRES ; 
                WTAB.'NFSOR'= WTAB.'NFSOR' + NFFSOR ; 
             'FINSI' ; 
           'FINS' ; 
         'FINSI'; 
       'FINSI'; 
     'FINSI'; 
   'FINSI' ; 
 'FINP' ISAUV ; 
   
 pt = 'PROG'; 
 ps = 'PROG'; 
 'REPETER' i ('DIMENSION' (tab1. 'CONTRAINTES' )); 
   t  = tab1. 'TEMPS'. (&i-1); 
   pt = pt 'ET' ('PROG' tab1. 'TEMPS'. (&i-1)); 
   s  = tab1. 'CONTRAINTES'. (&i - 1); 
   ps = ps 'ET' ('MAXIMUM' ('EXCO' s 'SMZZ')); 
 'FIN'  i; 
   
 EVO2FICH ('EVOL' 'MANUEL' pt ps) 'implicitnorton-castem.res'; 
   
 'FIN' ; 
